- en: 1.5 The Power of Prompt Chaining
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.5 提示链的力量
- en: 原文：[https://boramorka.github.io/LLM-Book/en/CHAPTER-1/1.5%20The%20Power%20of%20Prompt%20Chaining/](https://boramorka.github.io/LLM-Book/en/CHAPTER-1/1.5%20The%20Power%20of%20Prompt%20Chaining/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://boramorka.github.io/LLM-Book/en/CHAPTER-1/1.5%20The%20Power%20of%20Prompt%20Chaining/](https://boramorka.github.io/LLM-Book/en/CHAPTER-1/1.5%20The%20Power%20of%20Prompt%20Chaining/)'
- en: 'Prompt chaining solves complex tasks through a sequence of simple, interconnected
    steps. Instead of one “monolithic” request, you build a chain of small prompts:
    each step solves a specific subtask and prepares context for the next. This reduces
    errors, makes model behavior more controllable, and increases observability: it’s
    easier to see where and why a mistake happened and to intervene precisely. It’s
    like cooking a complex dish step by step or using modular architecture in software
    — it’s always easier to debug and maintain a series of small, clear operations
    than a single spaghetti‑like step.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 提示链通过一系列简单、相互关联的步骤解决复杂任务。而不是一个“单体”请求，你构建一个小的提示链：每个步骤解决一个特定的子任务并为下一步准备上下文。这减少了错误，使模型行为更容易控制，并增加了可观察性：更容易看到错误发生的地方和原因，并精确地干预。这就像一步一步地烹饪复杂的菜肴或使用软件中的模块化架构——总是更容易调试和维护一系列小而清晰的操作，而不是一个像意大利面一样的单一步骤。
- en: 'Practical benefits are clear: you can orchestrate the workflow by checkpointing
    state at each step and adapting the next step to the previous result; save context
    and budget, since long prompts cost more while each chain step uses only the minimum
    needed; reduce errors by isolating the problem; and load only relevant information,
    respecting LLM context limits. Methodologically, this means decomposing the task,
    explicitly managing state between steps, designing each prompt for a narrow focus,
    adding tools for loading and pre‑processing data, and dynamically injecting only
    the context fragments needed right now. Best practices are simple: don’t overcomplicate
    when a single prompt suffices; be clear; keep and update external context; think
    about efficiency (quality, cost, latency); and test the chain end to end.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 实际好处是显而易见的：你可以通过在每个步骤中检查点状态并调整下一步以适应前一步的结果来编排工作流程；节省上下文和预算，因为长提示成本更高，而每个链步骤只使用所需的最小量；通过隔离问题来减少错误；并且只加载相关信息，尊重LLM上下文限制。从方法论上讲，这意味着分解任务，明确管理步骤之间的状态，为每个提示设计狭窄的焦点，添加加载数据和预处理数据的工具，并动态注入当前需要的上下文片段。最佳实践很简单：当单个提示足够时不要过于复杂；保持清晰；保持和更新外部上下文；考虑效率（质量、成本、延迟）；并端到端测试链。
- en: 'Below is a sequential example that assembles an end‑to‑end scenario: entity
    extraction, querying a simple “database”, parsing JSON, and composing a user‑facing
    answer — then tying it all together into a single support flow.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个按顺序组装端到端场景的示例：实体提取、查询简单的“数据库”、解析JSON和编写用户界面答案——然后将所有这些整合成一个单一的支持流程。
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now extract entities from a user request. The first step sets the task and output
    format in a system instruction. The user input is bounded by delimiters, which
    makes it easier to control data boundaries and pass the result along the chain.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从用户请求中提取实体。第一步在系统指令中设置任务和输出格式。用户输入由分隔符界定，这使得控制数据边界和将结果传递到链条中变得更容易。
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, plug in a data source and find the specific products or categories. Even
    an in‑memory “database” demonstrates the idea: extract entities → move to structured
    data → prepare facts for the answer.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，连接一个数据源并找到特定的产品或类别。即使是一个内存中的“数据库”也能演示这个想法：提取实体 → 移动到结构化数据 → 准备答案的事实。
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On the next step, convert JSON strings that the model might return during entity
    extraction into Python objects for downstream chain steps.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，将模型在实体提取过程中可能返回的JSON字符串转换为Python对象，以便进行后续的链步骤。
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, compose a concise user‑facing answer from the resulting structures.
    You can swap this formatting layer for templates, localization, or generation
    tuned to your UX.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，从生成的结构中编写一个简洁的用户界面答案。你可以将这个格式化层替换为模板、本地化或针对你的UX调整的生成。
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We’ll finish with an end‑to‑end support scenario: first detect interest in
    photography, then provide troubleshooting, clarify warranty coverage, and end
    with accessory recommendations — four steps in one chain, each building on the
    previous result.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以一个端到端的支持场景结束：首先检测对摄影的兴趣，然后提供故障排除，明确保修范围，并以配件推荐结束——一个链条中的四个步骤，每个步骤都建立在之前的结果之上。
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the end, prompt chaining gives you a robust and understandable workflow:
    it saves context and budget, localizes errors more precisely, and preserves flexibility
    to tailor the answer to the user’s task.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，提示链式操作为你提供了一个强大且易于理解的流程：它节省了上下文和预算，更精确地定位错误，并保留了根据用户任务定制答案的灵活性。
- en: Theory Questions
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理论问题
- en: What is prompt chaining and how does it differ from using one long prompt?
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提示链式操作是什么？它与使用一个长提示有何不同？
- en: Provide two analogies and explain how they map to chaining.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供两个类比并解释它们如何映射到链式操作。
- en: How does chaining help manage workflow?
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链式操作如何帮助管理工作流程？
- en: Where do the savings come from when using chaining?
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用链式操作时，节省来自哪里？
- en: How does chaining reduce errors on complex tasks?
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链式操作如何减少复杂任务中的错误？
- en: Why is dynamic data loading useful given LLM context limits?
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到LLM上下文限制，动态数据加载为什么有用？
- en: Describe a step‑by‑step methodology for chaining and the role of each step.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述链式操作的逐步方法论以及每一步的作用。
- en: List best practices that ensure chaining efficiency.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出确保链式操作效率的最佳实践。
- en: Which libraries are used in the example and for what?
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 示例中使用了哪些库以及用途是什么？
- en: How does the system message guide the model’s answer?
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统消息如何引导模型的答案？
- en: What is the role of the product database, and how do you query it?
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 产品数据库的作用是什么？如何查询它？
- en: Why convert JSON strings to Python objects, and how?
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么需要将JSON字符串转换为Python对象，以及如何进行转换？
- en: How does formatting answers from processed data improve service quality?
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何通过格式化处理后的数据来提高服务质量？
- en: How does the end‑to‑end scenario demonstrate adapting to user needs via chaining?
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 终端到终端场景如何通过链式操作来适应用户需求？
- en: Practical Tasks
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实践任务
- en: Implement `retrieve_model_response` with `model`, `temperature`, and `max_tokens`
    parameters.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`retrieve_model_response`函数，包含`model`、`temperature`和`max_tokens`参数。
- en: Show an entity‑extraction example using a system instruction.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用系统指令展示实体提取的示例。
- en: Create a mini product database and functions to query by name or category.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个迷你产品数据库和按名称或类别查询的功能。
- en: Implement JSON‑to‑Python list conversion with error handling.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现带有错误处理的JSON到Python列表的转换。
- en: Write `generate_response_from_data` that formats a data list into a user‑friendly
    answer.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`generate_response_from_data`函数，该函数将数据列表格式化为用户友好的答案。
- en: Compose an end‑to‑end support scenario (query → troubleshooting → warranty →
    recommendations) based on the functions above.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于上述功能，编写一个端到端支持场景（查询 → 故障排除 → 保修 → 推荐）。

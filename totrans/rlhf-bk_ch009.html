<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <title>ch009.xhtml</title>
  <link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css" />
</head>
<body epub:type="bodymatter">
<section id="instruction-finetuning" class="level1">
<h1>Instruction Finetuning</h1>
<p>Early large pretrained language models were trained with a next-token prediction objective and, by default, did not come with an explicit interface for following instructions. Around the release of GPT-3 <span class="citation" data-cites="brown2020language"><a href="ch021.xhtml#ref-brown2020language">[167]</a></span>, prompting and in-context learning became a widely used way to adapt a single model to many tasks (though task-specific fine-tuning remained common), by showing examples in-context and asking the model to complete a similar task. A practical next step was instruction finetuning, which teaches the model to respond in an instruction–response format rather than just continuing text.</p>
<p>Instruction finetuning took off when two lines of work converged. First, NLP shifted from bespoke-finetuning task setups to a unified “text-to-text” or instruction framing, which made it straightforward to standardize diverse datasets and train a single model across many tasks. Prominent examples of unifying the framework for tasks include <em>Exploring the Limits of Transfer Learning with a Unified Text-to-Text Transformer</em> (T5 models) <span class="citation" data-cites="raffel2020exploring"><a href="ch021.xhtml#ref-raffel2020exploring">[168]</a></span>, <em>Finetuned Language Models Are Zero-Shot Learners</em> (FLAN dataset) <span class="citation" data-cites="wei2021finetuned"><a href="ch021.xhtml#ref-wei2021finetuned">[169]</a></span>, <em>Multitask Prompted Training Enables Zero-Shot Task Generalization</em> (T0 models) <span class="citation" data-cites="sanh2021multitask"><a href="ch021.xhtml#ref-sanh2021multitask">[170]</a></span>, and <em>Cross-Task Generalization via Natural Language Crowdsourcing Instructions</em> (Natural Instructions dataset) <span class="citation" data-cites="mishra2021cross"><a href="ch021.xhtml#ref-mishra2021cross">[171]</a></span>. Second, scaling pretrained LMs and the rise of prompting/in-context learning showed that a single model could generalize across tasks, but that generalization becomes far more reliable when the model is explicitly trained on instruction–response examples. Together, these trends led to an era of fine-tuning pretrained language models on large collections of instructions—what is now commonly called instruction finetuning (IFT), or supervised finetuning (SFT), in which training general models became accessible to wider audiences. <!-- Historically, until RLHF and related methods, all finetuning was **instruction finetuning** (IFT), also known as **supervised finetuning** (SFT). --></p>
<p>Since its discovery, instruction finetuning, also called colloquially just <em>instruction tuning</em>, has matured and is standard practice across many language modeling pipelines. At its core, IFT is the simplest method for adapting language models to a desired task distribution. It serves as the foundation for RLHF by preparing the model for a format of instructions that is known as question-answering, and it is the first tool used by those attempting to apply modern techniques to new domains. Without a basic level of instruction-following abilities, most of the pipelines we discuss in this book—from preference data collection to online RLHF optimization—cannot be performed.</p>
<section id="chat-templates-and-the-structure-of-instructions" class="level2">
<h2>Chat templates and the structure of instructions</h2>
<p>The beginning of the post-training process is defining a pattern to format user queries so that they are easily readable by a language model that processes information through a tokenizer. When using a pretrained language model, the prompting is quite simple, the model only knows a few tokens: a beginning-of-sequence token (e.g., <code>&lt;bos_token&gt;</code>), an end-of-sequence token (e.g., <code>&lt;eos_token&gt;</code>), and a padding token (to manage training on batches with empty components). This means, to prompt a base model, the user inputs a sequence of tokens for the model to continue from, such as:</p>
<pre><code>&lt;bos_token&gt; The capital of the United States is</code></pre>
<p>Then, the model would generate tokens until it runs out of its context window, or it generates the end-of-sequence token.</p>
<p>All post-training stages, from instruction tuning to RLHF and other methods, rely on this formatting to train the model. The tool that handles the structure of the interaction with the user is called the <strong>chat template</strong>.</p>
<p>An example which we will break down is below:</p>
<pre class="jinja"><code>{% if messages[0][&#39;role&#39;] == &#39;system&#39; %}
    {# If the conversation begins with a system message, treat it as a special first turn.
       We set an offset so the user/assistant alternation check lines up correctly. #}
    {% set offset = 1 %}
{% else %}
    {# No system message: user should be the first non-empty turn. #}
    {% set offset = 0 %}
{% endif %}

{# Emit the beginning-of-sequence token (model-specific). #}
{{ bos_token }}

{# Serialize each message into the model&#39;s chat-markup tokens. #}
{% for message in messages %}
    {# Enforce role alternation: (system), user, assistant, user, assistant, ...
       The boolean expression compares &quot;is this a user message?&quot; against whether the
       current index (plus offset) is expected to be user or assistant. #}
    {% if (message[&#39;role&#39;] == &#39;user&#39;) != (loop.index0 % 2 == offset) %}
        {{ raise_exception(&#39;Conversation roles must alternate user/assistant/user/assistant/...&#39;) }}
    {% endif %}

    {# Wrap each message with special tokens:
       - &lt;|im_start|&gt;&lt;role&gt;\n
       - message content (trimmed)
       - &lt;|im_end|&gt;\n
       This produces a single flat token sequence the LM can train on. #}
    {{ &#39;&lt;|im_start|&gt;&#39; + message[&#39;role&#39;] + &#39;\n&#39; + message[&#39;content&#39;] | trim + &#39;&lt;|im_end|&gt;\n&#39; }}
{% endfor %}

{# Optionally append an &quot;assistant&quot; start tag with no content.
   This cues generation to continue from the assistant role. #}
{% if add_generation_prompt %}
    {{ &#39;&lt;|im_start|&gt;assistant\n&#39; }}
{% endif %}</code></pre>
<p>This is the raw code for transforming a list of dictionaries in Python containing messages and roles into tokens that a language model can predict from.</p>
<p>All information passed into models is assigned a role. The traditional three roles are <code>system</code>, <code>user</code>, and <code>assistant</code>.</p>
<p>The <code>system</code> tag is only used for the first message of the conversation; it holds instructions for the agent in text that will not be received from or exposed to the user. These <strong>system prompts</strong> are used to provide additional context to the models, such as the date and time, or to patch behaviors. As a fun example, models can be told things such as “You are a friendly chatbot who always responds in the style of a pirate.”</p>
<p>Next, the two other roles are straightforward: <strong>user</strong> holds the messages from the person using the AI, and <strong>assistant</strong> holds the responses from the model (that is engaging as an AI assistant).</p>
<p>In order to translate all this information into tokens, we use the code listing above that we started with. The model has a series of <em>special tokens</em> that separate the various messages from each other. If we run the above code with the example query “How many helicopters can a human eat in one sitting?”, the token sequence passed into the model would look as follows:</p>
<pre><code>&lt;|im_start|&gt;system
You are a friendly chatbot who always responds in the style of a pirate&lt;|im_end|&gt;
&lt;|im_start|&gt;user
How many helicopters can a human eat in one sitting?&lt;|im_end|&gt;
&lt;|im_start|&gt;assistant</code></pre>
<p>Notice how the final tokens in the sequence are <code>&lt;|im_start|&gt;assistant</code>. This is how the model knows to continue generating tokens until it finally generates its end-of-sequence token, which in this case is <code>&lt;|im_end|&gt;</code>.</p>
<p>By packing all question-answer pair data (and downstream preference tuning data) into this format, modern language models follow it with perfect consistency. This is the language that instruction tuned models use to exchange information with users and the models stored on GPUs or other computing devices.</p>
<p>The behavior can be extended naively to multiple turns, such as shown below:</p>
<pre><code>&lt;|im_start|&gt;system
You are a friendly chatbot who always responds in the style of a pirate&lt;|im_end|&gt;
&lt;|im_start|&gt;user
How many helicopters can a human eat in one sitting?&lt;|im_end|&gt;
&lt;|im_start|&gt;assistant
Oh just 6.&lt;|im_end|&gt;
&lt;|im_start|&gt;user
Are you sure about that?&lt;|im_end|&gt;
&lt;|im_start|&gt;assistant</code></pre>
<p>In the open ecosystem, the standard method for applying the chat template to a list of messages is a piece of Jinja code saved in the tokenizer, as <code>apply_chat_template</code>.</p>
<p>The above chat template is a derivative of OpenAI’s Chat Markup Language (ChatML), which was an early attempt to standardize message formatting. Now, OpenAI and other model providers use a hierarchical system where the user can configure a system message, yet there are higher-level instructions that may or may not be revealed to the user <span class="citation" data-cites="wallace2024instruction"><a href="ch021.xhtml#ref-wallace2024instruction">[172]</a></span>.</p>
<p>Many other chat templates exist. Some other examples include Zephyr’s <span class="citation" data-cites="tunstall2023zephyr"><a href="ch021.xhtml#ref-tunstall2023zephyr">[21]</a></span>:</p>
<pre><code>&lt;|system|&gt;
You are a friendly chatbot who always responds in the style of a pirate&lt;/s&gt;
&lt;|user|&gt;
How many helicopters can a human eat in one sitting?&lt;/s&gt;
&lt;|assistant|&gt;</code></pre>
<p>Or Tülu’s:</p>
<pre><code>&lt;|user|&gt;
How are you doing?
&lt;|assistant|&gt;
I&#39;m just a computer program, so I don&#39;t have feelings, but I&#39;m functioning as expected. How can I assist you today?&lt;|endoftext|&gt;</code></pre>
<p>Beyond this, many chat templates include formatting and other tokens for tasks such as tool-use.</p>
</section>
<section id="best-practices-of-instruction-tuning" class="level2">
<h2>Best practices of instruction tuning</h2>
<p>Instruction tuning as the foundation of post-training and creating helpful language models is well-established. There are many ways to achieve successful instruction tuning. For example, efficient finetuning with quantization of some model parameters makes training very accessible <span class="citation" data-cites="dettmers2023qlora"><a href="ch021.xhtml#ref-dettmers2023qlora">[173]</a></span>. Also, in narrow domains such as chat alignment, i.e., without harder skills such as math or code, small, focused datasets can achieve strong performance <span class="citation" data-cites="zhou2023lima"><a href="ch021.xhtml#ref-zhou2023lima">[13]</a></span>.</p>
<p>Soon after the release of ChatGPT, human datasets with as few as 10K samples such as No Robots were state-of-the-art <span class="citation" data-cites="no_robots"><a href="ch021.xhtml#ref-no_robots">[174]</a></span>. Years later, large-scale synthetic datasets work best <span class="citation" data-cites="lambert2024t"><a href="ch021.xhtml#ref-lambert2024t">[6]</a></span> on most tasks.</p>
<p>A few principles remain:</p>
<ul>
<li>High-quality data is key to performance. The completions are what the model actually learns from (in many cases the prompts are not predicted over so the model does not learn to predict prompts).</li>
<li>~1M prompts can be used to create a model capable of excellent RLHF and post-training. Further scaling can still help, but returns diminish quickly.</li>
<li>The best prompts are those in a similar distribution to downstream tasks of interest.</li>
<li>If multiple stages of training are done after instruction tuning, the models can recover from some noise in the process. Optimizing the overall optimization is more important than each individual stage.</li>
</ul>
</section>
<section id="implementation" class="level2">
<h2>Implementation</h2>
<p>While the loss function is the same as pretraining, there are a few key implementation details that differ from the setting used for pre-training. Many practices, such as deciding on the types of parallelism used to shard models across many GPUs are the same as pretraining, just the total number of machines used is often lower (for the first technical change listed below):</p>
<ul>
<li><strong>Smaller batch sizes</strong>: Compared to pre-training, instruction tuning (and other post-training techniques such as preference finetuning) use substantially smaller batch sizes. For example, OLMo 2 uses a batch size of 1024 sequences for the 7B and 2048 for the 13B pretraining, while both only use a batch size of 256 sequences at post-training <span class="citation" data-cites="olmo20242"><a href="ch021.xhtml#ref-olmo20242">[59]</a></span>. The smaller batch sizes mean that these training jobs cannot be sharded across as many devices as pretraining – in practice, distributed training setups have minimum per-device batch sizes, so if you’re trying to retain a smaller global batch size for SFT you can use cumulatively fewer GPUs. In practice the batch size forcing a smaller concurrent GPU allotment per training job is not a limiting factor because the training token counts for SFT are much smaller than pretraining, and training for multiple seeds is needed in post-training to obtain the best final performance.</li>
<li><strong>Prompt masking</strong>: When pretraining, every token in the batch is predicted autoregressively and the loss is then applied to them. For instruction tuning, the prompt tokens are masked out so the model isn’t learning to accurately predict user queries – just responses. The same applies for other post-training algorithms.</li>
<li><strong>Multi-turn masking</strong>: For multi-turn conversations, there are two common masking choices. (1) <em>Final-turn only</em>: only the tokens in the final assistant turn are included in the loss, while all earlier context (including earlier assistant turns) is masked. Long conversations can still be “unrolled” into multiple training samples: for a conversation of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math> turns, each example predicts one assistant response while masking all prior context (and excluding any future turns). (2) <em>Mask user turns only</em>: all user turns are masked, but <em>every</em> assistant turn is included in the loss. You can still unroll in this setting if you want more (shorter) training examples, but the key difference is that intermediate assistant replies are trained on directly.</li>
<li><strong>Same loss function as pretraining:</strong> Instruction tuning uses the same autoregressive loss function used in pretraining language models, but with substantially different data and masking (training only on full sequences, whereas pretraining documents can be split across batches), etc.</li>
</ul>
</section>
</section>
</body>
</html>

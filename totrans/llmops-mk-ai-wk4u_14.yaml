- en: 2.3 Deep Dive into Text Splitting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://boramorka.github.io/LLM-Book/en/CHAPTER-2/2.3%20Deep%20Dive%20into%20Text%20Splitting/](https://boramorka.github.io/LLM-Book/en/CHAPTER-2/2.3%20Deep%20Dive%20into%20Text%20Splitting/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Splitting (segmentation) happens after loading data into a “document” format
    but before indexing or storage. The goal is to produce semantically meaningful
    chunks that work well for search and analytics without breaking meaning at the
    boundaries. Two parameters matter most: chunk size and overlap. Size is measured
    in characters or tokens (larger chunks carry more context; smaller ones are easier
    to process). Overlap is the “handoff” between neighboring chunks that helps maintain
    coherence. LangChain provides several strategies: character- and token-based splitting,
    a recursive approach that follows a hierarchy of separators (paragraphs → sentences
    → words), plus specialized splitters for code and Markdown that respect syntax
    and headings. There are also two modes of operation — Create Documents (accepts
    a list of raw text and returns chunked documents) and Split Documents (splits
    previously loaded documents) — so choose based on whether you are working with
    strings or with document objects. In practice, CharacterTextSplitter (simple character-based
    splitting when semantics are less critical) and TokenTextSplitter (token-based
    splitting to fit LLM limits) are the most common. When structure matters, a recursive
    splitter that follows the hierarchy is very helpful. Among the specialized options
    are LanguageTextSplitter for code and MarkdownHeaderTextSplitter for splitting
    by headings while preserving this structure in metadata.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before applying splitters, it’s useful to quickly set up the environment: imports,
    API keys, and dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Splitting strategy strongly affects search and analytics quality, so tune parameters
    to preserve relevance and coherence. The basic choices are CharacterTextSplitter
    and RecursiveCharacterTextSplitter; select based on your data’s structure and
    nature. Below are compact examples: first, a simple splitter with optional overlap
    to help maintain context,'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: and then a recursive splitter which, for “general” texts, more carefully preserves
    semantics by following a hierarchy of separators—from paragraphs to sentences
    to words.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next come a few practical examples. Start with simple strings,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: and then look under the hood with a minimal splitter implementation and its
    behavior on basic inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The example above illustrates how splitting behaves on basic strings—with and
    without explicit separators. Now consider two advanced techniques. First, handling
    more complex text where it’s helpful to explicitly set a hierarchy of separators
    and a chunk size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces coherent chunks that respect the document’s internal structure.
    Second, token-based splitting, where the LLM context window is defined in tokens
    and limits must be strictly observed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: And finally, splitting by Markdown headings, where the document’s logical organization
    guides segmentation and the detected headings are preserved in chunk metadata.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A few quick recommendations: preserve semantics and account for the source
    document’s structure; manage overlap—just enough to maintain coherence without
    unnecessary redundancy; use and enrich metadata to improve context during retrieval
    and answering.'
  prefs: []
  type: TYPE_NORMAL
- en: Theory Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is the goal of document splitting?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does chunk size affect processing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is overlap needed and how does it help analysis?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do `CharacterTextSplitter` and `TokenTextSplitter` differ, and where are
    they used?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a recursive splitter and how does it differ from basic ones?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which specialized splitters exist for code and Markdown, and what are their
    benefits?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is required to set up the environment before splitting?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List the pros and cons of `RecursiveCharacterTextSplitter` and the parameters
    that are important to tune.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the “alphabet” example demonstrate when comparing simple and recursive
    approaches?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What should you pay attention to when choosing between characters and tokens
    for LLMs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does splitting by Markdown headings preserve logical structure and why is
    that important?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What best practices help preserve semantics and manage overlap?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Practical Tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write a function `split_by_char(text, chunk_size)` that returns a list of fixed-size
    chunks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `chunk_overlap` parameter to `split_by_char` and implement overlapping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a class `TokenTextSplitter(chunk_size, chunk_overlap)` with a `split_text`
    method that splits text by tokens (tokens separated by spaces).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a function `recursive_split(text, max_chunk_size, separators)` that recursively
    splits text using a given list of separators.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a class `MarkdownHeaderTextSplitter(headers_to_split_on)` with a `split_text`
    method that splits Markdown by the specified headings and returns chunks with
    the corresponding metadata.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

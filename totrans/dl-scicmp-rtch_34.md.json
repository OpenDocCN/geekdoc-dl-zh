["```r\nlibrary(torch)\n\ndft <- function(x) {\n n_samples <- length(x)\n n <- torch_arange(0, n_samples - 1)$unsqueeze(1)\n F <- torch_complex(\n torch_zeros(n_samples),\n torch_zeros(n_samples)\n )\n\n for (k in 0:(n_samples - 1)) {\n w_k <- torch_exp(-1i * 2 * pi / n_samples * k * n)\n dot <- torch_matmul(w_k, x$to(dtype = torch_cfloat()))\n F[k + 1] <- dot\n }\n F\n}\n```", "```r\ndft_vec <- function(x) {\n n_samples <- length(x)\n\n n <- torch_arange(0, n_samples - 1)$unsqueeze(1)\n k <- torch_arange(0, n_samples - 1)$unsqueeze(2)\n mat_k_m <- torch_exp(-1i * 2 * pi/n_samples * k * n)\n\n torch_matmul(mat_k_m, x$to(dtype = torch_cfloat()))\n}\n```", "```r\n# straightforward, recursive implementation of the FFT.\n# Expects input size to be a power of 2.\nfft <- function(x) {\n n_samples <- length(x)\n if (n_samples == 1) {\n return(x)\n }\n\n X_upper <- fft(x[1:n_samples:2])\n X_lower <- fft(x[2:n_samples:2])\n\n w_k <- torch_exp(\n -2 * pi * torch_complex(0, 1) *\n torch_arange(0, n_samples / 2 - 1) / n_samples\n )\n torch_cat(list(\n X_upper + w_k * X_lower,\n X_upper - w_k * X_lower\n ))\n}\n```", "```r\nlibrary(torch)\nlibrary(gsignal)\n\n# requirements: input length is at least 4, and a power of 2\nfft_matrix <- function(x) {\n\n # perform sorting just once, a the beginning\n x <- torch_tensor(\n bitrevorder(as.numeric(x)),\n dtype = torch_cfloat()\n )\n\n n_samples <- length(x)\n\n # smallest butterfly matrix, needed for all valid inputs\n B2 <- torch_tensor(\n c(1, 1, 1, -1),\n dtype = torch_cfloat()\n )$view(c(2, 2))\n B2_block <- torch_block_diag(\n B2$`repeat`(c(n_samples / 2, 1))$split(2)\n )\n acc <- torch_matmul(B2_block, x)\n\n # iterative implementation then starts with B4\n n <- 4\n\n while (n <= n_samples) {\n\n # build up current butterfly matrix\n I <- torch_eye(n / 2)\n O <- torch_diag(\n torch_exp(\n -1i * 2 * pi *\n torch_arange(0, n / 2 - 1) / (n / 2 * 2)\n )\n )\n B <- torch_cat(list(\n torch_cat(list(I, O), dim = 2),\n torch_cat(list(I, -O), dim = 2)\n ), dim = 1)\n\n # in the final multiplication,\n # B directly matches input length\n if (n == n_samples) {\n return(torch_matmul(B, acc))\n }\n\n # create block-diagonal matrix from butterflies\n # at each iteration,\n # we need to replicate B {n_samples/rank(B) times}\n # this is achieved by first repeating B row-wise,\n # then splitting up into rank(n) parts)\n B_block <- torch_block_diag(\n B$`repeat`(c(n_samples / n, 1))$split(n)\n )\n acc <- torch_matmul(B_block, acc)\n n <- n * 2\n }\n acc\n}\n```", "```r\n# torch translation of\n# http://jakevdp.github.io/blog/2013/08/28/\n# understanding-the-fft/#Vectorized-Numpy-Version\n\nfft_vec <- function(x) {\n n_samples <- length(x)\n # could be chosen higher for performance reasons\n n_min <- 2 \n\n # Perform an O[N^2] DFT on all length-N_min \n # sub-problems at once\n n <- torch_arange(0, n_min - 1)$unsqueeze(1)\n k <- torch_arange(0, n_min - 1)$unsqueeze(2)\n\n # by starting with one (vectorized-by-matmul)\n # \"classic DFT\" (instead of a block matrix of B_mins),\n # we don't need the bitrevorder step\n mat_k_m <- torch_exp(-1i * 2 * pi / n_min * k * n)\n F <- torch_matmul(\n mat_k_m,\n x$to(dtype = torch_cfloat())$reshape(list(n_min, -1))\n )\n\n # build-up each level of the recursive calculation\n # all at once\n while (dim(F)[1] < n_samples) {\n F_first <- F[, 1:(dim(F)[2] / 2)]\n F_second <- F[, (dim(F)[2] / 2 + 1):dim(F)[2]]\n # only need first half of w_ks\n w_k <- torch_exp(\n -1i * pi *\n torch_arange(0, dim(F)[1] - 1) / dim(F)[1]\n )$unsqueeze(2)\n F <- torch_vstack(list(\n F_first + w_k * F_second,\n F_first - w_k * F_second\n ))\n # w_k * F_second multiplies both at once (column-wise)\n }\n F$ravel()\n}\n```", "```r\nx <- torch_randn(2^13)\natol <- 1e-4\n\ny_ref <- torch_fft_fft(x)\n\ny_dft <- dft(x)\ny_dft_vec <- dft_vec(x)\ny_fft <- fft(x)\ny_fft_vec <- fft_vec(x)\ny_fft_matrix <- fft_matrix(x)\n\ntorch_allclose(y_dft, y_ref, atol = atol)\ntorch_allclose(y_dft_vec, y_ref, atol = atol)\ntorch_allclose(y_fft, y_ref, atol = atol)\ntorch_allclose(y_fft_vec, y_ref, atol = atol)\ntorch_allclose(y_fft_matrix, y_ref, atol = atol)\n```", "```r\n[1] FALSE\n[1] FALSE\n[1] TRUE\n[1] TRUE\n[1] TRUE\n```", "```r\nset.seed(777)\ntorch_manual_seed(777)\nlibrary(bench)\nlibrary(dplyr)\nlibrary(ggplot2)\n\nres <- mark(dft(x),\n dft_vec(x),\n fft(x),\n fft_vec(x),\n fft_matrix(x),\n torch_fft_fft(x),\n iterations = 20,\n check = FALSE\n)\n\nres %>%\n mutate(\n expression =\n forcats::fct_reorder(as.character(expression),\n min,\n .desc = TRUE\n )\n ) %>%\n as_bench_mark() %>%\n autoplot(type = \"ridge\") + theme_minimal()\n```", "```r\nx_trace <- torch_randn(2^13)\n\nfft_vec_jit <- jit_trace(fft_vec, x_trace)\nfft_fft_jit <- jit_trace(torch_fft_fft, x_trace)\n```", "```r\nfft_matrix_for_jit <- function(x) {\n x <- x$to(dtype = torch_cfloat())\n\n n_samples <- length(x)\n\n # smallest butterfly matrix, needed for all valid inputs\n B2 <- torch_tensor(\n c(1, 1, 1, -1),\n dtype = torch_cfloat()\n )$view(c(2, 2))\n B2_block <- torch_block_diag(\n B2$`repeat`(c(n_samples / 2, 1))$split(2)\n )\n acc <- torch_matmul(B2_block, x)\n\n # iterative implementation then starts with B4\n n <- 4\n\n while (n <= n_samples) {\n\n # build up current butterfly matrix\n I <- torch_eye(n / 2)\n O <- torch_diag(\n torch_exp(\n -1i * 2 * pi *\n torch_arange(0, n / 2 - 1) / (n / 2 * 2)\n )\n )\n B <- torch_cat(list(\n torch_cat(list(I, O), dim = 2),\n torch_cat(list(I, -O), dim = 2)\n ), dim = 1)\n\n # in the final multiplication,\n # B directly matches input length\n if (n == n_samples) {\n return(torch_matmul(B, acc))\n }\n\n # create block-diagonal matrix from butterflies\n # at each iteration,\n # we need to replicate B {n_samples/rank(B) times}\n # this is achieved by first repeating B row-wise,\n # then splitting up into rank(n) parts)\n B_block <- torch_block_diag(\n B$`repeat`(c(n_samples / n, 1))$split(n)\n )\n acc <- torch_matmul(B_block, acc)\n n <- n * 2\n }\n acc\n}\n```", "```r\nfft_matrix_jit <- jit_trace(\n fft_matrix_for_jit,\n torch_tensor(\n bitrevorder(as.numeric(x_trace)),\n dtype = torch_cfloat()\n )\n)\n```", "```r\nx_rev <- torch_tensor(\n bitrevorder(\n as.numeric(x_trace)\n ),\n dtype = torch_cfloat()\n)\n\nres <- mark(fft_vec(x),\n fft_matrix(x),\n torch_fft_fft(x),\n fft_vec_jit(x),\n fft_matrix_jit(x_rev),\n fft_fft_jit(x),\n iterations = 20,\n check = FALSE\n)\n\nres %>%\n mutate(\n expression = forcats::fct_reorder(\n as.character(expression),\n min,\n .desc = TRUE\n )\n ) %>%\n as_bench_mark() %>%\n autoplot(type = \"ridge\") + theme_minimal()\n```"]
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>2.3 Deep Dive into Text Splitting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>2.3 Deep Dive into Text Splitting</h1>
<blockquote>原文：<a href="https://boramorka.github.io/LLM-Book/en/CHAPTER-2/2.3%20Deep%20Dive%20into%20Text%20Splitting/">https://boramorka.github.io/LLM-Book/en/CHAPTER-2/2.3%20Deep%20Dive%20into%20Text%20Splitting/</a></blockquote>
                
                  


  
  



<p>Splitting (segmentation) happens after loading data into a “document” format but before indexing or storage. The goal is to produce semantically meaningful chunks that work well for search and analytics without breaking meaning at the boundaries. Two parameters matter most: chunk size and overlap. Size is measured in characters or tokens (larger chunks carry more context; smaller ones are easier to process). Overlap is the “handoff” between neighboring chunks that helps maintain coherence. LangChain provides several strategies: character- and token-based splitting, a recursive approach that follows a hierarchy of separators (paragraphs → sentences → words), plus specialized splitters for code and Markdown that respect syntax and headings. There are also two modes of operation — Create Documents (accepts a list of raw text and returns chunked documents) and Split Documents (splits previously loaded documents) — so choose based on whether you are working with strings or with document objects. In practice, CharacterTextSplitter (simple character-based splitting when semantics are less critical) and TokenTextSplitter (token-based splitting to fit LLM limits) are the most common. When structure matters, a recursive splitter that follows the hierarchy is very helpful. Among the specialized options are LanguageTextSplitter for code and MarkdownHeaderTextSplitter for splitting by headings while preserving this structure in metadata.</p>
<p>Before applying splitters, it’s useful to quickly set up the environment: imports, API keys, and dependencies.</p>
<div class="highlight"><pre><span/><code><span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">openai</span><span class="w"> </span><span class="kn">import</span> <span class="n">OpenAI</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dotenv</span><span class="w"> </span><span class="kn">import</span> <span class="n">load_dotenv</span><span class="p">,</span> <span class="n">find_dotenv</span>

<span class="c1"># Add the path to access project modules</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'../..'</span><span class="p">)</span>

<span class="c1"># Load environment variables from the .env file</span>
<span class="n">load_dotenv</span><span class="p">(</span><span class="n">find_dotenv</span><span class="p">())</span>

<span class="c1"># Initialize the OpenAI client using environment variables</span>
<span class="n">client</span> <span class="o">=</span> <span class="n">OpenAI</span><span class="p">()</span>
</code></pre></div>
<p>Splitting strategy strongly affects search and analytics quality, so tune parameters to preserve relevance and coherence. The basic choices are CharacterTextSplitter and RecursiveCharacterTextSplitter; select based on your data’s structure and nature. Below are compact examples: first, a simple splitter with optional overlap to help maintain context,</p>
<div class="highlight"><pre><span/><code><span class="kn">from</span><span class="w"> </span><span class="nn">langchain.text_splitter</span><span class="w"> </span><span class="kn">import</span> <span class="n">CharacterTextSplitter</span>

<span class="c1"># Define chunk size and overlap for splitting</span>
<span class="n">chunk_size</span> <span class="o">=</span> <span class="mi">26</span>
<span class="n">chunk_overlap</span> <span class="o">=</span> <span class="mi">4</span>

<span class="c1"># Initialize a CharacterTextSplitter</span>
<span class="n">character_text_splitter</span> <span class="o">=</span> <span class="n">CharacterTextSplitter</span><span class="p">(</span>
    <span class="n">chunk_size</span><span class="o">=</span><span class="n">chunk_size</span><span class="p">,</span>
    <span class="n">chunk_overlap</span><span class="o">=</span><span class="n">chunk_overlap</span>
<span class="p">)</span>
</code></pre></div>
<p>and then a recursive splitter which, for “general” texts, more carefully preserves semantics by following a hierarchy of separators—from paragraphs to sentences to words.</p>
<div class="highlight"><pre><span/><code><span class="kn">from</span><span class="w"> </span><span class="nn">langchain.text_splitter</span><span class="w"> </span><span class="kn">import</span> <span class="n">RecursiveCharacterTextSplitter</span>

<span class="c1"># Initialize a RecursiveCharacterTextSplitter</span>
<span class="n">recursive_character_text_splitter</span> <span class="o">=</span> <span class="n">RecursiveCharacterTextSplitter</span><span class="p">(</span>
    <span class="n">chunk_size</span><span class="o">=</span><span class="n">chunk_size</span><span class="p">,</span>
    <span class="n">chunk_overlap</span><span class="o">=</span><span class="n">chunk_overlap</span>
<span class="p">)</span>
</code></pre></div>
<p>Next come a few practical examples. Start with simple strings,</p>
<div class="highlight"><pre><span/><code><span class="c1"># A simple alphabet string example</span>
<span class="n">alphabet_text</span> <span class="o">=</span> <span class="s1">'abcdefghijklmnopqrstuvwxyz'</span>

<span class="c1"># Try splitting the alphabet string with both splitters</span>
<span class="n">recursive_character_text_splitter</span><span class="o">.</span><span class="n">split_text</span><span class="p">(</span><span class="n">alphabet_text</span><span class="p">)</span>
<span class="n">character_text_splitter</span><span class="o">.</span><span class="n">split_text</span><span class="p">(</span><span class="n">alphabet_text</span><span class="p">,</span> <span class="n">separator</span><span class="o">=</span><span class="s1">' '</span><span class="p">)</span>
</code></pre></div>
<p>and then look under the hood with a minimal splitter implementation and its behavior on basic inputs.</p>
<div class="highlight"><pre><span/><code><span class="c1"># A class that splits text into chunks based on character count.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CharacterTextSplitter</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">,</span> <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Initialize the splitter with the given chunk size and overlap.</span>

<span class="sd">        Args:</span>
<span class="sd">        - chunk_size: Number of characters each chunk should contain.</span>
<span class="sd">        - chunk_overlap: Number of characters to overlap between neighboring chunks.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span> <span class="o">=</span> <span class="n">chunk_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span> <span class="o">=</span> <span class="n">chunk_overlap</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">split_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Split the given text into chunks according to the configured size and overlap.</span>

<span class="sd">        Args:</span>
<span class="sd">        - text: The string to split.</span>

<span class="sd">        Returns:</span>
<span class="sd">        A list of text chunks.</span>
<span class="sd">        """</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">start_index</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Continue splitting until the end of the text is reached.</span>
        <span class="k">while</span> <span class="n">start_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
            <span class="n">end_index</span> <span class="o">=</span> <span class="n">start_index</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span>
            <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">start_index</span><span class="p">:</span><span class="n">end_index</span><span class="p">])</span>
            <span class="c1"># Advance start index for the next chunk accounting for overlap.</span>
            <span class="n">start_index</span> <span class="o">=</span> <span class="n">end_index</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span>
        <span class="k">return</span> <span class="n">chunks</span>

<span class="c1"># Extend CharacterTextSplitter with recursive splitting capabilities.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">RecursiveCharacterTextSplitter</span><span class="p">(</span><span class="n">CharacterTextSplitter</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">split_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">current_depth</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""</span>
<span class="sd">        Recursively split text into smaller chunks until each chunk is below the</span>
<span class="sd">        size threshold or the maximum recursion depth is reached.</span>

<span class="sd">        Args:</span>
<span class="sd">        - text: The string to split.</span>
<span class="sd">        - max_depth: Maximum recursion depth to prevent infinite recursion.</span>
<span class="sd">        - current_depth: Current recursion depth.</span>

<span class="sd">        Returns:</span>
<span class="sd">        A list of text chunks.</span>
<span class="sd">        """</span>
        <span class="c1"># Base case: if max depth reached or text already below threshold, return as-is.</span>
        <span class="k">if</span> <span class="n">current_depth</span> <span class="o">==</span> <span class="n">max_depth</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">text</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Split into two halves and recurse on each.</span>
            <span class="n">mid_point</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">first_half</span> <span class="o">=</span> <span class="n">text</span><span class="p">[:</span><span class="n">mid_point</span><span class="p">]</span>
            <span class="n">second_half</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="n">mid_point</span><span class="p">:]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_text</span><span class="p">(</span><span class="n">first_half</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">,</span> <span class="n">current_depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> \
                   <span class="bp">self</span><span class="o">.</span><span class="n">split_text</span><span class="p">(</span><span class="n">second_half</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">,</span> <span class="n">current_depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Example usage of the above classes:</span>

<span class="c1"># Define chunk size and overlap for splitting.</span>
<span class="n">chunk_size</span> <span class="o">=</span> <span class="mi">26</span>
<span class="n">chunk_overlap</span> <span class="o">=</span> <span class="mi">4</span>

<span class="c1"># Initialize the CharacterTextSplitter with the specified size and overlap.</span>
<span class="n">character_text_splitter</span> <span class="o">=</span> <span class="n">CharacterTextSplitter</span><span class="p">(</span><span class="n">chunk_size</span><span class="o">=</span><span class="n">chunk_size</span><span class="p">,</span> <span class="n">chunk_overlap</span><span class="o">=</span><span class="n">chunk_overlap</span><span class="p">)</span>

<span class="c1"># Initialize the RecursiveCharacterTextSplitter with the specified size.</span>
<span class="n">recursive_character_text_splitter</span> <span class="o">=</span> <span class="n">RecursiveCharacterTextSplitter</span><span class="p">(</span><span class="n">chunk_size</span><span class="o">=</span><span class="n">chunk_size</span><span class="p">)</span>

<span class="c1"># Example text to split.</span>
<span class="n">alphabet_text</span> <span class="o">=</span> <span class="s1">'abcdefghijklmnopqrstuvwxyz'</span>

<span class="c1"># Use both splitters and store results.</span>
<span class="n">recursive_chunks</span> <span class="o">=</span> <span class="n">recursive_character_text_splitter</span><span class="o">.</span><span class="n">split_text</span><span class="p">(</span><span class="n">alphabet_text</span><span class="p">)</span>
<span class="n">simple_chunks</span> <span class="o">=</span> <span class="n">character_text_splitter</span><span class="o">.</span><span class="n">split_text</span><span class="p">(</span><span class="n">alphabet_text</span><span class="p">)</span>

<span class="c1"># Print results from the recursive splitter.</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Recursive splitter chunks:"</span><span class="p">)</span>
<span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">recursive_chunks</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>

<span class="c1"># Print results from the simple splitter.</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">Simple splitter chunks:"</span><span class="p">)</span>
<span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">simple_chunks</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
</code></pre></div>
<p>The example above illustrates how splitting behaves on basic strings—with and without explicit separators. Now consider two advanced techniques. First, handling more complex text where it’s helpful to explicitly set a hierarchy of separators and a chunk size:</p>
<div class="highlight"><pre><span/><code><span class="c1"># A sample complex text</span>
<span class="n">complex_text</span> <span class="o">=</span> <span class="s2">"""When writing documents, writers will use document structure to group content...</span>
<span class="s2">Sentences have a period at the end, but also, have a space."""</span>

<span class="c1"># Apply recursive splitting with configured chunk size and separators</span>
<span class="n">recursive_character_text_splitter</span> <span class="o">=</span> <span class="n">RecursiveCharacterTextSplitter</span><span class="p">(</span>
    <span class="n">chunk_size</span><span class="o">=</span><span class="mi">450</span><span class="p">,</span>
    <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> 
    <span class="n">separators</span><span class="o">=</span><span class="p">[</span><span class="s2">"</span><span class="se">\n\n</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">,</span> <span class="s2">" "</span><span class="p">,</span> <span class="s2">""</span><span class="p">]</span>
<span class="p">)</span>
<span class="n">recursive_character_text_splitter</span><span class="o">.</span><span class="n">split_text</span><span class="p">(</span><span class="n">complex_text</span><span class="p">)</span>
</code></pre></div>
<p>This produces coherent chunks that respect the document’s internal structure. Second, token-based splitting, where the LLM context window is defined in tokens and limits must be strictly observed:</p>
<div class="highlight"><pre><span/><code><span class="kn">from</span><span class="w"> </span><span class="nn">langchain.text_splitter</span><span class="w"> </span><span class="kn">import</span> <span class="n">TokenTextSplitter</span>

<span class="c1"># Initialize a TokenTextSplitter</span>
<span class="n">token_text_splitter</span> <span class="o">=</span> <span class="n">TokenTextSplitter</span><span class="p">(</span><span class="n">chunk_size</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Split document pages by tokens</span>
<span class="n">document_chunks_by_tokens</span> <span class="o">=</span> <span class="n">token_text_splitter</span><span class="o">.</span><span class="n">split_documents</span><span class="p">(</span><span class="n">pages</span><span class="p">)</span>
</code></pre></div>
<p>And finally, splitting by Markdown headings, where the document’s logical organization guides segmentation and the detected headings are preserved in chunk metadata.</p>
<div class="highlight"><pre><span/><code><span class="kn">from</span><span class="w"> </span><span class="nn">langchain.text_splitter</span><span class="w"> </span><span class="kn">import</span> <span class="n">MarkdownHeaderTextSplitter</span>

<span class="c1"># Define the headings to split on in a Markdown document</span>
<span class="n">markdown_headers</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s2">"#"</span><span class="p">,</span> <span class="s2">"Header 1"</span><span class="p">),</span>
    <span class="p">(</span><span class="s2">"##"</span><span class="p">,</span> <span class="s2">"Header 2"</span><span class="p">),</span>
<span class="p">]</span>

<span class="c1"># Initialize a MarkdownHeaderTextSplitter</span>
<span class="n">markdown_header_text_splitter</span> <span class="o">=</span> <span class="n">MarkdownHeaderTextSplitter</span><span class="p">(</span>
    <span class="n">headers_to_split_on</span><span class="o">=</span><span class="n">markdown_headers</span>
<span class="p">)</span>

<span class="c1"># Split a real Markdown document while preserving heading metadata</span>
<span class="n">markdown_document_splits</span> <span class="o">=</span> <span class="n">markdown_header_text_splitter</span><span class="o">.</span><span class="n">split_text</span><span class="p">(</span><span class="n">markdown_document_content</span><span class="p">)</span>
</code></pre></div>
<p>A few quick recommendations: preserve semantics and account for the source document’s structure; manage overlap—just enough to maintain coherence without unnecessary redundancy; use and enrich metadata to improve context during retrieval and answering.</p>
<h2 id="theory-questions">Theory Questions</h2>
<ol>
<li>What is the goal of document splitting?</li>
<li>How does chunk size affect processing?</li>
<li>Why is overlap needed and how does it help analysis?</li>
<li>How do <code>CharacterTextSplitter</code> and <code>TokenTextSplitter</code> differ, and where are they used?</li>
<li>What is a recursive splitter and how does it differ from basic ones?</li>
<li>Which specialized splitters exist for code and Markdown, and what are their benefits?</li>
<li>What is required to set up the environment before splitting?</li>
<li>List the pros and cons of <code>RecursiveCharacterTextSplitter</code> and the parameters that are important to tune.</li>
<li>What does the “alphabet” example demonstrate when comparing simple and recursive approaches?</li>
<li>What should you pay attention to when choosing between characters and tokens for LLMs?</li>
<li>How does splitting by Markdown headings preserve logical structure and why is that important?</li>
<li>What best practices help preserve semantics and manage overlap?</li>
</ol>
<h2 id="practical-tasks">Practical Tasks</h2>
<ol>
<li>Write a function <code>split_by_char(text, chunk_size)</code> that returns a list of fixed-size chunks.</li>
<li>Add a <code>chunk_overlap</code> parameter to <code>split_by_char</code> and implement overlapping.</li>
<li>Implement a class <code>TokenTextSplitter(chunk_size, chunk_overlap)</code> with a <code>split_text</code> method that splits text by tokens (tokens separated by spaces).</li>
<li>Write a function <code>recursive_split(text, max_chunk_size, separators)</code> that recursively splits text using a given list of separators.</li>
<li>Implement a class <code>MarkdownHeaderTextSplitter(headers_to_split_on)</code> with a <code>split_text</code> method that splits Markdown by the specified headings and returns chunks with the corresponding metadata.</li>
</ol>












                
                  
</body>
</html>
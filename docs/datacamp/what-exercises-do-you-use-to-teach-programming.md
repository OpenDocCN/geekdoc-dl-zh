# 你用什么练习来教编程？

> 原文：<https://web.archive.org/web/20230101103400/https://www.datacamp.com/blog/what-exercises-do-you-use-to-teach-programming>

每个机械师都有她最喜欢的螺丝刀，每个好老师都有不同种类的练习来检查她的学生是否真的在学习，让他们练习新技能，并让他们保持专注。一些类型的锻炼是众所周知的，但是其他的并没有被广泛的使用。DataCamp(我现在的雇主)支持每一种类型，我热衷于寻找新的东西来尝试，以及使用我们已经拥有的东西的新方法。

为了被纳入本文，一个练习必须让学习者快速完成，并且可以自动检查答案。这些要求排除了一些有用的评估，但是我很惊讶还有多少保留下来。

让我们从 DataCamp 用户最熟悉的两种锻炼方式开始。第一个是 ***选择题*** ，提出一个问题，要求学生从列表中选择正确答案。这样做可能(事实上，应该)需要他们做的不仅仅是阅读和记忆，正如前面的帖子所讨论的，当他们的错误答案探究学生的具体误解时，多选题是最有效的。

> 举例:你在`/home/repl`里。使用带有适当参数的`ls`来获取目录`/home/repl/seasonal`中的文件列表。下面哪个文件是目录中的*而不是*？
> 
> *   `autumn.csv`
> *   `fall.csv`
> *   `spring.csv`
> *   `winter.csv`

第二种练习是**编写并运行**，在这个练习中，学生必须编写产生指定输出的代码。当代码被提交时，我们检查它的结构和/或输出并给出反馈。编写和运行练习可以根据教师的要求简单或复杂。例如，对于新手来说，简单地让他们调用一个函数或方法就足够了:有经验的指导者经常忘记弄清楚哪个参数去哪里有多难。

> 示例:矩阵 M 包含从文件中读取的数据。使用一个函数或方法调用，创建一个与 M 形状相同但只包含零的矩阵 Z。

编写并运行练习可以帮助学生练习他们最想学的技能，但是编写好的自动化检查很难:学生可以找到非常有创意的方法来获得正确的答案，给他们一个错误的否定会让他们士气低落。减少这种情况发生频率的一种方法是，在提交代码之前，给他们一个小的测试套件，让他们可以运行他们的代码(在这一点上，可以运行一组更全面的测试)。这样做有助于发现学生完全误解了书面练习规范的情况。

为了帮助学生认识到写好的测试有多难，教师可以让他们自己去做。他们可以被要求编写测试来确定一段代码是否符合某个规范，而不是编写满足某个规范的代码。

> 示例:函数`monotonic_sum`计算数值单调递增的数字列表中每一部分的总和。例如，给定输入`[1, 3, 3, 4, 5, 1]`，输出应该是`[4, 3, 9, 1]`。编写并运行单元测试，以确定该函数包含以下哪些错误:
> 
> *   认为每个负数都是新的子序列的开始。
> *   不包括小计中每个子序列的第一个值。
> *   不包括小计中每个子序列的最后一个值。
> *   只有当数值减少而不是没有增加时，才重新开始求和。

***填空*** 是对 ***编写并运行*** 的细化，其中给学生一些启动代码并要求他们完成。(在实践中，许多**编写和运行**练习实际上是**填空**，因为讲师会提供注释来提醒学生应该采取哪些步骤。)新手通常会发现**填空**比从头开始编写所有代码更容易，而且由于导师已经提供了大部分答案的结构，提交的内容更容易检查。

> 示例:填写空白，以便下面的代码打印字符串“hat”。
> 
> ```py
> text = 'all that it is'
> slice = text[____:____]
> print(slice) 
> ```

帕森斯问题(Parsons Problem)是另一种避免“恐怖黑屏”问题的练习:学生被给予解决问题所需的代码行，但必须按正确的顺序排列。过去几年的研究表明**帕森斯问题**是有效的，因为它们让学生专注于控制流程(“我做事情的顺序是什么？”)与词汇分开(“我需要做什么？”).同样的研究表明，给学生比她需要的更多的线，或者让她重新安排一些线并增加一些线，会使这类问题变得更加困难。我们的移动平台直接支持 **Parsons 问题**，并且可以通过要求学生在编辑器中重新排列代码来模拟它们(尽管有些笨拙)。

> 示例:重新排列和缩进这些行，以计算列表中正值和负值的总和。
> 
> ```py
> positive = 0
> return negative, positive
> if v > 0
> else
> positive += v
> negative = 0
> for v in values
> negative += v 
> ```

***追踪执行*** 是帕森斯问题的逆问题:给定几行代码，学生必须追踪这些行的执行顺序。这是一项基本的调试技能，也是巩固学生对循环、条件以及函数和方法调用的求值顺序的理解的好方法。同样，我们还不直接支持这一点，但可以通过让学生键入线条标签列表来模拟。

> 示例:这个代码块中带标签的行是按什么顺序执行的？
> 
> ```py
> A)     vals = [-1, 0, 1]
> B)     inverse_sum = 0
>        try:
>            for v in vals:
> C)             inverse_sum += 1/v
>        except:
> D)         pass 
> ```

***跟踪值*** 类似于**跟踪执行**，但不是拼出代码执行的顺序，而是要求学生列出程序运行时一个或多个变量取的值。同样，可以通过让学生键入他们的答案来实现，但这很快变得不切实际。实际上，最好的方法是给学生一个表格，表格的列标有变量名，表格的行标有行号。

> 示例:当此文件:
> 
> ```py
> 2017-11-01,Akeratu,9
> 2017-11-01,Monona,3
> 2017-11-02,Monona,1
> 2017-11-03,Monona,1
> 2017-11-03,Akeratu,7 
> ```
> 
> 通过以下 Unix shell 命令运行:
> 
> ```py
> cut -d , -f 2 filename | sort | uniq > result.txt 
> ```

回到调试技能，另一个帮助学生发展这些技能的练习是 ***最小修复*** 。给定几行包含错误的代码，学生必须做出或识别出能产生正确输出的最小变化。做出改变可以通过使用**写和运行**来完成，而识别它可以通过**选择题**来完成。

> 示例:该函数用于测试点`(x, y)`是否严格位于由`(x_min, y_min, x_max, y_max)`定义的矩形内。更改一行以使它正确地这样做。
> 
> ```py
> def inside(point, rect):
>     if (point.x <= rect.x_min): return false
>     if (point.y <= rect.y_min): return false
>     if (point.x >= rect.y_max): return false
>     if (point.y >= rect.y_max): return false
>     return true 
> ```

**主题和变化**练习是相似的，但是学生被要求做一个小的改变，以某种特定的方式改变输出，而不是做出改变来修复错误。这些变更可以包括:

*   用一个函数调用替换另一个函数调用
*   改变一个变量的初始值
*   交换内部和外部循环
*   改变条件链中测试的顺序
*   更改函数调用的嵌套或方法链接的顺序

同样，这也给了学生一个实践有用的现实世界技能的机会:产生一个工作程序的最快方法通常是调整一个已经做了一些有用的事情的程序。

> 示例:更改下面函数中的内部循环控件，以便它将矩阵的左上角三角形设置为零。
> 
> ```py
> def zeroTriangle(matrix):
>     for c in range(matrix.cols):
>         for r in range(matrix.rows):
>             matrix[r, c] = 0 
> ```

匹配问题是另一整套练习。一个 ***一对一的匹配问题*** 给学生两个长度相等的列表，并要求她将相应的项目配对，例如，“将每段代码与其产生的输出进行匹配”。

> 示例:将每个函数的名称与其实现的操作匹配起来。
> 
> | 上海通用汽车公司 | 三角形带状矩阵向量乘法 |
> | STBMV | 求解有多个右边的三角矩阵 |
> | STRSM | 矩阵向量乘法 |

**多对多匹配问题**类似，但是列表的长度不同，所以一些项目可能与其他几个匹配。这两种都需要学生使用高阶思维技能，但多对多更难，因为学生不能先进行简单的匹配，以缩小他们的搜索空间。

我们的平台目前不支持匹配问题；他们可以通过让学生以文本形式提交配对列表(如“A3，B1，C2”)来模拟，但这很笨拙且容易出错。未来的实现可能会重复使用为帕森斯问题设计的机器，让学生拖放文本块以形成匹配。

拖放会打开许多其他的门:例如，**跟踪执行**很容易通过这种方式实现。 ***标签图*** 也是如此:比起学生键入标签，他们拖动标签来贴在正确的元素上更快更可靠。图片可以是复杂的数据结构(“这段代码执行后，哪些变量指向这个结构的哪些部分？”)、程序生成的图(“将这些代码片段中的每一个与它生成的图的一部分匹配”)、代码本身(“将每个术语与该程序元素的一个示例匹配”)或许多其他东西。

> 示例:标记下图，以显示在执行这三行代码后，变量`x`、`y`和`z`引用了哪些结构。
> 
> ```py
> x = 3
> y = [x, x]
> z = [x, y] 
> ```
> 
> ![](img/f12f0a1321f0e14c49a2daea2cd21956.png)

***画图表*** 像数据结构这样的东西在纸上画起来也很简单，但是很难自动评分。使解决方案可分级的一种方法可能是用与**帕森斯问题**约束代码构造相同的方式来约束绘图，即，给学生图表的各个部分，并要求他们正确地排列它们，但这还有很长的路要走。

我们前面提到匹配问题需要学生使用高阶思维技能。 ***总结*** 也是这么做的，给他们一个机会练习一个技能，这个技能在*报告*bug 而不是修复的时候非常有用。例如，可以问学生，“当 x 从 0 到 10 变化时，哪个句子最能描述 f 的输出如何变化？”然后给出几个选项作为**选择题**。同样， ***排名问题*** 给学生几个选择，让他们按最快到最慢、最健壮到最脆弱等顺序排列。(**排名**通过拖放实现时比作为**选择题**更易于管理。)

另一种可以实现为**选择题**的练习是 ***故障映射*** :给定一段错误代码和一条错误消息，学生必须识别错误发生在哪一行。在简单的情况下，这将是错误消息中提到的行，但是在更微妙的情况下，学生将不得不向前和向后跟踪执行，以找出哪里首先出错。

DataCamp 的平台还不能直接支持所有这些类型的练习，还有其他一些在线平台很难提供的。 ***重构练习*** 是**主题和变化**练习的补充:给定一段工作代码，学生必须以某种方式修改它*，而*不改变它的输出。例如，可以要求学生用向量表达式替换循环，简化 while 循环中的条件，等等。这里的挑战是，重构一段代码的方式往往如此之多，以至于分级需要人工干预。

> 例:写一个和这个循环有同样效果的单条列表理解。
> 
> ```py
> result = []
> for v in values:
>     if len(v) > threshold:
>         result.append(v) 
> ```

***代码审查*** 在一般情况下，很难自动评分，但如果给学生一个标题(即要寻找的错误列表)，并要求他们将特定的注释与特定的代码行进行匹配，就可以解决这个问题。例如，可以告诉学生有两个缩进错误和一个错误的变量名，并要求他们指出来；如果她是更高级的，可以给她六种关于代码的评论，而不需要指导她应该找到多少种。与**跟踪值**一样，当以表格的形式呈现时，这是学生最容易做到的，我们目前不支持。

> 示例:使用提供的标题，标记下面的每一行代码。
> 
> ```py
> 01)  def addem(f):
> 02)      x1 = open(f).readlines()
> 03)      x2 = [x for x in x1 if x.strip()]
> 04)      changes = 0
> 05)      for v in x2:
> 06)          print('total', total)
> 07)          tot = tot + int(v)
> 08)      print('total') 
> ```
> 
> 1.  糟糕的变量名
> 2.  未使用的变量
> 3.  未定义变量的使用
> 4.  缺少值
> 5.  化石密码

毫无疑问，还有许多其他类型的练习，做起来也很快，可以自动升级，但是我们没有听说过。如果你知道什么，我们很乐意听听。

感谢所有为本文提供想法的人，包括弗朗西斯·卡斯特罗、凯蒂·坎宁安、布莱恩·迪林厄姆、马克·古兹戴尔、伊恩·霍克、托比·霍奇斯、科琳·刘易斯、杰拉米娅·奥里、亚历克斯·庞德、丹妮尔·奎因、阿里尔·洛克姆、帕特·施洛斯、马尔维卡·莎兰、理查德·汤姆塞特、斯蒂芬·范德沃特、哈德利·威克姆和安德洛米达·耶尔顿。
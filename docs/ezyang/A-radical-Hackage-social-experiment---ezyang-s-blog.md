<!--yml

category: 未分类

date: 2024-07-01 18:18:11

-->

# 一个激进的 Hackage 社会实验：ezyang 的博客

> 来源：[`blog.ezyang.com/2010/08/the-radical-hackage-social-experiment/`](http://blog.ezyang.com/2010/08/the-radical-hackage-social-experiment/)

*序言*。这篇文章试图明确一些关于即将到来的 Hackage 2.0 的想法，这些想法在 Galois 的午餐桌周围已经讨论过。请注意，我从未见证过一门语言进入主流，所以请对我说的话持保留态度。论点是，如果 Hackage 结合了大教堂（Python）、集市（Perl/CPAN）和社会协作的轮子（Wikipedia、StackOverflow、Github），它可以彻底改变在 Haskell 中编程的含义。

新的编程语言层出不穷：只需漫步在[OSCON Emerging Languages track](http://emerginglangs.com/speakers/)，就能看到原因所在。作为程序员，我们的自然好奇心集中在语言本身：“它解决了什么问题？它是什么样子？”作为工程师，我们可能会问：“它的运行时系统是什么？”作为计算机科学家，我们可能会问：“这门语言融入了哪些新颖的研究？”当一门语言解决了我们能够理解的问题或展示了时髦的新技术时，我们的兴趣被激发了，我们会更仔细地看待它。

但随着语言的发展和知名度的提升，随着它从“新兴”阶段进入“新生”阶段，在某些时候，*语言本身变得不再重要*。取而代之的是围绕语言的社区：无论是社会上还是技术上。一个由人和代码组成的社区——库、框架、平台。一个工程师会问：“好的。我需要做 X。有没有填补这个需求的库？”

成功的语言能够毫无疑问地回答：“是的。”这是一个显而易见的陈述，因为受欢迎的语言吸引了编写更多库的开发者，这又吸引了更多开发者：一个正反馈循环。但对于试图打入主流的语言来说，这并不有利。

降低流行水平一点，然后你可以看到由开发者获取所需功能的机制定义的语言。两个即时的例子是 Python 和 Perl。

Python 的口号是：“一切都包括在内”，将一个没有库的语言比作一台没有电池的花哨技术：看起来漂亮，但目前来说相当无用。[Python 文档](http://www.python.org/about/) 自豪地宣称，在原生 Python 安装中，任何基本功能都只需一行导入操作。Python 标准库本身遵循大教堂模型：提交受限于 [python-dev](http://www.python.org/dev/committers) 成员，大约 120 名信任的人员列表。对于标准库的主要增加，包括 [新增模块的添加](http://www.python.org/dev/peps/pep-0002/) 需要经历 [严格的提案过程](http://www.python.org/dev/peps/)，在这个过程中，他们必须证明你的模块被接受、广泛使用并将得到积极维护。如果维护者消失，python-dev 将接管模块的管理，直到找到新的维护者，否则将弃用该模块。这种模型已经导致标准库中有 [三百多个相对高质量的模块](http://docs.python.org/library/)。

另一方面，Perl 采用了与 [CPAN](http://www.cpan.org) 相关的集市模型，以至于核心 Perl 的缓慢发布周期意味着一些核心模块已经双重存在：即它们既存在于核心中又存在于 CPAN 中。任何人都可以上传到 CPAN：结果是超过 20,000 个模块，被许多 Perl 开发人员视为必不可少的资源。除了它朴素的主页界面外，还有 [大规模的测试基础设施](http://deps.cpantesters.org/) 适用于 CPAN 中的所有内容，以及一个 [评级系统](http://cpanratings.perl.org/)（或许效用存疑）。CPAN 已经启发了许多编程语言中类似的集市风格的仓库（有趣的是，一些最流行的语言，如 C 和 Java，大部分都抵制了这一趋势）。

对于任何语言来说，要建立超过一百名可信任的提交者或规模庞大的社区都是一个很高的要求。但如果没有这个机制，该语言就无法生存。一般工程师必须重写太多的功能才能使其成为一种有用的通用语言。

这将我们带回到最初的问题：**Hackage** 站在哪里？

最近的结果来自 [Haskell 2010 调查报告](http://blog.johantibell.com/2010/08/results-from-state-of-haskell-2010.html)，反映了任何尝试使用 **Hackage** 的 Haskell 程序员的感受。有*太多质量不足的库*。

我们如何解决这个问题？毕竟，这是由志愿者制作的开源软件：你不能到处告诉人们要改进他们的库。是否增加核心模块集（即 Haskell 平台）和核心贡献者的数量，需要严格的质量审查（Python 模型）？还是让自然演变发生，并添加测量流行度的机制（Perl 模型）？

要取得成功，我认为 Hackage 需要做到两者兼顾。如果成功了，我相信它可能会成为*标准库增长的*模式。

大教堂模型是快速提高少量包质量的明显解决方案。Don Stewart 以前已经成功地使用了这种方法：[bytestring](http://hackage.haskell.org/package/bytestring)最初是一个业余项目，然后 Haskell 社区意识到高效打包字符串有多重要。一支由经验丰富的 Haskeller 组成的“突击队”被组建起来，代码得到了大幅改进、充实和文档化，并在此过程中产生了多篇论文。现在 bytestring 是一个非常调优的库，是 Haskell 中高效输入输出的基础。Don 建议我们为真正重要的功能块采用类似的突击队。我们可以通过将被认为重要的库放入一个共享的存储库中来促进这一过程，以便不是主要维护者的人们仍然可以帮助进行基本维护和错误修复。

但是这个过程并不可扩展。首先，培养一组可信任的维护者是困难的。当前的基础库只由非常少的人维护：人们不得不思考一下 Simons 在维护`base`时可能会花费多少时间，而他们本可以在 GHC 上工作。人们只能说服大多数人在智慧之前维护`X`个包。即使是单个包的积极维护也可能非常耗时。

[Hackage 2.0](http://cogracenotes.wordpress.com/2010/08/08/hackage-on-sparky/)致力于促进 Bazaar 模型。包的流行度和反向依赖性可以帮助开发人员判断是否值得使用。

但是，如果我们同时考虑开发人员和包维护人员，我们正在解决一个复杂的社会技术问题，我们不知道什么能彻底改变集市。像 StackOverflow 风格的声誉系统会鼓励维护者完善他们的文档吗？像维基百科那样奖励贡献者增加特权的文化是否有助于选择一组可信的管理者？即使在一个编程语言的结构中没有尝试过这些想法，我们也无法判断它们是否有效！

我谨慎乐观地认为我们正处在 Hackage 对 Haskell 社区所代表的重大转变的边缘。但要实现这一目标，我们需要您的帮助。Vive la révolution!

*致谢.* 大多数想法不是我自己的。我只是把它们记录下来了。尤其是 Don Stewart，他对这个问题思考很多。

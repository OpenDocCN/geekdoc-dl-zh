<!--yml

category: 未分类

date: 2024-07-01 18:18:25

-->

# 拘束编程：ezyang 的博客

> 来源：[`blog.ezyang.com/2010/03/straitjacket-programming/`](http://blog.ezyang.com/2010/03/straitjacket-programming/)

制约的重要性是众所周知的，对于那些从事创意事业的人来说尤为如此。告诉某人，“你可以做任何你想做的事情：真的是任何事情”，他们会茫然不知所措，被无限的可能性所束缚。艺术家们欢迎限制。作家们喜欢十四行诗的限制，因为它赋予了形式，并为开始提供了一个起点；角色扮演团体喜欢战役设置的限制，因为它强加规则，并设定了故事讲述的背景；爵士音乐家喜欢即兴演奏中和弦的限制，因为它将独奏者锚定到源曲，并为旋律提供了创意。

然而，许多程序员不喜欢类型系统的限制。“静态类型系统不允许我做我想做的事情。”“我需要写四个类来完成 Python 中两行代码的工作！”“什么？我不能这样做？为什么？”对于他们来说，这就像一种紧箍咒。当限制把你束缚住时，任何人怎么可能完成*任何*事情呢？

我持不同意见。*接受*这种限制。它允许你做的事情... 是*令人惊讶*的。

* * *

绞索曾被历史上用作防止危险个体伤害自己和他人的工具。程序员们并非精神病院的病人，尽管乍一看似乎我们一直在尝试减少我们伤害自己的方式。但这些变化通常带来了好处，许多人都迫不及待地放弃了指针和手动内存管理，以换取更高的表现力。

然而，静态类型对许多人来说仍然是一个痛点，Haskell 由于其类型系统而异常受限。Haskell 类型系统的狂热用户可能会惊叹道，“在我让它类型检查通过后，它就奇迹般地运行了！”当然，这种说法实际上并不成立；有一定复杂性的算法类别意味着类型系统不会发现您使用了错误的魔法数字来初始化哈希函数。

但并非所有代码都是如此。很多代码只是*乏味*的。它是生成你的网站的代码，或记录你的错误的代码；它是作为构建基础设施粘合剂的代码，或将文件中的数据转换为内存表示再存入数据库的代码。它是基础性的代码；它是让你简洁表达简单想法的代码。当你审视这些代码的开发时，所犯的错误非常简单，纯粹是精神上的小错别字，一旦显现出来，追踪和修复只需要十五秒钟，但如果累计到运行测试套件的时间或者，我敢说，*手动*测试的时间，很快就能变成分钟。一个快速的静态类型检查器可以极大减轻你的痛苦，无论是 Haskell 编译器还是`pylint -e`。不同之处在于`pylint -e`是可选的；没有任何保证每个 Python 项目都能与其良好合作，而且它经常出错。Haskell 编译器则不会出错。

这是更普遍现象的具体体现：类型减少事物出错的方式。这同样适用于复杂的代码；`(a -> r) -> r`也许不能阐明延续的含义，但它确实对如何实现它们施加了很多限制。这使得我们能够在没有理解其含义的情况下查看类型，并机械地推导出你正在寻找的解决方案的一半。

这正是类型如何增强表现力的方式：对于人们来说，理解密集和高度抽象的代码是非常困难的。类型防止我们深陷细节并使处理更强大的抽象形式变得可行。你不会在 Python 中依赖此功能（不要在 Python 中写 Haskell 代码！），在我用此语言编写高阶函数的少数情况下，我总是确保同时提供 Haskell 风格的类型签名。正如 Simon Peyton Jones 所说，类型提供了一个“清晰”而简洁的函数定义。

更令人印象深刻的是 Haskell 对空指针问题的解决方案。那些让 Java 程序员心生恐惧的异常之一就是`NullPointerException`：它是一个[运行时异常](http://java.sun.com/j2se/1.4.2/docs/api/java/lang/RuntimeException.html)，这意味着在方法的`throws`声明中不需要显式地声明它；这基本上意味着任何解引用都可能触发此异常。即使在 Java 这样的静态类型语言中，类型系统也无法编码“我是否保证在这里获取一个值？”这样基本的事实。

Haskell 对这个问题的答案是`Maybe`类型，明确指出函数类型中的值可能是`Nothing`（空）或`Just a`（值）。程序员必须意识到可能什么都没有，并明确处理失败情况（使用`maybe`）或忽略它（使用`fromJust`，或者更适当地命名为`unsafeFromJust`）。数据类型本身并没有什么特别之处；我可以写一个具有相同形式的 Java 泛型。关键在于伴随 Functor、Applicative、Monad、MonadPlus、Monoid 等实例的高阶函数。如果我想在 Java 中编写这段代码，我会立即碰壁：

```
pureOperation <$> maybeVal

```

`<$>`，也被称为`fmap`的高阶函数，对于这段代码至关重要。在等效的 Java 代码中，你必须从泛型中解包值，对其进行操作，然后再次打包（如果为空则使用条件语句）。我可以添加一个方法来实现这个功能到 Maybe 接口，但是然后我将无法优雅地将`pureOperation`传递给这些方法而不使用匿名类… 然后你很快就会发现这种方法的长篇大论（在 Java 中）。显而易见为什么设计者们没有选择这种方法：一个本来就冗长的语言会变得更加冗长。其他语言虽然不至于如此糟糕，但它们无法接近庆祝高阶运算符的语言所能提供的简洁性。

总结一下，虽然这对于一个因难以理解而声名狼藉的语言来说可能看起来有些奇怪，但 Haskell 类型系统的约束增加了作者和读者对抽象的容忍度，最终提升了表达能力。那些人们觉得无可奈何的问题，突然变得可以解决了，“如果你想修复这个问题，你将不得不添加大量样板代码”，这样的问题变得可以处理了。这是强大的。

对于喜欢逃避限制的人士，最后需要注意的一点是：如果你需要动态类型（我不会声称没有时机需要它），你可以完全[绕过静态类型系统！](http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Data-Dynamic.html) 只是要小心，并非默认选择。

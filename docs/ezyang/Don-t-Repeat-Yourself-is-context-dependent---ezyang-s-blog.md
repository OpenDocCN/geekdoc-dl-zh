<!--yml

类别：未分类

日期：2024-07-01 18:18:05

-->

# “不要重复自己”是依赖上下文的：ezyang's 博客

> 来源：[`blog.ezyang.com/2010/10/dry-is-context-dependen/`](http://blog.ezyang.com/2010/10/dry-is-context-dependen/)

我是一个名为[刺客协会](http://web.mit.edu/assassin/www/)的组织成员。不，我们不杀人，也不玩刺客游戏。相反，我们编写和运行竞技实时角色扮演游戏：你会得到一些描述宇宙的游戏规则，一个包含目标、能力和限制的角色表，然后我们会放你在四小时到十天的时间内自由发挥。在这种情况下，我想描述一个应用“不要重复自己”规则可能有害的情况。

当游戏作者构建游戏规则时，“不要重复自己”的原则以非常有趣的方式出现。游戏规则相当复杂：我们希望玩家能够执行诸如进行近战攻击、背后刺杀、施展魔法、打破门等操作，而又不能实际上伤害任何人或破坏任何财产，因此，就像 MIT 的学生那样，我们有“机制”来执行这些游戏内的行动（例如，在一组规则中，近战攻击可以用“Wound 5”声明，其中 5 是你的战斗评级，如果另一个个体的 CR 大于或等于 5，他们可以声明“抵抗”；否则，他们必须扮演昏倒并流血。这非常有趣。）由于构建合理的基础宇宙需要这么多规则，大多数游戏作者都会采用一个普通的、九页的规则表。

当然，规则并不总是一样。一个 GM（即编写和运行游戏的人）可能会决定单独使用攻击和防御等级，而不只是一个 CR 评级。另一组 GM 可能会引入机器人角色，这些角色不能因流血而死亡。等等。

因此，当我们向玩家提供规则时，我们有两种可能性：我们可以重复自己，简单地给他们完整的、修改后的规则集。或者我们可以避免重复自己，给出标准规则和一份勘误表——我们宇宙中所做的具体更改。我们倾向于重复自己，因为这在我们的游戏制作工具中更容易。但一个明显的问题是，哪种方法更好？

答案当然是，*这取决于情况*。

+   熟悉标准规则的老玩家在玩游戏时不需要每次都给他们整套规则；相反，如果他们只是给一个勘误表，他们会更容易更高效地说：“哦，嗯，有所不同，好的”，然后为这个改变过的游戏宇宙制定策略。这对于十天游戏尤为重要，因为改变宇宙规则可以极大地影响情节和策略。

+   对于从未玩过游戏的新玩家来说，拿到一套规则，然后被告知，“哦，但忽略这个和那个，这里还有一个额外的条件”，会非常令人困惑！在他们玩游戏的最初几次中重复完整的规则是有帮助的。

我认为这个原则同样适用于软件开发中的*不要重复自己*。为任何特定的代码或数据采用简洁、独特的表示是好的和有用的，但不要忘记一点冗余会极大地帮助那些初次学习你系统的人！而且，为了两全其美，你甚至不应该重复自己：应该让计算机替你完成。

*附言.* 好奇的朋友们，这里有我们在与 Alex Gurany 和 Jonathan Chapman 合作编写的游戏《杰斐逊·道格拉斯的谋杀案》（工作名称《危险的游戏》）的[游戏规则 PDF](http://web.mit.edu/~ezyang/Public/dangerous-scenario.pdf)。

*附言 II.* 什么时候重复自己被认为是好设计呢？

+   Perl 希望程序员尽可能少地说话来完成工作，这给它赢得了“只写语言”的声誉。

+   并非所有看起来相同的代码都应该重构为一个函数；所抽象出来的东西应该有一定的逻辑统一性。

+   Java 涉及大量的代码编写：IDE 生成`hashCode`和`equals`的代码，你可能事后会微调它们。喜欢 Java 的人大胆地声称这阻止了 Java 程序员造成过多的破坏（尽管也有人持不同意见）。

+   当你写论文时，即使你在五十页前已经定义了一个术语，给读者刷新记忆是很好的。这对数学教科书尤其如此。

+   Haskell 挑战你尽可能抽象出数学上合理的结构。因此，这会让人们的头痛，导致各种组合的动物园。但对于即使是中等程度的高级用户来说，它也非常有益。

鼓励读者提出更多例子。

<!--yml

category: 未分类

date: 2024-07-01 18:16:50

-->

# Rage bug reporting：ezyang 的博客

> 来源：[`blog.ezyang.com/2021/04/rage-bug-reporting/`](http://blog.ezyang.com/2021/04/rage-bug-reporting/)

## Rage bug reporting

在 Facebook，我们有一个名为 "rage" 的内部工具约定。当出现问题并且你想要报告 bug 时，工具开发人员通常会要求你提供一个 rage。对于命令行工具，可以通过运行 rage 子命令来完成，该子命令将询问你想要报告的先前 CLI 调用，并为你提供一组日志以发送给开发人员。

**rage** 有一个重要的特性，与传统的日志级别标志如 `-v` 相比：**rage 记录总是开启的**。换句话说，这就像是应用于客户端软件的传统服务器应用程序日志一样。日志记录总是开启的，而 rage 子命令使用户能够轻松地只发送与命令行调用相关的日志部分（例如，正在运行的日志）。

出于某种原因，在开源工具中，rage 功能并不那么常见。我可以想象很多原因为什么会是这种情况：

+   添加适当的日志记录就像使用牙线一样——在当时可能很烦人，但即使后来可以节省很多痛苦。

+   即使有了日志记录，你仍然需要添加基础设施将日志保存在某个地方，并允许用户随后检索它们。

+   编写足够有用的日志，以便开发人员可以简单地通过“阅读茶叶”来诊断问题，这本身就是一门艺术，但不要详细到会减慢程序正常执行的速度。并且不要忘记，最好不要暴露私人信息！

+   大多数程序都很简单，你可以依赖于老旧的方法，在错误报告中要求用户提交复制操作的说明。

尽管如此，就像大多数系统管理员视日志记录为调试服务器问题的宝贵工具一样，我认为 rage 报告对调试客户端问题同样是一种宝贵的工具。在 ghstack 中，实现 rage 报告并没有多少行代码：[ghstack.logs](https://github.com/ezyang/ghstack/blob/master/ghstack/logs.py)（用于将日志写入 rage 目录）和 [ghstack.rage](https://github.com/ezyang/ghstack/blob/master/ghstack/rage.py)（用于读取日志）。但这大大减少了我在项目支持上的负担；有了一个 rage，我通常可以在设置复制器之前找出 bug 的根本原因。

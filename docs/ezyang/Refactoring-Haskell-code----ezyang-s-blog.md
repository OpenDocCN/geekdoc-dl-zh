<!--yml

类别：未分类

日期：2024-07-01 18:18:20

-->

# 重构 Haskell 代码？：ezyang's 博客

> 来源：[`blog.ezyang.com/2010/05/refactoring-haskell-code/`](http://blog.ezyang.com/2010/05/refactoring-haskell-code/)

## 重构 Haskell 代码？

我必须承认，重构 Haskell 代码（或者甚至只是函数式代码）对我来说有点神秘。对我来说，典型的重构会话可能会是这样的：*坐在代码前，重新阅读代码。对代码运行 hlint，修复它给你的问题。再多看一些代码。进行一些局部转换，使管道更紧凑或者给局部子表达式起个名字。认为代码看起来相当漂亮和功能齐备，然后去做其他事情。*

部分问题在于我尚未培养出对函数式程序常见代码异味的敏感。我在 Haskell 程序中可能会探测到的代码异味，如过长的函数和方法、重复的代码以及过度耦合的代码，在我的程序中明显较少。我编写的大多数函数只有几行（尽管密度很高），轻量级的一阶辅助函数使得临时代码共享变得非常容易，而默认的纯度则鼓励状态的松耦合。这并不是说我的代码没有问题：在 do 块中编写的代码很快就会膨胀到几十行（如果你在 gtk2hs 上编程，这似乎是不可避免的），更高级别的样板代码需要更高级的技巧来消除，而且将所有东西简单地塞进 IO 单子中非常方便且诱人。但这些问题的程度似乎低到可以被忽略不计。

我可以编写代码，但当我回来时，这些代码真的让我很困扰，要么是为了再次理解它，要么是为了扩展它以执行其他任务。在临时基础上，我发现了一些可以使长期维护变得更加麻烦的问题：

+   *类型不够通用.* 在调试类型错误时，明确写出你的类型签名是一个好习惯，但通常情况下，如果你让函数被推断，你可能会发现你的函数比明显的签名更通用。像 `State ()` 这样的类型的代码通常可以泛化为 `MonadState m => m ()`，在许多情况下（如错误处理），你几乎肯定会希望这样泛化。

+   *庞大的函数.* 如果你按照功能从上到下编写代码片段，很容易在几个地方写上类似 `FilePath -> String -> IO [FilePath]` 类型的函数，却忘记内部代码可能对程序的某些未来用途有用。有时这很容易解决，因为你原本应该有三行代码，却写了三个单行代码，或者在不需要的单子中写了太多代码，但即使如此，你仍然必须为所有子函数选择名称，并且在某些情况下，划分甚至不够清晰。

+   *数据结构不够通用*或*递归重复*。当你在简化一个复杂的递归结构时，很容易精确地选择包含你想要的数据的数据结构。但如果你后来决定要一些不能强行塞进你结构中的其他信息，你就有两个选择：修改所有已经为递归编写的现有代码，以使其包含你寻找的额外信息，或者编写一整套新的函数来递归遍历数据结构。对于复杂的函数而言，这可能是一大堆需要处理的模式匹配。（是的，我知道你可以 Scrap Your Boilerplate，但在某些情况下，它感觉稍微有些沉重，不适合在代码中使用。）

+   *孤儿实例*。有时候库的作者并没有在他们的代码中放入你想要的实例，于是你面临选择：采取简单而不道德的方式定义一个孤儿实例，还是像一个好公民一样使用新类型，并且承受额外的包装和解包的复杂性。然后库更新来了，你的代码就崩了。

+   *即席解析*。虽然非常方便，*读*和*显示*实际上并不是为生产而设计的。我花了很多时间来制作读取实例，但其实早该转而使用解析库了。

但我真的很好奇，你在寻找代码中将来可能会让你感到头疼的问题时，会寻找什么，并采取什么措施来降低风险。

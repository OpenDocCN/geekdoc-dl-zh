<!--yml

类别：未分类

日期：2024-07-01 18:17:40

-->

# 让我们玩一个游戏：ezyang 的博客

> 来源：[`blog.ezyang.com/2011/09/lets-play-a-game/`](http://blog.ezyang.com/2011/09/lets-play-a-game/)

曾经想过哈斯克尔人是如何神奇地通过查看函数类型签名就能够推断出函数实现的吗？现在，你也可以学会这种能力。让我们来玩一个游戏。

你是一个发明家，以能够制造将一种东西转化为另一种东西的机器而闻名于世。你是一个**提议者**。

但是有很多人会怀疑你发明这些东西的能力。他们就是**验证者**。

我们玩的游戏如下。你作为提议者，声明某种你知道如何实现的神奇机器，比如 `(a -> b) -> a -> b`（这表示给定一个将 A 转换为 B 的机器和一个 A，它可以创建一个 B）。验证者对你是否能够创造出这样的机器表示怀疑，但作为一个公正的怀疑论者，提供给你你机器的输入（**假设**），希望你能够达到**目标**。

作为提议者，你可以将验证者提供给你的输入和机器**应用**在一起。

但这并不是很有趣。有时，在验证者给你一些机器后，你想提出另一个提案。通常，这是因为其中一个机器接受一个你没有的机器，但你也知道如何制造。

验证者有责任为这个新提案提供更多假设，但这些假设被放置在**抽象**的云层中。

你可以使用验证者之前提供的假设（在抽象的云层下面），

但一旦你完成了提案，所有新的假设都会**消失**。你剩下的只是一台闪亮的新机器（你明显希望传递给另一台机器），可以用于原始目标。

这些就是我们现在所需的所有规则。（它们构成了你在建设性逻辑中所能做的最有用的子集。）

让我们来玩一个游戏。

我们的验证者为我们提供了玩这个游戏所需的机器。我们的目标是 `r`。

这可是一大堆机器，看起来我们无法运行任何一台。我们无法从头开始制造一个 `a` 来运行底下的那个，所以也许我们可以做一个 `a -> r`。（看起来像是我凭空提出了这个建议，但如果你仔细看，这是在这种情况下唯一可能有效的选择。）让我们为 `a -> r` 提出一个新建议。

我们这个子提案的新目标也是 `r`，但与我们原来的情况不同，我们可以利用额外的成分 `a` 来创造 `r`：只需取两台原始的机器和新提供的 `a`。哇，一个 `r` 出来啦！

这样就解除了抽象的云层，留下了一个闪亮的新 `a -> r`，可以传递给剩下的机器，并且实现原始的目标。

让我们给这些机器起些名字。我会为你挑一些富有启发性的名字。

哦，嘿，你刚刚为**延续单子**实现了**绑定**。

这是逐步的转换步骤：

```
m a -> (a -> m b) -> m b
Cont r a -> (a -> Cont r b) -> Cont r b
((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
((a -> r) -> r) -> (a -> (b -> r) -> r) -> (b -> r) -> r

```

最后一步可能是最微妙的，但是可以完成，因为箭头右关联。

作为练习，执行`return :: a -> (a -> r) -> r`（等等，这看起来有点熟悉……），`fmap :: (a -> b) -> ((a -> r) -> r) -> (b -> r) -> r`和`callCC :: ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r`（重要提示：第一个参数里是`b`，不是`a`！）。

这个展示是直觉逻辑的**游戏语义**描述，尽管我省略了**否定**和**量词**的处理，这些比延续单子更为高级，在这种情况下至少是这样。

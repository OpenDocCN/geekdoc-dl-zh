<!--yml

分类: 未分类

日期: 2024-07-01 18:18:08

-->

# 数据即代码：ezyang 的博客

> 来源：[`blog.ezyang.com/2010/09/data-is-code/`](http://blog.ezyang.com/2010/09/data-is-code/)

昨天，我有幸参加了[Chung-Chieh Shan](http://www.cs.rutgers.edu/~ccshan/)的学术报告，主题是[嵌入式概率语言](http://www.cs.rutgers.edu/news/colloquia/?action=view&colloquium_id=4263&organization_id=1)。关于报告的完整内容可以在[本文](http://okmij.org/ftp/kakuritu/dsl-paper.pdf)中找到，所以我想专注于一个特定的大观点：即*数据即代码*的理念。

* * *

Lisp 程序员熟悉的口头禅是，“代码即数据”，这个概念认为每个源代码清单背后都有一个由 cons 单元和标签组成的数据结构，表示可以构建、修改和评估的代码。在这个框架下，一小部分数据是代码：`'(cons 1 (cons 2 ()))`是代码，但`'((.5 ((.5 #t) (.5 #f))) (.5 ((.5 #t))))`则不是。

在什么情况下后者可以成为代码呢？考虑以下问题（一种希望明确表达的[男孩或女孩悖论](http://en.wikipedia.org/wiki/Boy_or_Girl_paradox)）：

> 你闭上眼睛。我会递给你一个红球或一个蓝球。然后，我会再递给你一个红球或一个蓝球。然后你偷偷看了一眼，发现至少有一个球是红色的。第一个球是红色的概率是多少？

了解概率的你们可能会编写概率表格，并得出答案是`2/3`，但对于那些不太确信的人来说，可能会去编写一些代码来模拟这种情况：

```
a <- dist [(.5, red), (.5, blue)]
b <- dist [(.5, red), (.5, blue)]
if a != red && b != red
  then fail
  else a == red

```

其中`dist`是从分布中随机选择变量的某个函数，而`fail`则报告矛盾并忽略生成的宇宙。这段代码是数据，但它比抽象语法树更深刻地是数据。特别是，它编码了推理树 `'((.5 ((.5 #t) (.5 #f))) (.5 ((.5 #t))))`：

```
     O               O
    / \             / \
   /   \           /   \
  R     B        .5    .5
 / \   / \       / \   / \
RR RB BR BB    .25.25.25
                #t #t #f

```

* * *

> *旁注.* 对 Haskeller 来说，现在可以尝试去编写上述代码建议的概率单子的朴素和延续传递实现，这是一个返回所有可能结果概率列表的单子。这是一个有趣的技术细节，可能会成为未来博客文章的主题，但在[上述链接的论文](http://okmij.org/ftp/kakuritu/dsl-paper.pdf)的 2.2、2.3 和 2.4 节中已经很好地讨论了这个问题，并且在延续使用社区中是相当标准的做法。

现在，我并没有真正向你展示数据如何成为代码；相反，我展示了代码如何映射到“抽象语法树”表示或“推理树”表示。然而，与 AST 不同的是，我们不应该简单地构建整个推理树：推理树的节点如果有许多子节点，会呈指数级分支，我们在尝试进行*精确推理*时会在内存耗尽之前做不了多少事情。

然而，如果我们遵循“数据即代码”的口头禅，并将我们的树表示为*惰性*数据结构，其中每个节点的子节点实际上是一个延续，表示“为我构建这个子树”，我们可以恢复一个高效的表示。这些延续本身可以包含更多的延续，这些延续要放置在子树的叶子节点上，并且可以用叶子的值应用。因此，我们的*数据*结构在很大程度上由*代码*表示。（事实上，所有惰性数据结构都是这样工作的，但在这种情况下尤为显著。）

更具有说服力的是，对于分界延续的一流支持意味着你可以将一个常规函数 `() -> e` 实体化为一个（部分）树结构，其中更多的延续作为子节点准备好自行实体化。当然，我们可以评估这个树结构，以将其转回成一个函数。（在 Haskell 中，Monad 通过在抽象接口中无处不在的 lambda 使这种表示免费获得了一些小技巧。）

* * *

我发现真正迷人的是，一整类用于高效概率推断的算法，在推理树顶端重新组合时变得*显而易见*。例如：

+   变量和桶消除对应于记忆化延续，

+   拒绝采样对应于随机地沿着我们的树遍历路径，丢弃导致矛盾 (`fail`) 的样本，并且

+   重要性采样对应于随机地遍历路径，但如果一个分支失败，则切换到另一个分支。

作为浅层嵌入，遗憾的是我们无法进行像比较两个延续是否相等或进行复杂的代码分析这样的事情。但是一些初步的实验结果显示，这种方法在与现有的专门构建的推理引擎竞争时具有竞争力。

* * *

这里有一个更大的故事待讲述，关于 DSL 编译器，我们给用户提供工具来轻松实现他们自己的语言，从而提高其表达能力和生产力，但*也*允许他们实现自己的优化，从而不会像通常情况下仅编写解释器那样损失速度。我们希望利用现有的编译器框架，但根据适当的情况增加我们自己问题领域的增强功能。我们希望为我们的问题域提供行为规范，并教导编译器如何解决细节问题。编写一个适合所有人的编译器是不可行的，但每个人都可以拥有编译器精神 —— 我认为这将对软件工程产生令人兴奋和解放的影响。

<!--yml

分类：未分类

日期：2024-07-01 18:18:10

-->

# 定义“Haskelly”：ezyang 的博客

> 来源：[`blog.ezyang.com/2010/08/defining-haskelly/`](http://blog.ezyang.com/2010/08/defining-haskelly/)

## 定义“Haskelly”

虽然可能听起来像是老生常谈，但这篇文章的主题也来源于[abcBridge](http://blog.ezyang.com/2010/08/galois-tech-talk-abcbridge-functional-interfaces-for-aigs-and-sat-solving/)。John Launchbury 在我的演讲中提出了一个问题，让我开始思考 Haskell 中的 API 设计。（顺便说一句，[演讲视频](http://vimeo.com/14432112)已经发布！不幸的是，由于技术问题，第二部分不得不被删减了，但你仍然可以查看幻灯片。）

他的问题是这样的：

> 你用一种非常命令式的风格呈现了这个 AIG 结构在 ABC 工具中的存在，而实际上你给了我一个很好的类型化的 Haskell 接口，允许你进入并放置一个新的门或者抓取一个结构，我不禁想知道，为什么需要与该空间中正在进行的事情紧密联系？这里有一个思想实验：我可以想象自己拥有一个描述数据结构的纯函数数据结构...然后你最终得到了一个描述你希望图形看起来如何的函数描述，并告诉 ABC 一次性构建图形。

我曾声称 abcBridge 是一个用于操作与反转器图相关的“功能性 API”；也许我在撒谎！abcBridge——与底层命令式代码密切对应——真的是“功能性”的吗？或者，即使它不是功能性的，它至少有一个“Haskelly”API 吗？（一个 API 要“Haskelly”意味着什么？）为什么纯函数接口似乎在道义上比命令式接口更好？这不仅是一个具有哲学意义的问题，也是一个具有实际意义的问题——为什么我们更喜欢可能需要更复杂的底层实现的纯函数接口？

我的推测是，API 对其主机语言的忠诚度基于它利用语言易于使用的特定功能的程度。 Haskell 经常被介绍为一种“纯函数的、惰性的、强静态类型的编程语言”。逐个查看这些术语（非正式）...

+   *纯函数*指的是那些避免破坏性更新的 API，而是选择不可变性和持久化数据结构。使得以这种风格编写更容易的语言特性包括`final`和`const`关键字、代数数据类型、模式匹配和一组持久化数据结构的库。

+   *惰性* 指的是利用惰性来构建自定义控制结构和生成无限数据结构的 API。懒惰评估默认是惰性的语言特性，但在严格语言中，即使有显式的惰性注释或便捷的 lambda 抽象也鼓励懒惰风格。（Python 没有方便的 lambda，这就是为什么像 Twisted 这样的异步框架如此令人痛苦！）

+   *强静态类型* 指的是将各种形状的不变性编码到静态类型系统中，以便程序员的错误可以在编译时捕获，而不是在运行时。类型系统显然是这里的显著语言特性，其表达能力定义了你可以轻松添加到系统中的内容。

我们将利用这些语言特性的程序称为“Haskelly”，因为 Haskell 在语法和概念上都很容易使用它们！但与此同时，这些特性大多是正交的语言特性，对于任何给定的 API，你可能选择放弃一些特性以换取其他特性：也许这个特性在你的问题域中并不重要，也许这个特性会带来无法接受的性能损失或者不足以封闭的抽象。

以 abcBridge 作为具体示例，这里是你如何在实践中进行这种分类：

+   用于构建网络的单子接口距离纯函数的概念相当远，这是出于性能和控制的显式设计选择。（幸运的是，我们可以在其基础上构建一个更好的 API —— 实际上，我已经做了一个实验性实现。）然而，当你处理完全构建的网络时，API 采用纯函数风格，背后进行复制和`unsafePerformIO`以保持这种错觉。

+   abcBridge 并不直接使用惰性：特别是单子代码非常结构化，并且其中没有很多流程控制。

+   静态类型系统是 abcBridge 的重要组成部分，因为它与底层硬件操作如此紧密相关：它有两个单子，以及一组复杂的函数用于运行和转换这些单子，低级 FFI 绑定使得每一次尝试都能增强现有的基于 C 的类型系统。注意类型与函数接口之间有趣的互动：如果我们有一个纯函数接口，可能大部分这些复杂的类型都可以不用！（命令式代码似乎需要更强的类型系统技巧。）

就纯 Haskell 库而言，abcBridge 非常不“Haskelly”：我肯定会期待一个在纯 Haskell 中实现的等效库能提供更多。但它比起它衍生自的 C 库有了长足的进步。我们应该把握多大的发展空间？这完全取决于找到正确平衡——这就是 API 设计的艺术。

<!--yml

类别：未分类

日期：2024-07-01 18:17:05

-->

# 优化增量编译：ezyang 的博客

> 来源：[`blog.ezyang.com/2016/08/optimizing-incremental-compilation/`](http://blog.ezyang.com/2016/08/optimizing-incremental-compilation/)

当你运行 `make` 来构建软件时，你期望对先前构建过的软件进行构建所需的时间比从头构建的软件少。这其中的原因在于**增量编译**：通过缓存预编译的中间结果，程序中只有依赖于依赖图变化部分的部分需要重新编译。

“增量编译”这个术语并未详述依赖图是如何设置的，这可能导致对“增量编译器”的性能特征产生一些误解。例如，[维基百科关于增量编译](https://en.wikipedia.org/wiki/Incremental_compiler)声称增量编译器无法轻松优化其编译的代码，这是错误的：这完全取决于你的依赖图设置方式。

以 C 为例，考虑 `gcc`：

目标文件 `a.o` 依赖于 `a.c`，以及它（传递性地）包含的任何头文件（在这种情况下是 `a.h`）。由于 `a.o` 和 `main.o` 互不依赖，如果重建 `a.c`，`main.o` 就不需要重建。从这个意义上讲，C 实际上是非常适合增量编译的（没有任何 C 程序员会这样说）。C 之所以在增量编译方面名声不佳，是因为在简单情况下，头文件的预处理完全没有做到增量化（预编译头文件是解决这个问题的一种尝试）。

依赖图也意味着另外一件事情：除非函数体放在 `a.h` 中，否则生成 `main.o` 的编译器无法将函数体内联进去：它对 C 文件一无所知。在生成 `main.o` 的时候，甚至 `a.c` 可能还不存在（并行性！）这种优化只能在链接时发生（这就是为什么链接时优化存在的原因）。

Haskell 的 `ghc` 提供了一个很好的对比：

在这里，`Main.{hi,o}` 不仅依赖于 `Main.hs`，还依赖于它导入的模块 `A.hi`。GHC 仍然是增量的：如果你修改了一个 `hs` 文件，只有导入该源文件的模块需要重新编译。事情甚至比这个依赖图暗示的更好：`Main.{hi,o}` 可能仅依赖于 `A.hi` 的*特定*部分；如果这些部分未改变，GHC 将提前退出并报告无需编译。

尽管是增量的，GHC 支持内联，因为函数的展开可以存储在 `hi` 文件中，随后由导入它的模块使用。但现在有一个权衡：如果内联一个函数，你现在依赖于 `hi` 文件中的展开，这使得当 `A.hi` 变化时更有可能需要重新编译。

作为最后的例子，IDE 中的增量编译器，例如 Eclipse 中的 Java 编译器，与 GHC 的操作没有根本上的不同。主要区别在于（1）中间产品保存在内存中，这可以节省大量时间，因为解析和加载接口到内存中是一个巨大的时间消耗者，以及（2）他们试图使依赖图尽可能细粒度化。

* * *

这些都是相当出名的，所以我想转换思路，思考一个不太被理解的问题：如何为*参数化*的构建产品进行增量编译？当我说参数化时，我指的是 C 语言和 Haskell 语言范式的融合：

+   **分离编译。** 应该可以依赖于接口*而不是*依赖于实现（就像一个 C 文件依赖于头文件时一样）。

+   **零成本抽象。** 当提供了实现时，我们应该（重新）编译我们的模块，以便我们可以内联来自实现的定义（就像 Haskell 模块导入另一个模块时一样）。

这个问题对于 Backpack 非常重要，Backpack 引入了针对 Haskell 签名参数化的库。对于 Backpack，我们提出了以下设计：为以下两类构建产品生成不同的构建产品：（1）未实例化的代码，我们知道接口但不知道其实现，以及（2）已实例化的代码，我们知道它们的所有实现：

在蓝色框中，我们生成`A.hi`和`Main.hi`，这些文件仅包含对接口的类型检查结果。仅在粉色框中，我们将`A`的实现（在红色框中）与`Main`的用户组合在一起。这只是一个图表；因此，增量编译的工作方式与之前的工作方式完全相同。

* * *

我们在支持*多个*接口时遇到了一个有趣的问题：如果客户端实例化了一个接口但没有实例化另一个接口，我们该怎么办？我们是否有义务为这些部分实例化的模块生成构建产品？这并不是很有用，因为我们目前还不能生成代码（因为我们还不知道所有的实现）。

一个重要的观察是，生成这些接口实际上很便宜（因为你不进行任何编译）。因此，我们的想法是在需要时*即时*进行实例化，而不实际生成构建产品。部分实例化的接口可以缓存在内存中，但生成它们的成本很低，如果我们不需要它们（在这种情况下我们不实例化它们），我们就会获胜。

这是一个有点聪明的方案，而聪明总是有其暗面。在即时实例化中的一个主要复杂性来源是，现在对于道德上相同的构建产品存在两种表示：即时生成的产品和实际编译的产品：

这两个产品之间的子类型关系表明，我们总是可以用一个编译后的接口来代替即时实例化的接口，但反之则不行：即时接口缺少展开和其他编译代码可能需要的重要信息。

如果我们仅进行类型检查（即我们有未实例化的接口），我们可能*更喜欢*即时接口，因为它们需要较少的工作来创建：

相反，如果我们正在编译一个包，我们*必须*使用编译后的接口，以确保我们看到必要的展开内容用于内联：

特别复杂的情况是，如果我们正在对一组未实例化的模块进行类型检查，这些模块本身依赖于一些已编译接口。如果我们正在使用接口`p+a/M.hi`，我们应该对此保持*一致性*，因为`r`必须使用编译后的接口，`q`也必须如此：

另一种选择是确保我们始终构建产品，这些产品是根据即时接口进行了类型检查的，如下所示：

但这会带来一个令人不快的效果，即需要一切都建立两次（首先针对即时接口进行类型检查，然后进行真实构建）。

* * *

提前编译器的构建产品的依赖图传统上是编译器的公共 API 的一部分。正如我之前[写过的](http://blog.ezyang.com/2015/12/the-convergence-of-compilers-build-systems-and-package-managers/)，为了实现更好的增量性、更好的并行性和更多的功能（如参数化模块），依赖图变得越来越复杂。当编译器作者不愿意承诺一个接口，而构建工具作者对复杂的编译模型不感兴趣时，唯一运作良好的系统就是集成的系统。

Backpack 的即时接口实例化系统是否聪明过头了？我认为它对尝试解决的问题设计良好，但如果您仍然有复杂的设计，也许您正在解决错误的问题。我很想听听您的想法。

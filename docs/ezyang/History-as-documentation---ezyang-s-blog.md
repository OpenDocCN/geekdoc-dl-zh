<!--yml

category: 未分类

date: 2024-07-01 18:18:26

-->

# 历史作为文档：ezyang 的博客

> 来源：[`blog.ezyang.com/2010/02/history-as-documentation/`](http://blog.ezyang.com/2010/02/history-as-documentation/)

## 历史作为文档

这里提到的 [real](http://developers.slashdot.org/story/09/11/16/1626218/If-the-Comments-Are-Ugly-the-Code-Is-Ugly) 和 [easy](http://ask.slashdot.org/article.pl?sid=06/01/09/1544201) [argue](http://developers.slashdot.org/story/10/01/01/226232/Myths-About-Code-Comments) 讨论的是源代码注释的实用性、风格和实现方式，这些注释在 [pure code isn't enough](http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-7.html) 时尝试添加补充信息。

然而，仅仅关注特定源文件的最新快照，就会忽略文件内未包含的大量信息；即文件的历史和每一行的源流。这在快速原型功能时可能并不重要，因为源代码控制历史中的文件版本代表了不完整的、半成品的思想碎片，但一旦代码库过渡到更多的维护型工作流程，历史记录就显得尤为重要和不同寻常。特别是：

+   随着时间推移文件演变的日志可以说明模块的 *original* 意图，以及随后如何通过改装、扩展或修改进行调整。如果你需要重构其他人编写的代码，研究他们经历的修订版本是理解原始设计者思路的最佳方式。

+   任何特定行可能仅仅是初始检入时的环境代码的一部分，或者可能被针对某些问题的高度定位的提交所触及。在这种情况下，`git blame` 的输出对于识别为何这一特定行可能特殊，或者为何一个细微不同的排列方式是不正确的，是非常相关的。在非局部性更改的情况下，将一行与提交关联起来可以让您快速理解一个操作如何与其他许多操作一起产生全局效果。

鼓励开发人员编写非常描述性的提交信息（手中有差异：绝不在手上没有差异时编写提交信息），以便未来可能查看日志的人使用。即使在内联注释中可能会略显啰嗦，也是可以接受的，因为：

+   日志信息永不过时：它们始终与所附的修订版本相关！

+   一个良好的提交信息有助于代码审查，因为它提供了更改的非正式规范，外部观察者可以拿来验证代码。否则，审阅者需要确定代码的预期语义和实际语义，不考虑风格问题。

最后，关于保持历史记录清晰易用的几句话：

+   逻辑上组织良好的补丁集意味着任何给定的更改立即与日志消息相关联。如果您提交了一个包含大量语义更改的大提交，读者必须消除哪些特定的语义更改与差异的哪个部分相关。有意识地花时间使用`git add -p`逐个暂存片段是绝对值得的。

+   制作高质量的差异，避免触及不必要的代码。高流量的邮件列表，如 LKML，接收大量补丁，已经发布了[补丁提交指南](http://lxr.linux.no/#linux+v2.6.32/Documentation/SubmittingPatches)，以使差异尽可能易读，以供可能的审阅者查看。即使您不需要说服一个反应激烈的上游采纳您的更改，以后您可能会关心您的差异。

+   格式上的更改极大地扰乱了`git blame`输出，因为它们导致一行被标记为已更改，尽管没有语义上的差异发生。如果必须，它们应该是严格单独的。不频繁地进行更改是最好的选择。

+   利用历史重写来实现廉价提交，稍后再进行润色以供提交。

<!--yml

category: 未分类

date: 2024-07-01 18:17:11

-->

# 开放类型族不是模块化：ezyang 的博客

> 来源：[`blog.ezyang.com/2014/09/open-type-families-are-not-modular/`](http://blog.ezyang.com/2014/09/open-type-families-are-not-modular/)

在构建 Haskell 模块系统时面临的一个主要问题是处理类型类，我在此博客中[之前讨论过](http://blog.ezyang.com/2014/07/type-classes-confluence-coherence-global-uniqueness/)。我指出了目前在 Haskell 中使用类型类的模式假设“全局唯一性”，这在本质上是反模块化的；打破这一假设会有违许多现有数据类型的封装。

好像我们有选择一样。

实际上，**开放类型族**在 Haskell 中强制我们这样做，它们具有与类型类非常相似的特性，但附加的属性是对类型安全性 *要求* 的全局唯一性。我们别无选择（除非我们希望具有关联类型的类型类与类型类行为有所不同）：我们必须想办法调和类型族固有的非模块化特性与 Backpack 模块系统。

在这篇博文中，我想仔细阐述为什么开放类型族 *本质上* 是非模块化的，并提出一些解决这种非模块化的方案。如果你知道问题所在，可以跳过前两节，直接进入提出的解决方案部分。

* * *

在我们讨论开放类型族实例之前，首先值得强调的（直观）事实是，模块的签名应能够 *隐藏* 有关其实现的信息。这里有一个简单的例子：

```
module A where
    x :: Int

module B where
    import A
    y = 0
    z = x + y

```

在这里，`A` 是一个签名，而 `B` 是一个导入该签名的模块。模块系统的一个要点是，我们应该能够针对 `A` 来检查 `B` 的类型，而不知道我们实际上使用了哪个模块作为实现。此外，如果此类型检查成功，则对于 *任何* 提供 `A` 接口的实现，组合程序也应该能够通过类型检查。即使 `A` 的实现定义了签名中未提到的其他标识符：

```
module A where
    x = 1
    y = 2

```

如果 `B` 直接导入了这个实现，标识符 `y` 就会有歧义；但签名 *过滤掉* 了声明，以便 `B` 只能看到签名中的标识符。

* * *

考虑到这一点，现在让我们考虑一下与开放类型族类似的情况。假设我们在预置中定义了一些类型族`F`，我们有相同的例子：

```
module A where
    type instance F Int
    f :: F Bool

module B where
    import A
    type instance F Bool = Int -> Bool
    x = f 2

```

现在，以下模块`A`是否可以作为签名的合法实现？

```
module A where
    type instance F Int = Int
    type instance F Bool = Int
    f = 42

```

如果我们用正常的眼光看这个例子，我们可能会认为它是一个合法的实现。毕竟，`A` 的实现提供了额外的类型实例，但在先前出现（值级）声明时，它被签名隐藏了。

但是，如果我们戴上眼镜看整个示例，就会发生不好的事情：我们试图将整数 42 作为从整数到布尔值的函数。问题在于在模块`A`和模块`B`中，`F Bool`已被赋予不同的类型，这是不合理的…像*段错误*一样不合理。如果我们再仔细考虑一下，这并不奇怪：我们已经知道有重叠的类型家族是不合理的（并且热切地检查这一点），而签名样式的隐藏是允许重叠 sneak in 的一种简单方法。

令人沮丧的结论：**开放类型家族不是模块化的。**

* * *

那么，这是什么意思？我们应该举起双手放弃给 Haskell 一个新的模块系统吗？显然，我们不会束手无策。以下是一些对抗问题的方法。

### 基本提议：要求签名中的所有实例

解决不完全性最简单和最直接的方法是要求签名中提及由模块*传递*导出的所有家族实例。因此，在我们之前的例子中，`A`的实现不符合签名，因为它具有未在签名中提及的实例，但将满足此签名：

```
module A where
    type instance F Int
    type instance F Bool

```

虽然乍一看这似乎并不太繁重，但重要的是要注意，此要求是*传递*的。如果`A`碰巧导入另一个模块`Internal`，它本身有其自己的类型家族实例，*那些也必须在签名中表示*。（可以想象对于类型类来说，文件顶部的四十个导入中的任何一个可能会将各种类型类引入范围内，这很容易使情况失控。）这有两个主要用户可见的后果：

1.  模块导入*不是*实现细节——您需要在签名文件中复制此结构，并且

1.  添加实例*总是*一种不兼容的更改（没有减弱）。

当然，正如理查德对我指出的那样，这对于 Haskell 程序来说*已经*是事实（而您只是希望添加一个额外实例是“可以接受的”）。

尽管它不友好，但这一提议为其余提议提供了基础，您可以将其概念化为试图描述“何时可以避免编写所有签名中的实例”。

### 扩展 1：孤儿限制

假设我写了以下两个模块：

```
module A where
    data T = T
    type instance F T = Bool

module B where
    import A
    type instance F T = Int -> Int

```

尽管这两种类型实例确实重叠且被正确拒绝，但它们并非同样有问题：特别是，在模块`B`中的实例是一个*孤儿*。孤儿实例是类型类/族`F`和数据类型`T`的实例（它只需出现在左侧的任何位置），它位于一个既不定义的模块中。 （`A`不是孤儿，因为实例位于与数据类型`T`定义相同的模块中）。

我们可能会想知道的是，“如果我们禁止所有孤立实例，这是否会排除重叠的可能性？”答案是，“是的！（...有些技术性问题）。”以下是规则：

1.  签名必须提到所有被考虑的实现所导出的*所有*我们将称之为流浪汉实例的实例。如果一个家族 `F` 的实例不是与家族定义一起定义的，或者不是在第一个参数的头部与类型构造函数一起定义的，那么它就是一个*流浪汉*。所有孤立实例都是流浪汉，但并非所有流浪汉都是孤立实例。

1.  一个导出类型族的签名必须提到*所有*与类型族定义在同一模块中定义的实例。

1.  在签名中提及非流浪汉实例是完全可选的。

（旁注：我认为这不是最安全、但我认为这是最直接的规则版本。）这些规则的整点在于使得不可能编写重叠的实例，同时只要在写入实例时进行本地检查即可。为什么我们需要将孤立条件加强为流浪汉条件来得到这种非重叠性呢？答案是孤立的缺失并不意味着没有重叠，正如这个简单的例子所示：

```
module A where
    data A = A
    type instance F A y = Int

module B where
    data B = B
    type instance F x B = Bool -> Bool

```

在这里，`F` 的两个实例是重叠的，但都不是孤立的（因为它们的左手边提到了模块中定义的数据类型）。然而，`B` 实例是一个流浪汉实例，因为在 `F` 的第一个参数中没有提到 `B`。（当然，无论你检查第一个参数还是第二个参数，只要你保持一致即可。）

另一种思考这个规则的方式是，开放类型族实例并不是独立的实例，而是与类型构造函数*在其构造时*关联的元数据。这种方式下，非流浪汉类型族实例是模块化的！

然而，这种技术的一个主要缺点是它对于 Haskell 生态系统中孤立实例的合法用途实际上无济于事：当第三方同时定义了类型族（或类型类）和数据类型，并且你需要这个实例来满足自己的需求时。

### 扩展 2：孤立解决

这个提案基于 Edward Kmett 提出的一个提案，但我进行了改进。动机是为提供孤立实例的功能提供一个更好的解决方案，同时不会搞乱模块系统。提案的要点是允许包管理器有选择地启用/禁用孤立定义；然而，为了恰当地解释它，我想首先描述几种涉及孤立类型类实例的情况。（示例使用类型类而不是类型族，因为用例更清晰。如果你想象所讨论的类型类有关联类型，那么情况与开放类型族相同。）

故事始于一个第三方库，定义了一个数据类型 `T`，但没有提供你所需的实例：

```
module Data.Foo where
    data Foo = Foo

module MyApp where
    import Data.Foo
    fooString = show Foo -- XXX no instance for Show

```

如果你确实需要这个实例，你可能会被诱惑去定义它：

```
module MyApp where
    import Data.Foo
    instance Show Foo where -- orphan
        show Foo = "Foo"
    fooString = show Foo

```

后来，你将`Data.Foo`升级到了 1.0.0 版本，现在你的重叠实例错误！哎呀。

我们如何摆脱困境？线索在于，目前许多包作者是通过使用预处理器宏来“逃脱监狱”的：

```
{-# LANGUAGE CPP #-}
module MyApp where
    import Data.Foo
#if MIN_VERSION_foo(1,0,0)
    instance Show Foo where -- orphan
        show Foo = "Foo"
#endif
    fooString = show Foo

```

从道德上讲，我们希望在真实实例可用时隐藏孤立实例：我们希望在两个变体的`MyApp`之间进行透明切换：一个定义了孤立实例，另一个不定义并使用`Data.Foo`中定义的非孤立实例。选择取决于选择了哪个`foo`，这是由包管理器做出的决定。

让我们稍微混合一下。实例不必来自于`Data.Foo`，它可以是一个孤立实例的定义来自另一个库：

```
module MyOtherApp where
    import Data.Foo
    instance Show Foo where ... -- orphan
    otherFooString = show Foo

module MyApp where
    import Data.Foo
    instance Show Foo where ... -- orphan
    fooString = show Foo

module Main where
    import MyOtherApp
    import MyApp
    main = print (fooString ++ otherFooString ++ show Foo)

```

使用预处理器宏使其工作有些糟糕，但我们有 *两种* 方法可以手动解决重叠：我们可以从`MyOtherApp`中删除孤立的实例，或者从`MyApp`中删除孤立的实例。先验地，没有理由偏好其中一个。但是，根据删除的实例，`Main`可能需要以 *不同的* 方式编译（如果实例中的代码不同）。此外，我们需要在定义实例的模块与被删除实例的模块之间设置 *新的* （仅实例的）导入。

从这些例子中可以得出几个要点。首先，解决重叠孤立实例的最自然方式是简单地“删除”重叠实例；然而，删除哪个实例是一个全局决策。其次，启用哪些重叠的孤立实例会影响编译：您可能需要添加模块依赖关系才能编译您的模块。因此，我们可以想象一个解决方案，允许我们在不修改源代码的情况下做到这两点。

这是我们的计划：与以往一样，包可以定义孤立实例。但是，包定义的孤立实例列表是包的元数据的一部分，而实例本身在我们实际编译包（或其依赖项）时可能会被使用或不被使用。当我们对一组包进行依赖解析时，我们必须考虑所提供的孤立实例集合，并且只启用一个非重叠的实例集合，这就是所谓的 **孤立实例解析**。此外，我们需要从禁用其实例的包到唯一定义其实例的包添加额外的依赖关系（这可能限制我们实际可以选择为规范实例的孤立实例）。

这个提议的好处是，它解决了类型类用户已经存在的一个痛点，即在上游添加适当实例时定义孤立类型类实例不会出错。但你也可以把它看作是一个大型的 hack，并且它需要包管理器（或者其他管理孤立解决方案的工具）的配合。

* * *

对基本提议的扩展并不是互斥的，但是否值得为了现有的孤立实例的使用带来的好处而增加复杂性，这是一个开放的问题。当然，解决问题的其他方法可能还有，但眼下这些看起来是最合理的。

在 ICFP 会议上，我与 Derek Dreyer 有过一次有趣的交谈，他提到当开放类型族最初进入 GHC 时，他曾警告 Simon 它们不会是模块化的。随着封闭类型族的最近添加，原始论文中陈述的开放类型族的许多主要用例已经过时。然而，即使从未将开放类型族添加到 Haskell 中，我们仍然可能需要采纳这些解决方案：实例的全局唯一性深深植根于 Haskell 社区，即使在某些情况下我们对这个约束的实施比较松散，也不意味着我们应该积极鼓励人们打破它。

我对 ML 社区有一个离别的评论，因为类型类从 Haskell 进入：当你在你的语言中引入类型类时，不要犯和 Haskell 社区同样的错误，开始使用它们来强制 API 中的不变性。这种方式导致了实例的全局唯一性，而且失去了模块化可能是一个付出的代价太大。

* * *

*后记.* 一个自然的问题是，如果重叠的类型族实例中有一个“在外部不可见”，那么是否可以接受？当然，魔鬼在细节中；我们所说的类型族实例`F`的外部可见性是什么意思呢？

对于某些可见性的定义，我们可以找到一个等效的本地转换，它具有相同的效果。例如，如果我们根本不使用这个实例，那么有重叠是完全可以接受的。在这种情况下，直接删除该实例也是可以的。另一个例子是，我们可以要求在模块签名中没有类型族`F`的（传递性）提及。然而，消除类型族的提及要求了解足够的参数和方程式以减少：在这种情况下，类型族可以被替换为本地的封闭类型族。

有一个明确不起作用的定义是，如果`F`可以在一些未指定的类型变量中提及。这里有一个函数，它将`Int`强制转换为一个函数：

```
module A where
  type instance F Int = Int
  f :: Typeable a => a -> F a
  f x = case eqT of
    Just Refl -> x :: Int
    Nothing -> undefined

module ASig where
  f :: Typeable a => a -> F a

module B where
  import ASig
  type instance F Int = Bool -> Bool
  g :: Bool
  g = f 0 True -- oops

```

...重点在于，即使一个签名并没有直接提到重叠实例 `F Int`，类型细化（通常通过某种类似 GADT 的结构）可以意味着一个有问题的实例可以在内部使用。

<!--yml

category: 未分类

date: 2024-07-01 18:17:07

-->

# 编译器、构建系统和包管理器的融合：ezyang 的博客

> 来源：[`blog.ezyang.com/2015/12/the-convergence-of-compilers-build-systems-and-package-managers/`](http://blog.ezyang.com/2015/12/the-convergence-of-compilers-build-systems-and-package-managers/)

抽象。*传统的编译器、构建系统和包管理器之间的抽象屏障越来越不适合用于 IDE、并行构建系统和现代源代码组织。像 go 和 rustc 这样的最新编译器配备了一个成熟的构建系统；语义化的构建系统如 Bazel 和 Gradle 也期望管理软件的打包。这是否意味着我们应该放弃这些抽象屏障？寻找能够适应这些用例的新接口似乎是值得的。*

传统上，我们可以将编程语言的工具分为三部分来理解：

+   **编译器**接收单个源文件并将其转换为对象文件。（例如：`ghc -c`、`go tool 6g`、`javac` 和 `gcc -c`。）

+   **构建系统**接收一组源文件（及元数据），并将它们转换为最终的构建产品。它通过多次调用编译器来实现这一点。（例如：`go build`、`Setup build`、`make`、`ant compile`。）通常情况下，构建系统还知道如何*安装*所需的构建产品。

+   **包管理器**接收一个包名称，并获取和构建该包及其依赖项，然后将它们安装到某个存储中。它通过调用每个包的构建系统来实现这一点。（例如：`cabal install`、`cargo install`、`maven package`。）

这种分离构成了一个抽象屏障，允许这些组件可以分别提供。例如，单个构建系统可以与多个不同的编译器一起工作（如 gcc 和 clang）；反过来，编译器可以从用户的自定义构建系统中调用。一个库可以被打包成其本地语言的包管理器以及 Linux 发行版的打包系统；反过来，包管理器可能不关心库的实际构建过程。在今天的软件生态系统中，这些抽象屏障被广泛使用，效果显著！

然而，有越来越多的用例不能通过这些抽象屏障充分处理：

+   构建系统需要知道构建源文件的顺序；然而，这些信息的规范来源是源文件中的导入/包含声明。这些信息必须在构建系统内部复制，或者构建系统必须调用编译器以计算要使用的依赖关系图。无论如何，编译器不能*只是*一个简单的源文件到目标文件的转换器：它必须知道如何生成文件的依赖关系（例如，`gcc -M`）。除了 `Makefile` 桩外，没有标准化的格式来存储这些信息。

+   [依赖问题](https://github.com/rust-lang/rfcs/pull/1317#issuecomment-161729336)在模块依赖可以是循环时变得更加严重。一个构建系统必须知道如何解决循环依赖，可以通过一次编译模块的强连接组件，或者编译允许分开编译的“接口”文件。这是[激发 Rust 开发者](https://github.com/rust-lang/rfcs/pull/1317#issuecomment-161729336)不使用单一源码编译器的问题之一。

+   最佳的并行化可以通过源文件上的细粒度依赖图实现。然而，实现并行化的最理想地点是包管理器，因为调用包管理器会导致编译大部分代码。因此，像 Bazel 这样的系统统一了构建系统和包管理器，以便可以在整个构建过程中实现并行处理。（另一个例子是 GHC 的构建系统，它按模块基础并行编译所有内置包。）

+   IDE 想要从编译器获取比 `-c` 风格接口更深入的信息。但它们不能直接调用编译器，因为通过构建系统 / 包管理器是唯一的以正确标志和环境调用编译器的方式。Go 的内置构建系统意味着它可以更轻松地提供像 `go oracle` 这样的工具；否则，`go oracle` 需要能够适应外部构建系统。

+   某些语言特性对构建系统非常不友好；只有编译器具有足够的智能来管理构建过程。良好的例子包括宏（特别是可以访问文件系统的宏）、其他形式的编译时元编程和编译器插件。

因此，诱惑是将这些组件整合成一个完成所有工作的单一的巨型工具。这样做有很多好处：单一工具更容易开发，提供更统一的用户体验，并且不需要开发者指定不同组件之间的明确定义的 API。缺点呢？你无法替换巨型系统的部分组件。

我认为，即使面对这些特性，也值得考虑如何保持关注点的分离。不幸的是，我不知道正确的 API 是什么，但这里有一个草案提议：每个编译器和构建系统的编写者都应该有一个替代模式，让用户可以询问：“如何制作 `$output` 文件？” 这种模式返回 (1) 文件的依赖关系，和 (2) 制作它的方法。想法是将依赖查找逻辑放在编译器中（放置它的标准地方），同时让外部工具实际处理构建依赖关系。但这个提议还有很多细节没有涵盖。

您如何看待编译器、构建系统和包管理器的融合？您认为它们应该是巨型的吗？如果不是，您认为支持这些新用例的正确 API 是什么？我很想知道您的想法。

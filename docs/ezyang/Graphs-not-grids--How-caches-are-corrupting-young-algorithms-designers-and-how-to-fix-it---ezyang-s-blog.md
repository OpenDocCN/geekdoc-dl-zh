<!--yml

category: 未分类

date: 2024-07-01 18:18:15

-->

# 图形而非网格：缓存如何破坏年轻算法设计师及其修复方法：ezyang’s 博客

> 来源：[`blog.ezyang.com/2010/07/graphs-not-grids/`](http://blog.ezyang.com/2010/07/graphs-not-grids/)

小标题：大规模多线程处理器让你的本科计算机科学教育再次变得相关。

*快速排序。分而治之。搜索树。这些及其他算法构成经典本科算法课程的基础，展示算法设计的重要思想，以及性能模型是一个指令，一个时间单位。“一个指令，一个时间单位？多么古雅！”高速缓存无视算法研究人员和真实世界工程师知道，传统课程虽然不错，但却颇具误导性。仅仅看一些理论计算机是不够的：高性能算法的下一代需要与其运行的硬件保持协调。他们绝对正确。*

上周五，John Feo 博士在 Galois Tech Talk 上发表了题为[数据密集、不规则应用的要求和性能](http://www.galois.com/blog/2010/07/02/tech-talk-requirements-and-performance-of-data-intensive-irregular-applications/)的演讲（[幻灯片 1](http://www.lanl.gov/orgs/hpc/salishan/salishan2010/pdfs/John%20Feo.pdf)）。然而，Feo 还带来了另一个讲述更广泛的[自适应超级计算软件中心](http://cass-mt.pnl.gov/)的幻灯片（[幻灯片 2](http://supercomputing.pnl.gov/demos/CASS_Feo_SC09.pdf)）。最终的演示是关于大规模多线程处理器架构原则——特别是[Cray XMT](http://www.cray.com/products/xmt/)——以及在编写此类机器软件时遇到的实际工程问题的结合。由于我无法抵挡美好演示的诱惑，这些笔记的标题来自我与 Feo 在技术讨论后的一段对话；我并不是要贬低那些在传统处理器上进行研究的人，只是建议有另一种方法，Feo 认为这种方法应该得到更多关注。对于那些喜欢解谜题的人，本文末尾还将有一个“这是为什么会死锁？”的问题。

*图表不是网格。* 约翰·费奥开始区分科学问题和信息学问题。科学问题通常采用*网格*形式，是演化缓慢的系统，展示局部性原理，并仅涉及网格内部的最近邻通信。这类问题非常适合通过集群并行化解决：平面网格易于分割，最近邻通信意味着大部分计算将局限于包含分割的节点。局部性还意味着，在稍加注意的情况下，这些算法可以很好地与 CPU 缓存兼容：对于无关缓存的算法，这只是将问题分割直至适合板载的过程。

然而，数据信息学涉及的数据集却大不相同。考虑一下 Facebook 上的朋友关系图，或者互联网页面的相互链接，或者你国家的电力网络。这些都不是网格（即使是电网也不是）：它们是*图表*。与量子色动力学模拟不同，这些图表是动态的，不断地被许多自主代理修改，这对传统处理器和并行化提出了一些独特的问题。

*难以处理的图表。* 有几种类型的图表特别难以运行算法。不幸的是，它们在现实世界的数据集中经常出现。

[低直径（又称“小世界”）图](http://en.wikipedia.org/wiki/Small-world_network)是一种图表，其中任意两个节点之间的分离程度非常低。在这些图表上需要的工作量激增；任何查看节点邻居的算法很快就会发现自己不得不一次性操作整个图表。说再见内存局部性！紧密耦合还使得图表难以分割，而这是并行化图表计算的经典方法。

[无标度图](http://en.wikipedia.org/wiki/Scale-free_network)是一种图表，其中少数节点有大量的邻居，而大多数节点只有少量的邻居。这些图表也难以分割，并且导致高度不对称的工作负载：那些有大量邻居的少数节点往往会吸引大部分的工作。

图表的某些属性可能使计算更加困难。非平面图通常更难分割；动态图有并发的参与者插入和删除节点和边；加权图可能具有病理性的权重分布；最后，具有类型边的图阻止将图操作简化为稀疏矩阵操作。

这张来自 Feo 的幻灯片很好地总结了这些类型图表的即时效果。

*多线程处理器：计算世界的加特林机枪。* 加特林机枪是最早知名的快速射击枪之一。其他枪械简单增加射速，但很快发现，如果试图射击过快，枪管会过热。加特林机枪使用多管，每管独立射击速度较慢，但依次旋转时可以持续不断地发射子弹，同时允许未使用的枪管冷却。

空闲枪管冷却的时间类似于内存访问的延迟。由于内存访问开销大，传统处理器尝试“减少子弹使用”，通过处理器缓存来避免内存访问。然而，大规模多线程处理器采取不同的方法：而不是试图消除内存延迟，它通过上下文切换远离请求内存的线程来隐藏它，这样在切换回来时，访问已经完成并且数据可用。不需要无聊地等待数据；去做其他事情吧！在专用硬件上，PNNL 的研究人员已经能够使处理器利用率超过 90%；在非专用硬件上，性能目标要逊色一些，大约为 40%左右。

*影响。* 因为大规模多线程处理器隐藏了内存访问延迟，而不是试图消除它，传统的约束条件如内存局部性变得不重要。你不需要数据靠近计算，也不需要在处理器之间平衡工作（因为它们都进入共存的线程），也不需要像定时炸弹一样处理同步。你在本科计算机科学中学到的东西再次变得相关了！用 Feo 的话说：

+   自适应和动态方法都可以，

+   图算法和稀疏方法都可以，以及

+   递归，动态规划，分支和界限，数据流都可以！

因此，你的硬件将被定制用于类似图的计算。这包括一个巨大的全局地址空间来存放你的图，极其轻量级的同步形式如全/空位标志（Haskell 用户可能会认出它们与[MVars](http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Concurrent-MVar.html)非常相似；事实上，它们来自于数据流语言的同一血统）以及硬件支持线程迁移，以平衡工作负载。对于函数式语言来说，这是一种神圣的硬件圣杯！

Cray XMT 是约翰·Feo 及其研究伙伴一直在评估的一种特定架构。在处理具有较差引用局部性的算法时，它轻松击败传统处理器；然而，当你给传统处理器和具有良好引用局部性的算法时，它会慢一些。

*最大权重匹配*。有许多图问题——最短路径、节点间的介数中心性、最小/最大流、生成树、连通分量、图同构、着色、划分和等价性，仅举几例。Feo 选择详细介绍的是[最大权重匹配](http://en.wikipedia.org/wiki/Matching_(graph_theory))。匹配是边的一个子集，使得任意两条边不相邻于同一个顶点；因此最大权重匹配是一种使所选边的权重最大化的匹配（也可以考虑其他成本函数，例如在无权重图中可能希望最大化边的数量）。

虽然存在一种[多项式时间算法](http://en.wikipedia.org/wiki/Edmonds's_matching_algorithm)用于找到最大权重匹配，但是我们可以通过一种称为[Hoepman 的算法](http://arxiv.org/abs/cs.DC/0410047)的贪婪并行算法更快地得到近似答案。它类似于[稳定婚姻（Gale-Shapely）算法](http://en.wikipedia.org/wiki/Stable_marriage_problem)；算法运行如下：每个节点请求与其最昂贵的本地顶点对配。如果两个节点相互请求，则它们被配对，并拒绝所有其他配对请求。如果一个节点被拒绝，则尝试下一个最高的顶点，依此类推。由于一个节点只会接受一个配对请求，配对中的边永远不会与同一个顶点相邻。

Hoepman 的算法依赖于一个能够为每个节点分配处理器的理论机器。这对传统的集群机器并不利，因此[Halappanavar, Dobrian 和 Pothen](http://www.cs.odu.edu/~mhalappa/matching/index.html)提出了一个并行版本，将图分割成分区，每个分区分配给处理器，并使用队列来协调跨分区的通信。不幸的是，这种方法在某些情况下表现极差。Feo 对此现象进行了一些可视化：下面的图片展示了处理器核心的视觉图，绿色表示核心正在忙碌，白线表示处理器间的通信。尽管美国道路常规的平面图能很好地处理这个问题，但是由[Erdős–Rényi 模型](http://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93R%C3%A9nyi_model)和无标度图（我们之前提到的“难以处理”的图类型之一）生成的图表现出了大量的处理器间通信爆炸。

然而，像 Cray XMT 这样的机器使得更接近实现 Hoepman 原始算法成为可能。为每个节点分配一个线程，并按*描述的方式*实现算法。

为了实现信号传递，我们可以使用完整/空位原语。每条边有两个完整/空位位，每个端点分别拥有其中一个。当一个节点尝试与一个顶点配对时，它将自己的位填充为 1，然后尝试读取另一个位。当该位为空时，节点的线程将阻塞。如果另一个位读取为 1，则节点已配对：将节点拥有的所有其他位填充为 0，然后终止。如果另一个位读取为 0，则尝试与下一个具有最高边的邻居。

这种方法并不完全奏效，因为在 Cray XMT 上存在实际约束。特别是对于大图，不可能同时运行每个线程；只有一部分节点可以同时运行。如果恰好每个节点都在等待另一个当前未运行的节点，所有节点都会阻塞，我们就会陷入死锁。特别是，Cray XMT 不会默认抢占一个被阻塞的线程，因为上下文切换的成本如此之高。（你可以打开抢占，这样死锁会消失，但运行时间会大大增加。虽然 Cray 每个周期进行线程级上下文切换，但实际上从处理器中驱逐线程是非常昂贵的。）

Feo 应用的简单修复方法是以下观察：只要我们安排在昂贵边附近的节点，总是会有工作要做：特别是，两个与最昂贵的未配对边相邻的节点总是能够配对。因此，按照它们最昂贵的顶点对节点进行排序，然后运行算法。这解决了大部分死锁问题。

*结尾注释.* 尽管高度多线程的架构很有前景，但硬件方面仍需大量工作（使这项技术在大宗硬件上可用，而不仅限于 Cray XMT），以及软件生态系统（构建新的编程 API 以利用这种架构）。更进一步，这个领域的问题如此多样化，以至于没有一台机器能真正攻击所有问题。

尽管如此，Feo 仍然持乐观态度：*如果问题足够重要，机器会被建造起来的*。

*谜题.* 即使进行了排序修改，在禁用抢占的 Cray XMT 上实现最大匹配仍然会在一些大图上发生死锁。什么样的图会导致死锁，以及解决这个问题的简单方法是什么？（根据 Feo 的说法，他花了三天时间调试这个死锁！而且，不，打开抢占不是答案。）解决方案将在星期五发布。

（可能会有答案在评论部分，所以如果你不想被剧透，请避开目光。）

*更新*。我已删除到 CACM 文章的链接；虽然我认为这对 Reddit 读者来说很及时，但它暗示 Varnish 的设计者是一个“被缓存局部性腐蚀的年轻算法设计师”，这完全是错误的。这种表达意在表达 Feo 对算法社区普遍对复杂的缓存感知/无感知算法的过分关注的一般不满，并非针对任何特定人物。

（此处故意留白）

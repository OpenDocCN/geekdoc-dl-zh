<!--yml

category: 未分类

date: 2024-07-01 18:18:28

-->

# Git 中的工作流：单用户风格 : ezyang’s 博客

> 来源：[`blog.ezyang.com/2010/01/single-user-git-workflow/`](http://blog.ezyang.com/2010/01/single-user-git-workflow/)

Nelson Elhage 写了一篇关于[Git 和可用性](http://blog.nelhage.com/archives/64)的文章，在其中他讨论了 Git 看起来如此令人困惑的原因之一，这对于直接从 Subversion 风格工作流转入的用户来说。在讨论这个问题时，有一件事被提出来，那就是，虽然 Subversion 对其用户施加了相当严格的工作流程，但 Git 足够灵活，可以执行几乎任何类型的工作流。这对于一个使用 Git 的公司来说对用户来说是个噩梦：当他们在 Google 上搜索如何使用 Git 时，他们会得到多种多样的教程，每一个教程都是针对*不同的工作流程*。

在这个多部分系列中，我想讨论几种我见过或经历过的 Git 工作流类型。本文首先将简要介绍一个非常简单的 Git 工作流示例，即单用户工作流，这将建立一些你可能在其他工作流中看到的 Git 基本习语。

单用户工作流本质上很简单。在其最简单的形式下，它不过是一个略显高级的备份系统；你可以有很多版本的代码。你可以回到过去。因为我假设你对版本控制系统有一般的了解，所以我认为我不需要说服你这是有用的。本文还假设你足够熟悉在代码库中进行提交（虽然我们不会*假设*你知道如何使用索引；`-a`是一个神奇的标志）。

*备份*

当你从集中式 VCS 转向*分布式*VCS 时可能会注意到的第一件事是，除非你明确说出来，否则你的数据永远不会离开你的计算机。如果你在飞机上没有互联网访问，这很棒；你不需要堆积一堆变更而不能登入服务器。然而，这意味着你必须稍加考虑你将把变更`push`到哪里。一个简单的方法是利用多种[免费公共托管](http://git.or.cz/gitwiki/GitHosting)。如果你有一个具有 SSH 访问权限的服务器，私人的离线备份也很容易：在另一台服务器上使用 `git init --bare` 创建一个裸 Git 仓库，然后设置一个远程仓库，你可以向其推送……但我已经过于详细了！

如果你在自己的电脑上使用 `git init` 创建了一个 Git 仓库和工作副本，现在你将不得不处理 Git 远程。我个人觉得这相当烦人，因此总是安排在 `git clone` 我的工作副本之前设置好我的裸 Git 仓库（即服务器），这样可以轻松进行推送。我的步骤是：

# 在我的服务器上，创建一个目录（我喜欢`/srv/git/project.git`），然后在其中运行`git init --bare` # 在我的客户端上，运行`git clone ssh://servername/srv/git/project.git`

如果你必须在一个现有的仓库上设置远程仓库，可以使用以下命令来完成：

```
git remote add origin $REPO_URL
git config branch.master.remote origin
git config branch.master.merge refs/heads/master

```

对于那些好奇的人，第一行添加了一个名为“origin”的远程仓库（按照约定，这是从你可能克隆的仓库设置的远程仓库），关联到`$REPO_URL`。第二和第三行设置了从仓库拉取更改时的默认行为，以模拟通常在克隆时设置的配置。（注意：这有点糟糕。Git 1.7.0 引入了`--set-upstream`标志来解决这些问题。）

然后，你只需要使用`git commit`提交更改，然后用`git push`将它们推送到远程仓库。

*主题分支*

作为单个用户，在你的仓库中大部分的工作都可以很好地一起进行；你不必担心别人会进来破坏你的提交。然而，偶尔你可能会发现自己在进行一次大的重构时，你不得不结束今天的工作，或者中断来处理一个更紧迫但更小的 bug 修复。在这里，Git 的廉价提交和分支使得这一切变得非常简单。

如果你认为你目前正在进行的更改很大，但是你很快就能回来处理它们，可以使用`git stash`命令将你的更改暂时保存到一个暂存区。然后你可以进行你的小改动，完成后使用`git stash pop`来恢复你的旧更改。暂存区最适合作为一个临时的存储空间，当可能时应立即清空；你不想看到多个被暂存的更改，并试图弄清楚哪一个包含了你关心的更改。

如果你的更改比那还要大一点，或者你认为你暂时无法继续进行任何大的更改，你可以创建一个所谓的主题分支。首先，使用`git checkout -b 新分支名`切换到一个新分支（选择一个描述性的名字）。然后，进行一次提交以保存你的更改。如果你打开`gitk`，你会注意到你现在有一个附加在`master`上的提交。你可以再次切换到 master 分支使用`git checkout master`，并进行你需要的其他更改。

当你最终确定你的主题分支完成时，你需要将它重新合并到 master 分支中。有两种方法可以做到这一点：

1.  你可以假装你的主题分支作为一个整体只是一个大补丁，因此，这个补丁应该合理地适用于最新版本的 `master`。在主题分支上运行 `git rebase master`（你可以用 `git status` 检查），这将把这个“补丁”应用到 `master` 上。然后你可以切换到 master 并 `git pull topic-branch` 来快进 master 到主题分支。由于清理旧分支是件好事，我建议之后运行 `git branch -d topic-branch`。

1.  你可以认为历史很重要，并执行一次合并。在主分支上，运行 `git merge topic-branch`。就像第一种情况一样，你可以用 `git branch -d topic-branch` 清理主题分支。

清理旧主题分支是一个良好的习惯，因为这意味着你可以使用 `git branch` 快速提醒自己哪些主题分支可能需要你的关注。

另外，如果你关心备份你的主题分支，你应该运行 `git push origin topic-branch`。你可以使用 `git push origin :topic-branch` 从远程删除主题分支（注意冒号）。

*清理历史*

许多人在源文件内部的文档中投入了很多注意力，以便解释某段代码的作用。然而，代码文档的另一个优秀来源是查看代码的*历史*；特定片段是何时引入的，作者在进行更改时对此作了什么解释？`git blame` 将为你提供每个 Git 文件中每行何时更改的详细描述，而 `git log` 将展示对特定文件所做的更改的综合情况。

不幸的是，这种机制的有用性高度依赖于你在提交中做出的消息质量，如果你正确使用 Git 并经常提交，可能在某些消息上会有所疏忽。别担心；这种情况发生在我们每个人身上。你只需记住在完成时*整理一下*（即重写历史）。

在这种情况下，`git rebase -i` 是你的好朋友。指定一个参数来指定你想要重写历史的距离（`HEAD~N`，其中 N 是一个数字可能是个不错的选择），然后根据你的心情重写历史。你有三个主要的工具：

+   `edit`，当 Git 到达该提交时，只需运行 `git commit --amend`：这很简单：你有一个独立的提交，但没有写一个好的提交消息，那么 amend 允许你把提交消息改成有用的内容。

+   `squash`：如果你做了一堆非常小的提交，现在你看着它们并决定，不，它们实际上逻辑上是一致的，那么你可以把它们合并在一起。

+   `edit` with `git checkout HEAD~`: 这个操作会给你一个带有该提交更改的工作树，但这些更改实际上并不属于一个提交的一部分。你可以使用`git add -p`（它会选择性地将你的更改块添加到索引中）然后使用`git commit` *不带* `-a` 标志，把一个“太大”的提交分解成易处理的小块。

这种策略与专题分支特别配合，适合以下工作流程：

1.  使用 `git checkout -b 主题名称` 创建专题分支，

1.  在分支上进行大量修改，使用难以理解的总结进行小提交，

1.  使用 `git log -u master..HEAD` 检查你的更改，

1.  使用 `git rebase -i master` 编辑你的更改，

1.  切换到主分支并使用 `git pull 主题名称`。

部分一就到这里了！你可能已经注意到，所有这些策略似乎互为补充：这种不寻常的整合是 Git 简单内部模型的一个优点之一。如果大家想看一些这些技术在实际中的例子，我很乐意再多写一些博客。感谢阅读。

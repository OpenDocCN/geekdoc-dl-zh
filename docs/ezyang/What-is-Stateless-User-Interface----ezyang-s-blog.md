<!--yml

类别：未分类

日期：2024-07-01 18:17:06

-->

# 什么是无状态用户界面？：ezyang 的博客

> 来源：[`blog.ezyang.com/2015/11/what-is-stateless-user-interface/`](http://blog.ezyang.com/2015/11/what-is-stateless-user-interface/)

无状态用户界面的本质是，您对程序所采取的操作不应取决于隐含状态。无状态界面更容易理解，因为对某些参数执行命令将*始终*执行相同的操作，而在有状态界面中，命令可能与昨天不同，因为隐含状态已更改并影响程序的含义。

这种哲学是任何 Haskeller 都应该直观理解的……但是今天的 Cabal 和 cabal-install 未能达到这一理想。以下是 Cabal 中现今状态性的一些例子：

1.  运行`cabal install`时，构建的软件包被安装到“包数据库”中，使它们可以被 GHC 使用。

1.  运行`cabal install`时，要安装哪些包以及版本的选择取决于本地包数据库的状态（当前解算器试图重用已安装的软件）和远程包存储库的状态（指定了可用的包和版本）。

1.  运行`./Setup configure`会将`LocalBuildInfo`保存到`dist/setup-config`，这会影响进一步的`Setup`命令（`build`、`register`等）。

这些状态实例都给用户带来了复杂性：你认为有多少次（1）因为本地包数据库无法逆转而重建了它，（2）因为依赖解算器开始选择了过新版本的包而使项目停止构建，或者（3）因为一些功能未启用而要求重新配置 Cabal？

状态是有成本的，但并非没有理由：

1.  包数据库的存在是因为我们不希望每次想要构建某些东西时都必须从头开始重建我们所有的包（实际上，这就是包管理器的全部意义）。

1.  解算器依赖于本地包数据库，因为用户不耐烦，希望在构建他们的软件之前避免构建新版本的包；

1.  解算器依赖于远程包存储库，因为开发人员和用户都不耐烦，希望尽快将新版本发布给用户；

1.  配置会缓存其信息，因为用户不希望每次尝试构建他们正在工作的软件包时都要重新配置该软件包。

面对看似固有的状态性问题领域，无状态用户界面能够取得成功吗？当然可以。

有时状态仅仅被用作*缓存*。如果缓存被清除，一切应该仍然可以正常工作，只是速度会慢一些。包数据库（原因 1）和配置缓存（原因 4）都属于这一类别，但今天的 Cabal 犯的关键错误是，如果删除这些信息，事情*并不*会“自动解决”。必须有足够的信息来重建缓存；例如，配置缓存应该补充实际输入到配置步骤的内容。（有时，关注点的分离意味着你根本无法做到这一点。如果你要求 ghc 使用不在缓存中的 lens 包，ghc 会怎么做？）此外，系统的行为不应因缓存数据的存在与否而变化；例如，求解器（原因 2）不应基于缓存的有无做出不同（语义上有意义的）决策。

否则，必须能够显式管理相关的状态：如果状态是远程包仓库（原因 3），必须有一种方式来针对某个状态进行固定。（有一个工具可以做到这一点，它叫做 Stack。）虽然有时是必需的，显式状态会使接口复杂化，并且更难描述系统可以做什么。最好将这种状态保持得尽可能小和集中。

我不认为我在这里说的任何事情特别微妙。但这确实是你需要专门考虑的事情；否则，你将会被有状态接口的陷阱所诱惑。但如果你拒绝这种诱惑，穿上苦衣，你的用户将更为感激你。

*致谢.* 这些想法不是我自己的：我要感谢 Johan Tibell、Duncan Coutts 和 Simon Marlow，因为他们的讨论让我理解了这一点。本文中的任何错误都是我自己的。这不是号召行动：Cabal 的开发者们意识到了这一点，并正在尝试修复，详见这个[hackathon wiki page](https://github.com/haskell/cabal/wiki/Hackathon2015)。但我在互联网上并没有看到这种哲学明确写出来的地方，因此我在这里为你写下它。

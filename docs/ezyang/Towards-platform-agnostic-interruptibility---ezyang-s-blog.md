<!--yml

category: 未分类

date: 2024-07-01 18:18:09

-->

# 向平台无关的可中断性迈进：ezyang 的博客

> 来源：[`blog.ezyang.com/2010/09/towards-platform-agnostic-interruptibility/`](http://blog.ezyang.com/2010/09/towards-platform-agnostic-interruptibility/)

上一篇文章中，我讨论了在[Windows 上模拟 pthread_cancel](http://blog.ezyang.com/2010/09/pthread-cancel-on-window/)时遇到的一些显著困难。今天，我想讨论像 GHC 这样的跨平台编译器实际上应该做什么。回想我们的三个设计目标：

1.  GHC 希望能够将阻塞 IO 调用放在工作线程上，然后稍后取消；目前在 Linux 上可以做到这一点，但在 Windows 上不行，

1.  用户希望编写友好于中断的 C 库，并使其与 Haskell 的异常机制无缝集成，以及

1.  我们希望拥有 IO 世界的黄金之手，即将阻塞 IO 代码瞬间转变为良好行为、非阻塞、可中断的代码。

我将讨论这三种情况，简要描述为阻塞系统调用、协作库和阻塞库。我建议，由于缺乏跨平台的中断机制，正确的中断接口是允许用户定义处理程序以处理异步异常。

* * *

*可中断的阻塞系统调用*。在过去，GHC 曾经有[一些错误](http://hackage.haskell.org/trac/ghc/ticket/2363)，其中对阻塞 IO 系统调用的外部调用导致 Windows 无法被中断。这是 POSIX 和 Windows 异步 IO 哲学长期存在的差异：POSIX 认为某些看似阻塞但可以被信号中断的函数，而 Windows 则依赖回调函数。因此，看似无害的调用实际上破坏了中断性，并且必须手动重写为既适用于 POSIX 模型又适用于 Windows 模型的形式。

虽然理论上和实际上可以手动将每个阻塞调用转换为异步版本（顺便说一句，在 Linux 上完全可以，因为你可以发送信号），但这非常烦人，违背了我们可以简单地将阻塞调用移到另一个线程以假装它们是非阻塞的这一想法。

自 Windows Vista 以来，我们可以使用一个方便的新函数[CancelSynchronousIo](http://msdn.microsoft.com/en-us/library/aa363794(VS.85).aspx)来中断阻塞 IO 调用。请注意，取消 IO 与取消线程不同：特别是同步操作仅返回失败，并将上次错误设置为`ERROR_OPERATION_ABORTED`，因此系统调用必须由 GHC 直接执行（然后可以注意到中止操作并进一步传播中断），或者出现在能够处理此错误条件的 C 代码中。不幸的是，此功能在较早版本的 Windows 上不存在。

> *旁注.* 有什么我们可以为 Vista 之前的 Windows 做吗？显然没有：Windows Vista 中所做的底层更改部分是为了使`CancelSynchronousIo`这样的功能成为可能。如果我们要对何时调用`TerminateThread`强制执行极强的不变量；也就是说，我们必须手动审查我们考虑终止的每个函数，那么在那一点上，你可能会选择重写为异步风格。

* * *

*可中断的协作库.* 这是我们对 C 库有很高控制权的情况：它可能是我们自己的库，或者我们可能正在为 GHC 和一个富有表现力的异步底层库之间编写一个中间 C 层。我们想要做的是让 GHC 无缝地将其异步异常转换为我们的 C 可以注意到并优雅地处理的异常。

正如你现在可能已经意识到的，有*很多*方法可以实现这一点：

+   信号。仅限 POSIX，信号可以通过`sigprocmask`或`pthread_sigmask`临时阻止，并且可以通过`sigaction`安装信号处理程序来清理并可能退出线程或长跳转。

+   Pthread 取消。仅限 POSIX，取消可以通过`pthread_setcanceltype`临时阻止，并且可以通过`pthread_cleanup_push`安装取消处理程序。

+   Select/poll 循环。取消请求通过正在轮询的套接字发送，处理程序可以选择忽略它们。

+   事件对象。仅限 Windows，线程可以从`OpenEvent`的句柄接收取消请求，但选择忽略它们。

+   IO 取消。仅限 Windows Vista，如上所述。

+   完成队列。仅限 Windows，类似于 select/poll 循环。

试图本地实现所有这些机制并没有太多意义。因此，我的建议是：在接收到异步函数时，让 GHC 在不同的线程中调用用户定义的函数，并让用户自己决定该怎么做。在许多方面，这实际上并不是一个决定：特别是，我们要求程序员自己解决问题。只能与 POSIX 一起工作的库仍然只能与 POSIX 一起工作。然而，这仍然是一个进步，因为当前状态是，Haskell 和 FFI 代码的异步异常*必然*表现不同。

* * *

*可中断的阻塞库.* 因为阻塞 IO 比非阻塞 IO 更容易编程，阻塞接口往往更普遍且测试更充分。（我的一个朋友在夏季在 Chromium 上工作时对 NSS 的非阻塞接口的[bug](https://bugzilla.mozilla.org/show_bug.cgi?id=542832)感到无穷无尽的抱怨。）将一些系统调用重写为异步风格可能是可行的，但当你有一大块现有的 C 代码要进行接口处理时，这种重写的维护成本很快就变得难以承受。该怎么办呢？

唉，世上并无灵丹妙药：如果库从未考虑到可中断性，强行终止它很可能会使你的程序处于破坏状态。然而，对于那些想要走捷径的人来说，用户定义的函数方法仍然可以让你在*真的*需要时调用`TerminateThread`。

* * *

总之，我建议可中断性补丁不仅仅局限于简单的`interruptible`关键字，还应允许用户定义异步异常处理程序，这些处理程序编译后与运行时系统（RTS）兼容，并提供一些内置处理程序，这些处理程序提供合理的默认行为（无论是特定于平台还是非特定于平台，尽管我预计后者会提供较弱的保证）。

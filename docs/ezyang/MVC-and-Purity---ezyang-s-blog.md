<!--yml

分类：未分类

date: 2024-07-01 18:18:15

-->

# MVC 和纯度：ezyang’s 博客

> 来源：[`blog.ezyang.com/2010/07/mvc-and-purity/`](http://blog.ezyang.com/2010/07/mvc-and-purity/)

*注意保护注意.* 纯函数式编程展示了面向对象 MVC 实践推荐的相同实践。

[模型-视图-控制器](http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) 是一种广泛使用的面向对象设计模式，用于组织带有用户界面的应用程序功能。我在早期编写 Web 应用程序时首次接触到它。模型/视图分离对我作为 PHP 程序员来说有深刻的直觉意义：如果没有它，你将得到一堆将 HTML 打印语句与 MySQL 查询混合在一起的意大利面模板。但是控制器总是有些模糊不清（[控制器到底是什么？](http://www.c2.com/cgi/wiki?WhatsaControllerAnyway)）。它究竟是做什么的？它是一种“粘合”代码，将模型和视图绑在一起并给它们命令的代码。但对我来说，这总是一个不太满意的答案（[输入验证应该放在哪里？](http://discuss.joelonsoftware.com/default.asp?design.4.354410.6)），不久之后我离开了 Web 应用程序的世界，我的问题没有答案。

通过接触纯函数式编程，我现在相信控制器和模型/视图分离确实是副作用代码（IO）和纯代码之间的分离。

*控制器依赖于模型和视图，但模型和视图不应（直接）依赖于控制器。* 纯代码和不纯代码不能自由混合。特别是，你不能从纯代码引用不纯代码（除非使用 `unsafePerformIO`）。但是，不纯代码可以调用纯代码（尽管可能涉及一些[技术细节](http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Monad.html)），而生成的代码是不纯的。因此，如果控制器是不纯的代码，而模型/视图是纯代码，分离两者只是确保如果我们有任何不纯的代码，我们已尽可能多地将纯计算提取出来。换句话说，如果我有一个读取和写入数据的函数，并且其中有些行与 IO 无关，我应该将它们移动到它们自己的函数中。也许这些行是模板系统，这时它是视图；也许这些行在运行一些复杂的方程式，这时它是模型。纯/不纯并不能捕捉到模型/视图的区别。

*控制器接收输入并启动响应.* 因此，控制器是输入输出，即 IO。

控制器处理影响模型或视图的事件。纯代码有点像活在真空中：它可以进行计算，但它不能做任何有用的事情，因为它不能有任何副作用，因此我们无法告诉它该计算什么，或者查看计算结果。不纯代码是我们通过将这些信息传递给我们的纯代码来完成任何实际工作的方式。

对这种区分存在几种可能的反对意见。以下是其中一些：

大多数面向对象模型都是有状态的，而状态并不是纯粹的！这种误解可能源于 IO 和 State 都是单子的事实。然而，通过简单运行状态机，我可以将状态单子转换为单一的纯值：具有状态的代码是单子的，但也是纯粹的，因为它没有任何外部副作用。共享状态则稍微棘手，通常不是纯粹的。

控制器代码不一定非要是不纯的，这里举一个例子。在这里我会有点先入为主：我打赌你有一个模型，但这个模型只是与你的核心业务逻辑有关的某个边缘联系。如果你有代码将二进制字符串解析为消息对象（但实际上并不处理在网络上传输或接收这些二进制字符串），你就有了一个网络消息的迷你模型。你应该将其与真实的模型分开，但为了可测试性，你还应该将其与网络代码分开。关注点分离可能是可以改变的，但你类型签名中的少量 IO 始终是诚实的。

关于纯度“苦衣”还有一些告别话语：相当广泛地认为，采用 MVC 模式会使你的应用程序在初始阶段变得更加复杂，在纯函数语言中，你被迫从一开始就尊重这种区分。因此，在纯函数语言中编写小程序可能会令人沮丧，因为你不想从一开始就使用笨重但可扩展的工程实践，而语言却要求你这样做。Haskell 为你提供了许多方式来让编程变得愉快，但需要一段时间来适应。好处是，当你的程序增长时，这种分离将继续得到强制执行，可能会避免混乱的重构。

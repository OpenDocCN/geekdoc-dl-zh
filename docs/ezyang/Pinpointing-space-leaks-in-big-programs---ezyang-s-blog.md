<!--yml

类别: 未分类

日期: 2024-07-01 18:17:45

-->

# [大程序中定位空间泄漏](http://blog.ezyang.com/2011/06/pinpointing-space-leaks-in-big-programs/) : ezyang’s 博客

> 来源：[`blog.ezyang.com/2011/06/pinpointing-space-leaks-in-big-programs/`](http://blog.ezyang.com/2011/06/pinpointing-space-leaks-in-big-programs/)

在你能够尝试调试空间泄漏的最大可能的 Haskell 程序中，有一个非常好的选择是 GHC，它接近 10 万行代码（尽管，值得庆幸的是，这个数字的 25% 是注释）。今天，我将描述我在 GHC 中修复的一个这样的空间泄漏。这不是一个完整的故事：我的代码最终是罪魁祸首，所以没有涵盖如何调试你没有写的代码。但我仍然愿意认为这个故事涵盖了一些主要的要点：

我真的很喜欢这个案例，因为我必须按顺序做所有这些事情，才能准确定位并最终修复这个空间泄漏。希望你也能喜欢！

### 设置一个测试用例

当我最终认真解决这个 bug 时，我想要做的第一件事是制作一个`Parser.hs`的简化测试用例，实际上就是导致内存溢出的输入文件。为什么不直接在`Parser.hs`上测试呢？

+   大输入导致大量数据，如果你不知道自己在找什么，大量数据会让人感到无所适从和困惑。答案可能显而易见，但如果有太多无用信息，你可能会错过。

+   这是一个让 2GB 内存的机器 OOM 的文件。空间就是时间，使用这么多内存的 Haskell 程序运行时间相对较长。如果我想进行增量更改和重新测试（这是希望），在迭代之间等待半小时是不可取的。

+   这是一个在过去曾对我有效的策略，所以它似乎是一个收集信息的好地方。

实际上，我作弊了：我能够在 GHC 的测试套件中找到另一个大幅较小的测试文件，它与运行在`Parser.hs`上时 GHC 的堆分析匹配，所以我将我的注意力转移到那里。

在你的情况下，你可能没有一个“更小”的测试用例可以使用。那么你就需要减少你的测试用例。幸运的是，非源程序的输入往往更容易减少！

+   二分查找一个更小的大小。你的零假设应该是空间泄漏是由更多数据引起的，所以如果你删除一半的输入数据，泄漏仍然应该存在，只是不那么严重。如果可以削减并重新测试，就不要费心搞复杂。

+   有时空间泄漏是由特定类型的输入引起的，在这种情况下，删除输入集合的一半可能会使泄漏消失。在这种情况下，您应该首先测试输入集合的另一半：问题数据可能在那里，您可以继续在该代码块上进行二进制搜索。在最坏的情况下（删除任何一半都会导致泄漏消失），请专心开始有选择地删除您认为“低风险”的行。如果删除一行数据后泄漏消失，则您对算法可能实际发生的事情有了非常好的数据。

+   对于具有依赖关系的输入数据（例如，源代码模块导入），尝试首先通过使用存根数据来消除这些依赖关系。

在最理想的情况下，这个过程只需要几分钟时间。在最坏的情况下，这个过程可能需要一个小时左右，但会为问题的本质提供深刻的见解。事实上，在我得到我的新测试用例之后，我进一步减少了它，直到它成为一个很好的紧凑大小，可以包含在博客文章中：

```
main = print $ length [
  ([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),
  ([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),
  ([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),
  ([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),
  ([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),
  ([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),
  ([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),
  ([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),
  ([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),
  ([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),
  ([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),
  ([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),
  ([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),
  ([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),
  ([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),
  ([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),
  ([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0),([0,0,0],0)]

```

一个普通的堆分析看起来与更大的解析器案例非常相似，即使它是不同的空间泄漏，修复它仍然是值得的。

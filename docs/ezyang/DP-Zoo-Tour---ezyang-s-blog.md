<!--yml

category: 未分类

date: 2024-07-01 18:18:04

-->

# DP Zoo Tour : ezyang’s blog

> 来源：[`blog.ezyang.com/2010/11/dp-zoo-tour/`](http://blog.ezyang.com/2010/11/dp-zoo-tour/)

*有人告诉我，这一切都发生在动物园里……*

我一直认为*动态规划*是一种对将来使用的子计算进行存储的实践，这个名字相当糟糕。为什么不叫它*填表算法*呢？因为实际上，把动态规划算法看作是填写表格的算法，是一个相当不错的思路。

事实上，你几乎可以完全通过动态规划算法的表格形状及数据从一个单元格流向另一个单元格的方式来描述一个动态规划算法。如果你知道这个形状是什么样子的，通常你可以直接推断出复杂度，而不必知道问题的任何具体内容。

所以我做的事情是收集了一堆来自*算法导论*的动态规划问题，并画出了表格和数据流。这里有一个简单的例子，解决装配线问题：

蓝色表示我们可以免费填写的单元格，因为它们不依赖于其他单元格。红色表示我们想要找出的单元格，以便从中选择最优解决方案。灰色表示沿途的代表单元格及其数据依赖关系。在这种情况下，机器到给定单元格的最优路径仅取决于其前两个单元格的最优路径。（因为，如果有更优的路径，它早已显示在我的前两个单元格中！）我们还看到任何单元格都有恒定数量的箭头出口和*O(n)*个单元格在这个表中，因此该算法显然总共需要*O(n)*的时间。

* * *

这里是下一个介绍示例，矩阵乘法的最佳括号化。

每个单元格包含矩阵 i 到 j 的最佳括号化。为了计算单元格的值，我们必须考虑所有可能导致此结果的现有括号化组合（因此有多个箭头）。有*O(n²)*个框，和*O(n)*个箭头，总复杂度为*O(n³)*。

* * *

这里有一个很好的方框用于找到两个字符串的最长公共子序列。每个单元格表示第一个字符串到*x*和第二个字符串到*y*的最长公共子序列。我会让读者计算单元格和箭头，并验证复杂度是否正确。

* * *

构建最佳二叉搜索树的方式与最佳矩阵括号化非常相似。但是索引有些复杂。（哦，顺便说一句，*算法导论*是以 1 为基础索引的；我在这里切换到了 0 索引来进行我的示例。）

* * *

现在我们进入练习领域！欧几里德双调旅行推销员问题在网络上相当知名，其复杂的递归关系与底部边有关。每个单元格表示从 i 到 j 的最佳开放双调路径。

* * *

美丽的换行问题，其变种是 Knuth TeX 换行算法的核心，利用一些额外信息来限制必须查找回的单元格数目。（TeX 算法进行全局优化，因此复杂度会是 *O(n²)*。）每个单元格代表了到目前为止所有单词的最佳换行方式。

* * *

最后，编辑问题似乎就像作者决定尽可能增加的复杂性一样，当你意识到他们要求你设计的每个字符串操作对应于某个先前单元的单一箭头时，这个问题就会很好地解决。有用！每个单元都是从源的那个前缀到目的地的那个前缀的最优编辑链。

* * *

*动物园管理员非常喜欢朗姆酒。*

方块、三角形、矩形，这些是我通常找到的桌子。我很好奇 DP 算法是否填补了更多奇异的桌子。发送它们给我，我会画出来！

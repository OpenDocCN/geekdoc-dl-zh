<!--yml

类别：未分类

日期：2024-07-01 18:17:30

-->

# 当你将三种研究性编程语言混合在一起时会发生什么：ezyang 的博客

> 来源：[`blog.ezyang.com/2012/05/what-happens-when-you-mix-three-research-programming-languages-together/`](http://blog.ezyang.com/2012/05/what-happens-when-you-mix-three-research-programming-languages-together/)

“...所以这就是我们要做的！”

“酷！你打算用什么语言写？”

“嗯，我们曾经认为我们需要三种编程语言...”

“...三个？”

“...而且它们也将是研究性编程语言...”

“你疯了吗？”

* * *

这就是我决定用 Coq、Haskell 和 Ur/Web 编写最新软件项目时，在我脑海中流淌的对话。我对选择有合理的理由：我想要 Coq 是因为我实际上不想从头开始实现一个定理证明器，我想要 Ur/Web 是因为我实际上不想手写 JavaScript 来实现 AJAX 接口，我想要 Haskell 是因为我不想写一堆 C 来让 Ur/Web 和 Coq 进行通信。但总体来看，整件事情似乎有些荒谬，像是三种研究性编程语言的不祥结合。

最终，效果还不错。现在，这意味着什么取决于你的期望：情况并非“一切都毫不费力并带有非常好的说明”。然而，如果情况是这样：

+   没有单一问题最终需要花费不可估量的时间和刮毛，

+   编写的任何补丁都进入了上游，改善了软件对未来开发者的情况，而且

+   在工程润滑上花费的时间少于用劣质语言构建系统所需的时间，

+   项目中所有参与者都愿意学习所涉及的所有语言（如果只有一个人，这很容易），

那么是的，“效果”“还不错”。在这篇文章中，我想稍微详细描述一下当我将这三种语言组合在一起时发生了什么，并对可能适用于类似活动的一般准则进行疯狂的推测。

### Coq

虽然 Coq 是一个研究语言，但它在学术界非常广泛地使用，大部分的不稳定性来自于我在项目中没有使用的高级特性。所以我在 Coq 中遇到的主要问题不是 bug，而是将其与系统集成（即，使其与 Haskell 通信）。

**准则 1.** *交换格式将不会被记录下来，只是足够好以完成工作。*

Coq 已经设计用于允许进程间通信（这是 Proof General/Emacs 和 Coq 互相通信的方式），但是 coqtop 和 Proof General 之间的格式是未记录的、临时的，并且没有为我的应用程序传输足够的信息。在这种情况下，有两种解决方法：忍耐并实现不好的协议或者修改编译器以实现更好的协议。我选择了后者，并学到了一些非常有趣的东西：

**Maxim 2.** *在类 ML 语言中，由于类型检查器的帮助，对代码库进行简单但影响深远的更改非常容易。*

对前端进行的更改非常简单；这个更改没有任何深层次的东西，类型检查器和 grep 的结合使我能够在零调试的情况下完成补丁。通过在几个关键位置放置一些 XML 标记，我得到了足够合理的输出来构建系统的其余部分。

*旁白.* 后来，我了解到 Coq 的最新版本（8.4 及更高版本）中 coqide 有另一种交换格式。从现在开始，这可能是与 Coq 进行交互的正确机制，尽管这一点因为交换格式未记录而变得更加困难；然而，我已经[提交了一个 bug](https://coq.inria.fr/bugs/show_bug.cgi?id=2777)。希望它能比我的补丁做得更好。最初，我的补丁打算部分实现 PGIP，一个通用的与定理证明器交互的交换格式，但后来我和 Coq 开发者发现 PGIP 项目不活跃，另一个用户 Isabelle 也停止使用他们的 PGIP 后端。（有时标准并不总是有帮助！）

### Ur/Web

Ur/Web 的使用相对较少，因此我们遇到了各种各样的 bug 和系统各部分的其他不便，从前端到编译器都有。它们是阻碍吗？不是！

**Maxim 3.** *在一些核心功能中发现的具有确定性可复现性的 bug，原始代码的积极作者会非常快速地修复。*

这个格言并不适用于设计中的基本限制（在这种情况下修复会需要大量的精力，尽管作者通常会对这种情况有很好的想法），但是对于其他这种类型的 bug，我发现可以非常快速地得到修复。虽然我可能会把部分原因归功于我的指导教师是编译器的作者，但我认为问题不止于此。当有人向你展示一个 bug 时，你写的有趣而棘手的代码碎片会给你一种不可抗拒的小难题的自豪感。而我们*喜欢*小难题。

还有一个推论：

**Maxim 4.** *学术界对问题越不感兴趣，你自己解决问题的可能性就越大。*

学术界对于他们不感兴趣且对他们研究不重要的问题有些过敏。这意味着他们不喜欢处理这些细节，但这也意味着他们可能保持了简单，这意味着你更有可能能够弄清楚它。（一个好的类型检查器也确实有很大帮助！见第二条原则。）Ur/Web 编译的 FastCGI 服务 404 时存在一个简单的 bug，有一个非常简单的修复方法；我还对 Ur/Web 做了一些修改，使其可以在没有`make install`的情况下运行。积极维护研究软件的维护者通常对这些“工程”补丁非常接受，这些补丁对研究本身没有直接用途，但我认为它们是成为开源社区良好公民的重要组成部分。

### Haskell

好的，Haskell 现在不仅仅是一个研究语言；它也是一种非常灵活的通用语言，在现实世界中得到了相当多的应用，并且可以作为“普通”语言来对待。这使得它成为将其他两种语言粘合在一起的好选择；它几乎可以做任何事情，并且在调用 Haskell 中的函数时具有非常好的 FFI 支持。这带我们来到我们的下一个原则：

**原则 5.** *对于任何 DSL 来说，FFI 都是一个至关重要的功能，并且应该是准备语言供一般使用的任务中的首要任务之一。*

通过它们的 FFI 让 Haskell 和 Ur/Web 相互通信对于使所有这些工作都能正常运行至关重要。Ur/Web 是一种用于编写 Web 应用程序的领域特定语言，除了其他事情外，它不包括健壮的系统库（例如执行外部进程并与其交互）。大多数语言都会遇到这个问题，因为要添加库支持需要花费一些功夫，但 Ur/Web 有第二个问题：所有具有副作用的事务也需要能够回滚，这对于一般的输入输出来说相当困难。然而，通过 FFI，我们可以在一个更合适的语言（Haskell）中实现需要这种库支持的任何代码，将其封装在一个提供适当事务保证的 API 中，并让 Ur/Web 使用它。如果没有这个，我们将无法使用 Ur/Web：它是一个非常灵活的逃生舱。

指定一个 FFI 也是展示你的语言与 C 语言“不同”的一个好方法：它迫使你思考你期望外部函数具有的不变量（引用透明性？线程安全性？）：这些不变量恰好是你的语言中编写的代码自动满足的那些。这真的很酷！

但是，由于操作 C 指针的函数是非事务性的，Ur/Web 仅限于处理基本 C 类型的 FFI 函数，例如整数和字符串。因此，对于 Ur/Web 来说，解析的问题成为至关重要的问题，因为字符串是复杂结构的首选交换格式。虽然不同的语言会有不同的情况，但通常：

**准则 6。** *确保你知道如何在涉及的所有语言中进行解析。*

### 结论

我提出了研究多语言能力的六大准则：

1.  交换格式将没有文档，并且只足以完成工作。

1.  在类 ML 的语言中，由于类型检查器的帮助，对代码库进行简单但影响深远的更改非常容易。

1.  某些核心功能中确定性可重现的 bug 将由代码的活跃原始作者非常快速地修复。

1.  对学者来说越无趣的问题，你越有可能自己解决。

1.  FFI 对于任何 DSL 都是至关重要的功能，并且应该是准备语言以供一般使用中涉及的任务中的首要任务。

1.  确保你知道如何在涉及的所有语言中进行解析。

如果你记住了所有这些准则，我相信在一些额外的错误修复和为了研究编程语言的好处而进行的琐事之间的权衡是一个引人注目的选择，应该认真考虑。是的，你必须愿意涉足你使用的所有工具的内部，但对于任何足够重要的工具来说，这是不可避免的。比你的编译器更重要的工具是什么？

*附言。* 相关的应用是[Logitext](http://logitext.ezyang.scripts.mit.edu/main)。

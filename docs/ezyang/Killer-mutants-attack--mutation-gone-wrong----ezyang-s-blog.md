<!--yml

category: 未分类

日期：2024-07-01 18:17:56

-->

# Killer mutants attack (mutation gone wrong)：ezyang’s 博客

> 来源：[`blog.ezyang.com/2011/03/killer-mutants-attack-mutation-gone-wrong/`](http://blog.ezyang.com/2011/03/killer-mutants-attack-mutation-gone-wrong/)

这是由于误用可变状态导致的一系列 WTFs。

* * *

我们将从一些 Java 开始。你期望这段代码做什么？

```
Sensor Accel = sm.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
Sensor Orient = sm.getDefaultSensor(Sensor.TYPE_ORIENTATION);
sm.registerListener((SensorEventListener) this, Accel, sm.SENSOR_DELAY_FASTEST);

```

表面上，它注册当前对象以接收加速度计更新。但如果我告诉你 getDefaultSensor 是这样实现的呢：

```
public Sensor getDefaultSensor (int type){
        if(sensors == null) {
                sensors = new Sensor(mContext, type);
                return sensors;
        }else if(sensors.checkList(type)){
                sensors.addSensor(type);
                return sensors;
        }else{
                sensors.removeSensor(type);
                return sensors;
        }
}

```

这段代码完全无法管理预期的语义：有一个宽为 `sm` 的单个 `Sensor` 对象（存储在 `sensors` 中），随着 `getDefaultSensor` 的调用累积传感器值。因此，实际上，`this` 将同时接收来自加速度计和磁力计的事件。唯一的救赎是，当我们注册事件监听器时，通常确实希望它们接收所有事件，所以如果我们不仔细看的话可能不会注意到这一点。这是来自 [OpenIntents SensorSimulator](http://code.google.com/p/openintents/source/browse/trunk/sensorsimulator/SensorSimulatorSettings/src/org/openintents/sensorsimulator/hardware/SensorManagerSimulator.java) 的真实代码。

* * *

以免你认为我只取笑别人的代码，这里是[我自己项目的一处差异](https://github.com/ezyang/git-ftp/commit/291bc437da61ca7065b7e3651446704fd47decab)：

```
@@ -197,13 +197,7 @@ def upload_all(tree, ftp, base):

     ftp.cwd(base)
     for blob in tree.blobs:
-        logging.info('Uploading ' + '/'.join((base, blob.name)))
-        try:
-            ftp.delete(blob.name)
-        except ftplib.error_perm:
-            pass
-        ftp.storbinary('STOR ' + blob.name, blob.data_stream)
-        ftp.voidcmd('SITE CHMOD ' + format_mode(blob.mode) + ' ' + blob.name)
+        upload_blob(blob, ftp, base)

@@ -260,11 +254,25 @@ def upload_diff(diff, tree, ftp, base):
             node = subtree/components[-1]
             assert isinstance(node, Blob)

-            logging.info('Uploading ' + full_path)
-            ftp.storbinary('STOR ' + file, node.data_stream)
-            ftp.voidcmd('SITE CHMOD ' + format_mode(node.mode) + ' ' + file)
-            # Don't do anything if there isn't any item; maybe it
-            # was deleted.
+            upload_blob(node, ftp, base)

```

这看起来相当合理：我已经分离出一些常见的`storebinary`逻辑。你能看出 bug 是什么吗？[这里有个提示](https://github.com/ezyang/git-ftp/commit/ec14419c53ae5e4ac155f5daf685fface98c01a8)。

问题在于 `upload_all` 在 FTP 连接上改变了当前工作目录（可变状态！），而 `upload_diff` 则没有（完全从 `base` 工作目录操作）。上传函数假设了 `upload_all` 风格的工作目录更改，因此所有 `upload_diff` 的上传都被放在了基本目录中。可变性损害了模块化！解决方法是摆脱这种变化，并手动计算完整路径；这也消除了原始 `upload_all` 实现中一些复杂的不变性维护。

* * *

令人矛盾的是，尽管 Haskell 鼓励你不要使用突变，但当你使用它时，Haskell 强大的静态类型系统赋予了你一种非同寻常的能力，即在静态地编码关于突变的复杂不变量——如果你没有使用突变，这些不变量是不必要的。一个小例子是 [ST monad](http://www.haskell.org/haskellwiki/Monad/ST)，它使用 rank-2 类型来确保对可变内存的引用不能逃逸出 `runST`，这是孤立的“突变线程”。

如果你尝试静态地排除对可变 API 的不正确使用，你可能会发现自己深陷于高级类型系统特性之中。我在与[abcBridge](http://blog.ezyang.com/2010/08/galois-tech-talk-abcbridge-functional-interfaces-for-aigs-and-sat-solving/)合作时发现了这一点，并且非常努力地使用类型来防止底层 C 库的不当使用。这里有一个相关的代码引用：

```
-- | When you duplicate a network, node indexes may change, so if you
-- would like to use old references, they need to be translated first.
-- You can read this type as @Node n -> NT n2 (Node n2)@ or @Node n ->
-- NQ n2 (Node n2)@, with the condition that the @n2@ index was one
-- generated by 'branch' or 'speculate'.
translate :: (G.NetworkMonad m AIG (Dup n n2)) => Node n -> m AIG (Dup n n2) (Node (Dup n n2))

```

这确实是一些 WTF，等级-2-幻影类型的代码，但它源于我偶然发现的一个非常具体的错误，并且我并不确定我会记得在未来避免它（你能猜到是什么吗？）一个好奇的读者可能会问，为什么我需要在第一次重复网络？因为底层库提供的一些操作是破坏性的，我可以提供持久网络的假象的唯一方法是在破坏之前复制。

* * *

总结起来：

+   变异通常不符合人们的预期，

+   变异不是模块化的，而且

+   变异是复杂的。

尽量避免它！

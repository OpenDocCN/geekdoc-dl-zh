<!--yml

category: 未分类

date: 2024-07-01 18:17:41

-->

# [模块化编程的第一印象](http://blog.ezyang.com/2011/08/first-impressions-of-module-programming/)：ezyang 的博客

> 来源：[`blog.ezyang.com/2011/08/first-impressions-of-module-programming/`](http://blog.ezyang.com/2011/08/first-impressions-of-module-programming/)

在我在 Jane Street 的时间里，我做了大量涉及模块的编程工作。我涉及了函子、类型和模块约束、嵌套模块，甚至是一等公民模块（尽管只是次要的）。不幸的是，在《类型与编程语言高级主题》中关于模块的章节让我无法专注，所以我不能真正称自己在模块系统上是“有知识的”，但我认为我已经足够使用它们来对它们发表一些评论。 （所有关于惯例的评论都应该被视为 Jane Street 风格的指示。注：他们已经[开源](http://ocaml.janestreet.com/?q=node/13)了部分他们的软件，如果你真的想看看我谈论的一些东西。）

好消息是它们基本上按照你的期望工作。事实上，它们非常巧妙。当你开始使用大量使用模块的代码库时，你会注意到的最基本的习惯用法是这样的：

```
module Sexp = struct
  type t = ...
  ...
end

```

实际上，我曾经在 Henning Thielemann 的 Hackage 上看到过这种风格的地方，特别是[data-accessor](http://hackage.haskell.org/package/data-accessor)，我之前[有过涵盖](http://blog.ezyang.com/2010/04/inessential-guide-to-data-accessor/)。与 Haskell 不同，在 OCaml 中，这种风格确实有意义，因为你从未像在 Haskell 术语中的未限定导入一样，你通常会将类型称为`Sexp.t`。因此，抽象的基本单位可以被认为是一种类型——大多数简单的模块恰好是这样——但你可以辅助类型和操作该类型的函数。这是相当容易理解的，你可以将模块系统大多解析为一种便捷的命名空间机制。

然后事情变得有趣。

当你使用 Haskell 的类型类时，每个函数都会单独指定对参数的约束。OCaml 没有任何类型类，因此如果你想要这样做，你必须手动将字典传递给函数。你可以这样做，但这很烦人，OCaml 程序员更喜欢更大的东西。所以，你不是将字典传递给函数，而是将模块传递给函子，并一次性专门化所有“通用”函数。这更加强大，这种力量克服了在任何给定时间显式指定你使用的模块的烦恼。约束和嵌套模块从这个基本思想中自然而然地产生，当你实际尝试在实践中使用模块系统时。

对于我来说，关于模块系统最难理解的事情之一是类型推断和检查是如何在其上操作的。部分原因是类型类如何工作与之间存在的不匹配。当我有一个函数时：

```
f :: Monoid m => m -> Int -> m

```

`m`是一个可以与任何特定类型统一的多态值。因此，如果我执行`f 5 + 2`，如果为`Int`定义了适当的 Monoid 实例（即使`+`不是 Monoid 实例方法），那是完全合理的。

然而，如果我用模块做同样的技巧，我必须小心添加额外的类型约束来教编译器某些类型确实是相同的。这是一个额外的类型限制的例子，感觉应该被统一化消除，但实际上并没有：

```
module type SIG = sig
    type t
    val t_of_string : string -> t
end

module N : SIG = struct
    type t = string
    let t_of_string x = x
end

let () = print_endline (N.t_of_string "foo")

```

实际上，在您添加那个`SIG`声明时，您必须指定`t`和`string`是相同的：

```
module N : SIG with type t = string = struct

```

有趣！（实际上，当您为大量类型指定约束时，而不仅仅是一个类型时，情况会变得更加恼人。）涉及到函子时，正确性也很棘手，在 OCaml 3.12 之前有一些错误，这意味着您必须采取一些丑陋的措施来确保您实际上可以编写您想要的类型约束（`with type t = t`… 这些`ts`是不同的…）

有时候，您确实会觉得在 OCaml 中真的很想要类型类。高度多态功能通常是关键因素：如果您有类似`Sexpable`（可以转换为 S 表达式的类型），使用模块系统感觉非常像鸭子类型：如果它有一个`sexp_of_t`函数，并且类型正确，它就是“sexpable”。天哪，我们基础库中大多数复杂的函子都是因为我们需要处理多参数类型类的道德等价物。

单子绑定当然是没有希望的。好吧，如果您的程序中只使用一个单子（然后您只需通过打开模块来专门化您的`>>=`到该模块的实现）。但在大多数应用程序中，您通常在一个特定的单子中，如果您想快速切换到`option`单子，您就没那么幸运了。或者您可以重新定义运算符为`>>=~`，希望没有人刺伤您。`:-)`

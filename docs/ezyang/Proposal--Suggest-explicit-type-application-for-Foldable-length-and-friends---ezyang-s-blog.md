<!--yml

category: 未分类

date: 2024-07-01 18:16:59

-->

# Proposal: 建议为 Foldable 的 length 及其伙伴添加显式类型应用：ezyang 的博客

> 来源：[`blog.ezyang.com/2017/03/proposal-suggest-explicit-type-application-for-foldable-length/`](http://blog.ezyang.com/2017/03/proposal-suggest-explicit-type-application-for-foldable-length/)

**tl;dr** *如果你使用类似于 length 或 null 这样的可折叠函数，其中实例选择完全由输入参数决定，那么通过引入显式类型应用来使你的代码更加健壮是很有必要的。对于像 fold 这样的函数来说，如果你的类型匹配不正确，返回类型可以进行交叉检查，因此这不是必要的。如果你没有提供这种类型应用，GHC 应该会发出警告建议你显式注释，就像它建议在顶层函数中添加显式类型签名一样。*

最近，有些人对[Foldable 实例导致“坏”代码编译](https://mail.haskell.org/pipermail/libraries/2017-March/027716.html)有所争论。典型例子是这样的：你写了`length (f x)`，其中`f`是返回列表`[Int]`的函数。在未来的某个时刻，同事重构`f`以返回`(Warnings, [Int])`。在重构后，`length (f x)`是否继续类型检查？是的：`length (f x)`将始终返回 1，无论内部列表有多长，因为它使用了`(,) Warnings`的`Foldable`实例。

邮件列表中提出的解决方案是移除`Either`的`Foldable`，这种疗法可以说比病情更糟糕。但我认为抱怨`Foldable`对元组和`Either`的实例使你能够编写类型检查但完全错误的代码确实有其道理。

[Richard Eisenberg](https://mail.haskell.org/pipermail/libraries/2017-March/027743.html)将这个问题描述为“如果它编译，那么它就有效！”与一般的多态代码之间的紧张关系，后者应该在尽可能多的情况下适用。然而，我认为这里有些微妙之处。为什么`Functor`多态代码从来不会因为“太通用”而引起问题，但`Foldable`会？我们可以构造一个类似的情况：我写了`fmap (+2) (f x)`，其中`f`再次返回`[Int]`。当我的同事将`f`重构为返回`(Warnings, [Int])`时，`fmap`现在使用了`(,) Warnings`的`Functor`实例，但代码仍然无法编译，因为`(+1)`的类型与`[Int]`不匹配。是的，我们仍然可以构造出`fmap`在类型更改后继续工作的情况，但这些情况要少得多。

这两个程序之间有一个明显的区别：`fmap` 程序是*冗余*的，因为类型受输入容器、映射在其上的函数以及使用结果的上下文的约束。就像纠错码一样，冗余使我们能够检测到错误的发生；当你减少冗余时，错误变得更难检测。对于 `length`，对所选实例的唯一约束是输入参数；如果你搞错了，我们就无法判断出来。

因此，正确的做法是在需要的地方*重新引入*冗余。像 `fold` 和 `toList` 这样的函数不需要额外的冗余，因为它们通过它们的返回参数的使用进行交叉检查。但是像 `length` 和 `null`（以及可能是 `maximum`，它仅弱约束其参数具有 `Ord` 实例）这样的函数没有任何冗余：我们应该在这些地方引入冗余！

幸运的是，使用 GHC 8.0 提供了一种非常简单的方法来引入这种冗余：**显式类型应用**。（这也是独立地由[Faucelme 建议的](https://www.reddit.com/r/haskell/comments/5x4yka/deprecate_foldable_for_either/def96j4/)。）在这种情况下，不再写 `length (f x)`，而是写 `length @[] (f x)`，表示你想要列表的长度。如果你想要映射的长度，你会写 `length @(Map _) (f x)`。现在，如果有人改变了 `f` 的类型，由于显式类型应用不再匹配，你将会得到一个类型错误。

现在，你可以在你的 FTP 代码中写入这个。因此，我建议我们向 GHC 添加一个小小的改进：让用户指定函数的类型参数为“建议为显式”。在调用点，如果这个函数在没有给定类型应用的情况下被使用，GHC 将会发出一个警告（可以通过通常的机制禁用），并说：“嘿，我在这个类型上使用了这个函数，也许你应该添加一个类型应用。”如果你真的想要抑制警告，你可以简单地在类型上应用一个类型空位，例如 `length @_ (f x)`。作为一个小小的改进，你还可以指定一个“默认”类型参数，这样如果我们推断出这个参数，就不会发出警告（这将让你在不需要显式指定类型参数的情况下使用列表函数）。

就是这样！没有 BC 破坏性标志日，没有污染函数，没有摆脱 FTP，没有丢弃实例：只是一个新的编译指示，和一个可选的警告，让那些想要避免这些 bug 的人们能够使用它。这不会解决所有 `Foldable` 的 bug，但应该能够消除最明显的一些。

大家怎么看？

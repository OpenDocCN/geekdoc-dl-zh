<!--yml

我们的指针网络意味着我们需要替换树中*每一个*节点！当寻找持久性更新时，额外的循环指针对我们造成了不利影响。

日期：2024-07-01 18:18:23

-->

# 因此，在单个节点上，我们希望快速访问父节点和子节点以及快速更新。快速访问意味着我们需要指向远离这个节点的指针，快速更新意味着我们需要消除指向这个节点的指针。

> 指针的流动自然地从树的根部流向叶子，像蓝莓馅饼一样容易走到一个节点的子节点。

一开始，有一个二叉树：

```
struct ctree { // c for children
  int val;
  struct ctree *left;
  struct ctree *right;
}

```

你本可以发明拉链：ezyang's 博客

不幸的是，给定一个节点，没有好的方法找出其父节点！如果只需要高效的父节点访问，你可以简单地在另一个方向使用单个指针：

```
struct ptree { // p for parent
  int val;
  struct ptree *parent;
}

```

指针的流向然后从树的叶子到根部：

当然，综合起来，你可以拥有两者的最佳：

```
struct btree {
  int val;
  struct btree *parent;
  struct btree *left;
  struct btree *right;
}

```

我们的数据结构已经变成了循环的，但结果是我们有了非常高效的方法来在树上上下移动，以及插入、删除和移动节点，只需通过改变节点、其子节点和其父节点上的相关指针进行变化。

*天堂出问题了。* 指针技巧对于可变的情况来说没问题，但我们想要的是不可变的节点。我们想要的节点不会在我们不知情的情况下发生变化，因为其他人决定乱动指针。

对于`ctree`，我们可以使用一种称为*路径复制*的标准做法，我们只需要更改到节点变更的路径上的节点。

实际上，路径复制只是不可变更新规则的一个具体表现：如果你替换（即更新）了某些东西，你必须递归地替换指向它的任何东西。在`ptree`中，我们需要知道更新节点的子树并更改它们全部。

但是`btree`失败得相当惨重：

指针的流动自然地从树的根部流向叶子，轻而易举地走到一个节点的子节点。

我们想要做的是以更智能的方式结合`ptree`和`ctree`，这样我们就不会得到一堆额外的指针，但我们仍然可以找到节点的子节点和父节点。

在这里，我们做出了关键的简化假设：我们只关心对单个节点的父母和子女的高效访问以及更新。快速访问意味着我们需要指向远离这个节点的指针，快速更新意味着我们需要消除指向这个节点的指针。

类别：未分类

很简单！只需翻转一些指针（显示为红色）。

恭喜！你看到的数据结构就是我们称之为拉链的东西！现在我们唯一要做的任务是弄清楚如何在`struct`定义中实际编码它。在此过程中，我们将为这个图表内部的各种特性分配一些名称。

让我们考虑一个稍微复杂的例子：

我们引入了一些符号便利：三角形代表与给定节点连接的树，当我们不关心任何子节点时。正方形是附加到任何给定节点的值（我们明确显示它们，因为节点与其数据的区别很重要）。红色节点是我们想要围绕的节点，我们已经翻转了必要的指针（红色）使其他所有东西都可以访问。

当我们在这个位置时，我们可以遍历树，或者沿着指向远离绿色节点的红色箭头上升；我们将这个箭头指向的结构称为上下文。树和上下文的结合给我们在拉链中的一个位置。

```
struct loc {
  struct ctree *tree;
  struct context *context;
}

```

就像树一样，上下文也是一个递归数据结构。在下面的图表中，它正是被涂黑的节点。然而，它不是一个普通的节点，因为它缺少一个子节点指针，并且可能包含指向它自己父节点的指针。

这个特定位置包含的是"右上下文"，也就是说，指向上下文的箭头指向右边（如下图所示为黑色）。

你可以看到，在我们的树结构中，上下文包含另一个上下文、一棵树和一个值。

同样，"左上下文"对应于指向左边的箭头。它包含相同的组件，尽管从这里的图表可能不太明显：递归子上下文在哪里？好吧，因为我们在树的顶部，所以我们有一个"顶部上下文"，它不包含任何值。这相当于`Nothing`的道德等价物。

```
enum context_type {LEFT, RIGHT, TOP}
struct context {
  enum context_type type;
  // below only filled for LEFT and RIGHT
  int val;
  struct context *context;
  struct ctree *tree;
}

```

就是这样！你需要制作一个拉链的所有部分：

```
> data Tree a = Nil | Node a (Tree a) (Tree a)
> data Loc a = Loc (Tree a) (Context a)
> data Context a = Top
>                | Left a (Tree a) (Context a)
>                | Right a (Tree a) (Context a)

```

*练习：*

1.  编写函数以向上、向左下和向右下移动我们的`Tree`定义。

1.  如果我们有另一种树的定义 `data Tree a = Leaf a | Branch Tree a) (Tree a)`，我们的上下文定义会如何改变？

1.  为链表编写数据和上下文类型。

*进一步阅读：* 这种模式的最初晶化可以在[Huet 的论文（PDF）](http://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf)中找到，两个入门材料的经典来源在[维基书籍](http://en.wikibooks.org/wiki/Haskell/Zippers)和[Haskell Wiki](http://www.haskell.org/haskellwiki/Zipper)。从那里，关于类型微分如何导致拉链的迷人讨论！请参阅[Conor 的论文（PDF）](http://www.cs.nott.ac.uk/~ctm/diff.pdf)，维基书籍文章，以及 Edward Kmett 在使用[生成函数](http://comonad.com/reader/2008/generatingfunctorology/)引入更多异国情调数据类型讨论的文章。

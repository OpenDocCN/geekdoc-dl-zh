<!--yml

类别：未分类

时间：2024-07-01 18:17:17

-->

# 当锁优于 MVar：ezyang 的博客

> 来源：[`blog.ezyang.com/2014/01/when-a-lock-is-better-than-an-mvar/`](http://blog.ezyang.com/2014/01/when-a-lock-is-better-than-an-mvar/)

MVars 是一种非常灵活的同步原语，可以用作锁、单位置通道、屏障等，或用于构建更高级别的抽象。就灵活性而言，MVars 是实现运行时系统的首选原语，而不仅仅是实现锁的选择。

然而，最近我在思考[GHC 的 BlockedIndefinitelyOnMVar 异常](http://blog.ezyang.com/2011/07/blockedindefinitelyonmvar/)，我意识到使用锁的本地实现可以允许*完美*的死锁检测，与我们当前针对 MVars 提供的近似检测不同。（我必须强调，然而，在这里，我定义死锁是指一个循环的等待图，而不是“线程无法进一步前进”。）

下面是新原语的行为方式：

+   将会有一个新类型`Lock`，只有一个函数`withLock :: Lock -> IO a -> IO a`。（出于简洁起见，我们不考虑将锁通用化以包含值。）

+   在运行时，锁被表示为两种闭包类型，分别表示锁定和解锁状态。锁定的闭包包含一个等待队列，其中包含等待锁的线程。

+   当线程获取一个空闲锁时，它将锁添加到与线程关联的（GC 的）持有锁集合中。当它释放锁时，锁将从此集合中移除。

+   当线程试图获取一个忙碌的锁时，它会阻塞自己（等待锁），并将自己添加到被锁定闭包的等待队列中。

+   关键是，在闭包被锁定时，对锁的引用被视为*弱指针*。（只有从持有的锁集合中的指针是强的。）直观地说，仅仅因为有锁的指针并不意味着你可以解锁；唯一可以解锁的人是持有锁的线程。

+   如果一个线程试图在一个已经无效的弱指针上获取锁，那么它将会发生死锁。

**定理。** *在等待循环中的任何一组线程是不可达的，如果除了在循环中的锁的等待队列中的指针以外，没有其他指向线程的指针。*

**证明。** 考虑一个在循环中的单个线程：我们展示唯一（强）指向它的指针来自于循环中前一个线程。当线程被阻塞时，它会从运行队列中移除（这算作一个 GC 根）。根据假设，指向线程的唯一指针来自于它所阻塞的锁的等待队列。现在我们考虑指向它所阻塞的锁的指针。由于这个锁正在被使用，指向它的所有指针都是弱的，除了来自于持有锁的线程的指针。但这恰恰是循环中的前一个线程。■

当锁定时进行弱引用解引用的成本，我们现在可以实现完美的死锁检测。死锁将在下次运行垃圾收集时检测到，该收集会检测到线程的死循环。（最坏情况下，这将是下一个主要的 GC。）

为什么这会引起兴趣？毕竟，通常情况下，从死锁中恢复是困难的，因此，虽然准确的死锁报告可能是件好事，但并不是必需的。一个线索来自 Koskinen 和 Herlihy 的论文[Dreadlocks: Efficient Deadlock Detection](http://www.cs.nyu.edu/~ejk/papers/dreadlocks-spaa08.pdf)中的一句话：“一个本质上能够处理可中止锁请求的应用程序……是软件事务内存（STM）。如果你在 STM 事务中，死锁根本不是问题；只需回滚一个事务，打破循环即可。通常情况下，在普通的 STM 使用中不会锁定，但当你使用像事务提升这样的技术时，就可能会发生这种情况（来自同一作者；这两篇论文之间的关系并非巧合！）

*读者的练习，为限制为单一位置通道的 MVar 制定类似的 GC 方案。（提示：将 MVar 分为写入端和读取端。）*

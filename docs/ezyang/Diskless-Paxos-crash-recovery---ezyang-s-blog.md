<!--yml

category: 未分类

date: 2024-07-01 18:17:41

-->

# 无盘 Paxos 崩溃恢复：ezyang 博客

> 来源：[`blog.ezyang.com/2011/08/diskless-paxos-crash-recovery/`](http://blog.ezyang.com/2011/08/diskless-paxos-crash-recovery/)

*这是我上周发送的电子邮件的编辑版本。不幸的是，这需要你熟悉原始 Paxos 正确性证明，所以我甚至没有试图将其扩展为适合普通读者的内容。这个算法可能太简单了，以至于不可能在文献中出现，除非可能是非正式提到的—然而，如果它是错误的，我很想知道，因为实际的代码依赖于它。*

我想描述一个关于 [Paxos](http://en.wikipedia.org/wiki/Paxos_algorithm) 崩溃恢复的算法，该算法不需要持久存储，而是利用同步时钟和基于格子的时期编号。基本思想是将选票/提案号码增加到一个对于崩溃节点不可能做出任何承诺的值。正如在 [Paxos made Live](http://labs.google.com/papers/paxos_made_live.html) 中指出的那样，这种算法在磁盘损坏的情况下非常有用，其中持久存储丢失了。（不幸的是，他们在论文中描述的从此情况恢复的算法是错误的。原因留给读者作为一个练习。）它受到 [Renesse](http://www.cs.cornell.edu/home/rvr/) 关于“基于时期的系统”的评论的启发，以及在 [JPaxos：基于 Paxos 协议的状态机复制](http://infoscience.epfl.ch/record/167765) 中描述的基于时期的崩溃恢复算法。然而，与 [Nuno](http://personnes.epfl.ch/nuno.santos) 的通信中，我发现他们的算法正确性的证明尚未发表，因此我决定自己确信其正确性，并在此过程中发现了一个更简单的版本。也许这个算法已经在社区传闻中存在，如果是这样，那就更好，因为我的主要兴趣是实现。

首先，让我们将提案号码从单一的命名空间值 `n` 扩展为元组 `(e, n)`，其中 `n` 是之前的命名空间提案号码，`e` 是一个时期向量，其长度等于 Paxos 集群中节点的数量，并在其上强制常规的笛卡尔乘积格子结构。

让我们确定在节点崩溃期间我们希望从节点中获得的行为：

**已知未知。** 一个接受者知道一个值 `e*`，对于所有 `e` 满足 `e* ≤ e`（使用格子排序），接受者知道是否已经响应了形式为 `(e, n)` 的准备请求（对所有 `n`）。

也就是说，接受者知道一组提案号码的集合，他保证不会为这些号码做出任何承诺。

我们如何建立这个不变性？我们可以将一个值写入持久存储，并在崩溃后递增它；这种行为通过单调性来确立。事实证明，我们还有其他方便的单调数字来源：同步时钟（在 Paxos 的其他情况下也很有用）具有这种行为。因此，我们不再使用整数向量，而是使用时间戳向量。在崩溃时，进程将其时期设置为零向量，除了其自己的条目，该条目设置为当前时间戳。

在[Paxos 简介](http://academic.research.microsoft.com/Publication/12945610/paxos-made-simple)中，Lamport 介绍了接受者操作的以下不变性：

**P1a.** 只有当接受者未对大于`n`的准备请求作出响应时，接受者才能接受编号为`n`的提议。

我们可以修改这个不变性为以下内容：

**P1b.** 只有当`e* ≤ e`并且该接受者未对具有`n' > n`的准备请求`(_, n')`作出响应时，接受者才能接受编号为`(e, n)`的提议。

注意这个不变性在“强化”了**P1a**，因为接受者在更少的情况下接受提议（即在`e* ≰ e`时拒绝提议）。因此，安全性得到保证，但进展现在是可疑的。

在建立 Paxos 的进展时，我们要求存在一个稳定的领导者，并且该领导者最终选择一个足够“高”的提议号。因此问题是，领导者最终能够选择一个足够“高”的提议号吗？是的，定义这个数为`(lub{e}, max{n} + 1)`。这个时期违反了**已知未知**吗？不是的，因为零向量与系统已经收敛的任何时期都是不可比的，这个节点有单个较晚的时间戳。

因此，对 Paxos 算法的修改如下：

+   扩展选票号以包括时期号；

+   在初始启动时，将`e*`设置为零向量，并在该节点条目中添加当前时间戳；

+   另外，拒绝接受那些时期号不大于`e*`的接受请求；

+   当选择新的提议号来提议时，取所有时期号的最小上界。

一个优化是在非崩溃启动时，将`e*`初始化为零向量；这消除了在准备请求的第一轮中建立时期的需求。从快照克隆状态是一个正交问题，可以使用修复滞后副本的相同机制来解决。我们建议还实现一种优化，即领导者仅向已知良好的法定人数发送接受消息，因此恢复的节点不会立即强制视图更改。

我若不提及此领域的一些先前工作，就会显得不周到。特别是，在[故障检测和一致性在崩溃恢复模型中的应用](http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.17.5958)中，作者们提出了一种卓越的算法，即使在没有稳定存储的情况下，也能处理同时多于大多数节点崩溃的情况（在一些条件下，详见论文）。不幸的是，他们的解决方案比我上面描述的方案要复杂得多，而且我不知道有没有人实现它。此外，处理没有内存的崩溃节点的另一种机制是组成员机制。然而，组成员机制实现起来非常微妙，正确性难以保证。

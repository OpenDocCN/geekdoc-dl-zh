<!--yml

category: 未分类

date: 2024-07-01 18:17:53

-->

# IO 评估 Haskell 堆：ezyang's 博客

> 来源：[`blog.ezyang.com/2011/04/io-evaluates-the-haskell-heap/`](http://blog.ezyang.com/2011/04/io-evaluates-the-haskell-heap/)

在今天的文章中，我们关注的是*你*，在 Haskell 堆中翻找打开一个礼物的人。毕竟，Haskell 堆中的礼物并不会自行打开。

某人必须打开第一个礼物。

如果 Haskell 堆不与外界交互，就不需要打开礼物：因此 IO 函数是打开礼物的函数。它们将打开什么礼物对于许多函数来说并不明显，因此我们将专注于一个特别明显的函数：`evaluate`。这告诉你要...

...打开一个礼物。

如果你得到一个原始值，你就完成了。但当然，你可能会得到一个礼品卡（构造函数）：

你会打开其余的礼物吗？尽管内心深处充满了不满，答案是否定的。`evaluate`只要求你打开一个礼物。如果它已经被打开，那你就无需做任何事情。

> 高级技巧：如果你想评估更多东西，可以制作一个包含一个幽灵的礼物，他将帮你打开那些东西！当涉及到延迟 IO 时，这是一个经常使用的例子：`evaluate (length xs)`，但如果你还不明白，不用太担心：我还没有说过我们如何制作礼物！

即使我们只打开了一个礼物，很多事情可能会发生，正如上篇所述。它可能执行一些 IO...

这是我们在评估过程中直接窥探的窗口：通常情况下运行程序时，我们看不到礼物被打开的过程；但如果我们让幽灵在被扰动时也喊出来，我们就能得到这些信息。事实上，这正是`Debug.Trace`所做的！

还有其他方法可以查看正在进行的评估。一个礼物可能会爆炸：这是爆炸的陷阱礼物，也称为“底部”。

或许爆炸是由`undefined`或`error "Foobar"`引起的。

砰。

* * *

我们将以一个实用的笔记结束。正如我们所提到的，你只有在显式要求从 IO 打开一个礼物时才能确定它已经被打开。否则，幽灵可能会捉弄你。毕竟，你实际上是看不到 Haskell 堆的，所以没有直接的方法可以直接告诉一个礼物是否已经被打开。

如果你不确定一个 thunk 何时被评估，请在其中添加一个跟踪语句。如果幽灵在你背后懒惰，跟踪语句就永远不会出现。

然而，更频繁地，跟踪语句将会出现；它可能会比你预期的晚一些（幽灵可能会懒惰，但他们最终会完成工作）。因此，过早终止你的程序或添加额外的打印语句来划分程序的各个阶段是很有用的。

上次：[在 Haskell 堆上评估](http://blog.ezyang.com/2011/04/evaluation-on-the-haskell-heap/)

下一次：[在 Python 中实现 Haskell 堆，v1](http://blog.ezyang.com/2011/04/implementing-the-haskell-heap-in-python-v1/)

*技术说明。* 与我之前说过的相反，理论上我们可以在堆上自发地评估`thunk`，这种评估方法称为*推测性评估*。有些令人困惑的是，`IO`操作本身也可以是`thunk`：这相当于传递`IO a`的值，而不实际“运行”它们。但因为我不在这里讨论单子，我将简单地忽略包含`IO`操作的存在——它们的工作方式相同，但你必须保持间接层级清晰。当然，无限循环也算作`bottom`，但将其打开一个礼物直到永远的形象，并不像一个爆炸性礼物那样吸引眼球。

这项工作根据[知识共享署名-相同方式共享 3.0 未本地化许可协议](http://creativecommons.org/licenses/by-sa/3.0/)进行许可。

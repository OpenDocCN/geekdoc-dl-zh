<!--yml

category: 未分类

date: 2024-07-01 18:17:38

-->

# Bugs and Battleships：ezyang 的博客

> 来源：[`blog.ezyang.com/2011/12/bugs-and-battleships/`](http://blog.ezyang.com/2011/12/bugs-and-battleships/)

你还记得你的第一个计算机程序吗？当你完成编写它时，你做的第一件事是什么？你进行了最简单的可能测试：你运行了它。

随着程序规模的增加，可能测试的数量也在增加。值得考虑的是我们实际运行了哪些测试：想象一下儿童游戏“战舰”，其中海洋是所有可能程序执行的空间，战舰是你要寻找的 bug，每一颗发射的导弹就是你运行的一个测试（如果测试通过则为白色，失败则为红色）。你没有无限的导弹，所以你必须决定将它们发送到哪里。

关于“你的第一个计算机程序”的情况，答案似乎很明显：只有一种方式来运行程序，只有少数几种测试情况。

但这种幻想很快就会被真实软件的遭遇所打破。即使你的程序没有输入，硬件、操作系统、开发环境和其他环境因素也会立即增加测试空间。添加显式输入和不确定性到应用程序中，你会看到一个游泳池和海洋之间的差异。

我们如何决定测试什么？我们的策略是什么——我们在哪里发送更多导弹，哪里发送更少？不同的测试策略导致在所有可能执行的空间上的不同测试分布。即使我们在编写测试或在整个系统中运行集成测试时可能没有*考虑*测试用例的分布，不同的测试策略也会导致不同的覆盖范围。

例如，你可能决定不进行任何测试，并依赖用户向你报告 bug。结果是，你的应用程序在*经常使用的区域*具有较高的覆盖率，在很少使用的区域覆盖率较低。在某种意义上，当你有一个愿意容忍失败的大用户群体时，这是一种最优策略——尽管任何在不寻常情况下使用软件时遇到 bug 的人可能会持不同意见！

对于回归测试有不同的想法，即你为过去发生过的任何 bug 添加一个自动测试。与将覆盖面集中在经常使用的区域不同，回归测试套件最终会集中在应用程序的“棘手”区域，即过去发现大多数 bug 的区域。这种策略背后的假设是，历史上有 bug 的代码区域未来更可能有 bug。

你甚至可能对应用程序中的 bug 发生位置有一些先验假设；也许你认为应用程序中的边界情况最有可能出 bug。那么你可能会合理地把测试工作集中在这些区域上。

其他测试策略可能专注于测试的分布。当您关注*最坏情况*行为（例如安全漏洞）而不是平均情况行为（普通错误）时，这一点尤为重要。例如，模糊测试涉及随机在测试空间中泼洒，而不考虑使用频率等因素：结果是您在很少使用和没有发现许多错误的区域上获得了更多的分布。

然而，您可能会注意到，虽然模糊测试改变了测试的分布，但它并不提供任何*保证*。为了保证没有任何错误，您必须测试每一个输入，而在现代软件工程实践中，这是不可能的。实际上，有一种非常巧妙的技术叫做*模型检查器*，专门设计了各种技巧以加速进行这种详尽的测试。对于有限的状态空间来说，无论如何都是如此——还有更近期的研究项目（例如 Alloy），可以执行这种详尽的测试，但仅限于一定的深度。

模型检查器在某种意义上是“愚笨的”，因为它们并不真正理解程序试图做什么。我们可以采取的另一种方法是利用我们知道的程序工作方式的事实，以选择一些非常谨慎设计的测试输入，这些输入“泛化”以覆盖整个测试空间。（我们很快会更加精确地阐明这一点。）

然而，上面的图表有点误导：测试用例很少能够如此轻松地泛化。甚至可以说，将特定测试的行为泛化到程序行为的能力，正是区分好程序与坏程序的关键。坏程序充满了许多不同的情况，所有这些情况都必须单独测试才能确保。

说一个测试用例泛化是什么意思？我个人的信念是，被称为相互等效的测试输入空间块对应于程序的单个案例，是更大数学证明的一部分，可以独立进行论证。当您将一个复杂的程序分解为部分以解释其功能时，这些部分应该对应于程序的等效划分。

这种信念的推论是，*好程序易于证明正确*。

这比“运行程序看看是否正常”要复杂得多。但我认为，无论软件工程师是否使用像模型检查器和定理证明器这样的学术工具，对于想要制作正确可靠软件的人来说，这种过渡是必要的。无论如何，最终你仍然需要编写测试用例。但如果你理解构建测试用例背后的分布理论，你将会更加有效。

*附言.* 类型检查与测试之间的关系经常被误解。我认为这张图表很好地总结了它们之间的关系：

类型可以消除某些 bug 区域，但对其他区域无效。依赖类型的理念是增加这些边界，直至覆盖所有空间，即使你只能管理测试空间的子集，其好处也是非常明显的。

这项工作根据[知识共享署名-相同方式共享 3.0 未本地化版本许可协议](http://creativecommons.org/licenses/by-sa/3.0/)进行许可。

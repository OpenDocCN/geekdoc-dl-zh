<!--yml

category: 未分类

日期：2024-07-01 18:18:03

-->

# 我在 Isabelle 中的第一个证明：ezyang’s blog

> 来源：[`blog.ezyang.com/2010/11/my-first-proof-in-isabelle/`](http://blog.ezyang.com/2010/11/my-first-proof-in-isabelle/)

美国和英国学术机构之间的一个显著差异是课外补充学习。在美国，我们有*课后讲习班*，类似额外的讲座，而在英国，他们有*教程*，或者按剑桥的说法称为*辅导*。正如往常一样，它们是一种混合包：一些导师很糟糕，其他人则仅仅称职，还有些则激发并鼓励对课程主题的兴趣，远远超出课程大纲的范围。

尼克·苏尔塔纳（Nik Sultana），我们的*逻辑与证明*监督员，就是这样的人物之一。在我们最后一次辅导中，凭借一时的冲动（我们这些被监督者的怂恿），他建议我们尝试在[Isabelle](http://www.cl.cam.ac.uk/research/hvg/Isabelle/)中证明以下逻辑陈述，这是他一直在进行研究的证明助手。

我首先推导了关于该命题的序言演算证明（留给读者作为练习），然后我找到了 Isabelle，下载了手册，启动了 Proof General，开始了我在 Isabelle 中的第一个证明。

* * *

*语法.* 我遇到的第一个问题是得到一个最小的理论以编译。这是因为 Isabelle 要求你始终有一个 imports 行，所以我提供了`Main`作为一个 import。

然后我尝试证明一个微不足道的理论，A --> A，并因为声明为“by (impI)”而被绊倒，而不是“by (rule impI)”（在这一点上，仍然不清楚‘rule’实际上是做什么的）。

我尝试证明另一个理论，即`conj_rule`，直接参考文档，但是我把 Unicode 转录成 ASCII 时出错了，最终得到了一个与他们所做步骤不符的理论。（这是阅读手册的一个让人恼火的事情，尽管我理解他们为什么这样做。）最终我意识到了问题所在，并决定实际开始证明：

```
lemma "(ALL x. ~ P x --> Q x) & (EX x. ~ Q x) --> (EX x. P x)"

```

我首先尝试了非点记法，但语法检查失败了，所以我为所有绑定变量引入了点。

* * *

*语义.* 这个证明很简单：

```
by blast

```

不过，那是作弊 :-)

在这一点上，我感到很不自在：Isabelle 使用自然演绎系统，而（通过我的学习）我最有经验的是等价推理、序言演算或表演演算（更不用说我已经掌握了序言演算的证明）。事实证明，移除量词后看起来确实像在正常的序言演算中一样，但我还没有意识到这一点。

我摸索着，盲目地应用`allE`、`allI`、`exE`和`exI`，看看它们会做什么。我还没有意识到`rule`、`drule`和`erule`之间的区别，所以偶尔我会应用一个规则，得到大量的子目标展开，然后对自己说：“嗯，这似乎不对啊。”

最后，从通用部分反向阅读，我意识到 `==>` 与 `-->` 有些不同，代表着一种元蕴含，某些规则对其特别对待，所以我将其转换为它：

```
-- "Massage formula"
apply (rule impI)

```

再一次，我试图应用通用规则，通常无法使公式看起来漂亮。然后我更仔细地查看了伊莎贝尔的示例，注意到它们在 `==>` 的左侧使用了 `[| P; Q |]`，而不是 `P & Q`，所以我找到了适当的规则将公式整理成这种形式（分号是序言演算的冒号）。然后我意识到还有这个 `erule` 的东西，虽然我仍然认为当规则末尾有 E 时只需应用它：

```
apply (erule conjE)

```

* * *

*证明。* 每个人都喜欢通过排列来编码，所以我再次通过规则。这一次，`exE` 似乎使公式保持简单，经过几秒钟的思考，也应该是序言演算证明中正确的做法。我也意识到我正在进行反向证明（即，我们将我们的目标分解为子目标），突然手册中的蕴含语句更加清晰了（看右侧，而不是左侧！）：

```
apply (erule exE)

```

接下来的步骤花费了一些时间。我很容易地应用了 `(erule allE)`，这消除了方程右侧的全称量词，但引入了一个新的斯科莱姆函数，这似乎不是我想要的。我也知道理论上我应该能够消除右侧的存在量词，但无法弄清楚应该使用什么规则。尝试使用通常的规则结果很荒谬，尽管我认为在这一点上我已经搞清楚了何时使用各种 `rule` 的变体。最终，我重新阅读了手册中显式替换变量部分，脑补了 `drule_tac` 语法，它奏效了！

```
apply (drule_tac x = "x" in spec)

```

有经验的伊莎贝尔将会意识到我可以消除右侧的存在量词，但因为我已经得出结论这是不可能的，所以我选择了绕道而行。我决定尝试结合一些我的假设来得出一些有用的结论。此时，证明状态如下：

```
!!x. [| ~ Q x; ~ P x -> Q x |] ==> (EX x. P x)

```

我觉得我应该能够在左侧得到 `P x`，然后应用一些存在量词规则，因为真语句 `P x ==> (EX x. P x)`。但是没有一条蕴含规则或假言推理适用得恰当。我还尝试使用反证法交换假设和目标：

```
!!x. [| ~  (EX x. P x); ~ P x -> Q x |] ==> Q x

```

实际上，我希望蕴含物在右侧。然而，存在量词在左侧，所以我本应该能够消除它……但有一个否定，所以规则失败了。

进一步阅读揭示了我可以使用一些特殊的语法将蕴含物放在右侧：

```
!!x. [| ~ Q x; ~ (EX. P x) |] ==> ~ (~ P x -> Q x)

```

但再次，条件使我无法执行我的邪恶计划，破坏推论并在假设中推导出矛盾。

所以我回头去，再玩了一些，最终发现从目标端消除存在量的方法是*引入*它（倒过来！）我还发现`_tac`可以适用于基本上任何规则：

```
apply (rule_tac x = "x" in exI)

```

在这一点上，这是一个简单的命题证明，而我之前对反证法的探索给了我一个做法的想法：

```
apply (erule contrapos_np)
by (drule mp)

```

Sweet。在我完成证明后，我回头去掉了`tacs`，并检查了一下伊莎贝尔是否能够自行统一变量；她可以，但中间的证明目标看起来更丑，所以我又把它们加了回去。这样就完成了我在伊莎贝尔中的第一个证明。这并不算多，但其中的漫步足以让我在完成时感到相当满意。以下是整个过程：

```
theory LogicAndProof
imports Main
begin

lemma "(ALL x. ~ P x --> Q x) & (EX x. ~ Q x) --> (EX x. P x)"
-- "Massage the formula into a nicer form to apply deduction rules"
apply (rule impI)
apply (erule conjE)
-- "Start introducing the safe quantifiers"
apply (erule exE)
apply (drule_tac x = "x" in spec)
apply (rule_tac x =" x" in exI)
apply (erule contrapos_np)
by (drule mp)

```

<!--yml

category: 未分类

date: 2024-07-01 18:18:06

-->

# 在 Haskell 中快速原型化脚本：ezyang 的博客

> 来源：[`blog.ezyang.com/2010/10/rapid-prototyping-in-haskell/`](http://blog.ezyang.com/2010/10/rapid-prototyping-in-haskell/)

我在周末里玩得很痛快，用 Haskell 写了一个叫做 [MMR Hammer](http://github.com/ezyang/mmr-hammer) 的小工具。 我不会跟你讲 Fedora Directory Server 的多主复制的细节，相反，我想谈谈在 Haskell 中快速原型化脚本的经验—这些程序的特点是计算量少而 IO 多。 通过这个脚本作为案例研究，我将描述我如何解决问题，什么容易做到，什么需要花点儿力气。 特别是，我的主要论点是：

1.  在高度专业化的脚本中，你可以不指定顶层类型签名，

1.  IO 单子是你唯一需要的单子，最后

1.  你 *可以* 也 *应该* 在 Haskell 中编写一些 hackish 代码，语言会施加适量的严格性，以确保你稍后可以整理它。

我希望说服你，Haskell 可以成为快速原型化脚本的一种优秀语言。

*快速原型化脚本的特点是什么？* 快速原型化有两个主要目标：让它 *工作*，并让它快速 *工作*。 有许多因素汇集成这两个基本目标：

+   你的需求立即显而易见—问题在于将你的想法转化为可工作的代码。（你可能会后来决定你的需求是错误的。）

+   你有一个现有的 API，你希望使用它，这让你可以说“我想将 X 属性设置为 Y”而不是说“我将以这种特定格式的二进制消息和这些数据通过 TCP 传输”。 这应该与你对你想做的事情的构思相匹配。

+   你将通过反复执行你关心的代码路径来进行手动测试。 你没有积极开发的代码通常不会被运行（如果你有很多辅助函数可能会编译失败）。 此外，运行代码应该快速且不涉及长时间的编译过程。

+   你想要避免剃牛毛：解决无关的问题会消耗时间，阻止你的软件正常工作；最好现在就解决问题。

+   你的代码专门为你的特定用例进行了优化：这使得它更容易使用，并提供了一个未来广泛适用时需要支持的具体示例（如果你决定将你的代码更广泛地应用，这似乎会发生）。

+   你并没有做很多计算昂贵的工作，但你的逻辑比在 shell 脚本中维护起来更复杂。

*一个能够实现快速原型化的语言是什么样子？*

+   它应该简洁，并且至少不要让你重复自己。

+   它应该“随带电池”，并至少有你想要使用的重要 API。

+   它应该是解释性的。

+   它应该被充分利用；也就是说，你试图做的事情应该已经存在于其他人已经用该语言做过的事情的并集中。这意味着你在没有人运行的代码中遇到奇怪的错误条件的可能性较小。

+   它应该有一个快速的写-测试-调试循环，至少对于小程序来说是这样的。

+   编译器不应该妨碍你。

*Haskell 的一般原型制作。* 如果我们看看上面的列表，Haskell 有几个方面值得推荐。GHC 有一个 `runghc` 命令，允许你解释你的脚本，这意味着可以快速进行原型制作。函数式编程鼓励高度的代码重用，并且在你熟悉使用高阶函数时可以非常简洁。而且，它正在逐渐增加一个相当庞大的工具集。在 LDAP MMR 的情况下，我需要一个 OpenLDAP 库的绑定，[John Goerzen](http://hackage.haskell.org/package/LDAP) 已经写过了。一个很好的开始。

*编译器不应该妨碍你。* 这对于任何初学者来说可能是 Haskell 最明显的问题：他们试图编写一些普通的程序，但编译器却开始用复杂的类型错误来“咩咩”地指责他们，而不是通常的语法错误或运行时错误。随着他们对 Haskell 的熟悉程度的提高，他们对 Haskell 类型系统的心理模型也会改进，并且他们修复类型错误的能力也会提高。

百万美元的问题是，你必须对 Haskell 有多了解才能快速解决类型错误？我认为，在 Haskell 的快速原型制作中，*并不需要太多！*

一个简化的因素是你写的函数通常*不*是多态的。在 MMR Hammer 中的 73 个完全实现的函数中，只有六个具有推断的非平凡多态类型签名，其中除了一个之外都只在单一类型上下文中使用。

对于这些签名，`a` 总是 `String`：

```
Inferred type: lookupKey :: forall a.
                            [Char] -> [([Char], [a])] -> [a]

Inferred type: lookupKey1 :: forall a.
                             [Char] -> [([Char], [a])] -> Maybe a

```

`m` 总是 `IO`，`t` 总是 `[String]`，但它是多态的，因为它在函数体中没有被使用：

```
Inferred type: mungeAgreement :: forall (m :: * -> *).
                                 (Monad m) =>
                                 LDAPEntry -> m LDAPEntry

Inferred type: replicaConfigPredicate :: forall t (m :: * -> *).
                                         (Monad m) =>
                                         ([Char], t) -> m Bool

```

`a` 在这里总是 `(String, String, String)`；然而，这个函数是为数不多的真正通用的函数之一（它旨在实现 `IO` 的 `msum`）：

```
Inferred type: tryAll :: forall a. [IO a] -> IO a

```

最后，我们的另一个真正通用的函数，一个方便的调试函数：

```
Inferred type: debugIOVal :: forall b. [Char] -> IO b -> IO b

```

我认为对于高度特定的原型代码，GHC 通常会推断出相当单态的类型，因此你不需要添加很多显式类型签名来获得良好的错误提示。你可能会注意到 MMR Hammer 几乎没有任何显式的类型签名——我认为对于单态代码来说，这是可以接受的！此外，这意味着你只需要知道如何*使用*多态函数，而不需要知道如何编写它们。（更不用说更高级的类型技巧了！）

*单子，单子，单子。* 我怀疑脚本的一个高度简化的假设是避免使用除了 IO 之外的任何单子。例如，下面的代码*可能*已经使用了 Reader 变换器在 IO 的基础上实现了：

```
ldapAddEntry ldap (LDAPEntry dn attrs) = ...
ldapDeleteEntry ldap (LDAPEntry dn _ ) = ...
printAgreements ldap = ...
suspendAgreements ldap statefile = ...
restoreAgreements ldap statefile = ...
reinitAgreements ldap statefile = ...

```

但是只有一个参数传递，这在任何调用 API 时基本上都是必需的（所以我可能会做一点 `ask` 调用），所以使用读取器转换器可能会增加代码量，因为我的所有 LDAP 代码都需要用 `liftIO` 提升。

更少的单子也意味着更少的担忧：你不必担心混淆单子，你可以自由地使用 `error` 作为在关键错误时中止的简写。在 IO 中，这些会被转换为异常，异常会按照通常的方式传播——因为它们是字符串，你不能编写非常健壮的错误处理代码，但嘿，原型通常不需要错误处理。特别是，原型容易出错是好事：宁愿出现错误而不是执行可能正确但可能导致完全无意义的操作。

悬挂的 lambda 风格也使得编写使用括号函数的代码非常愉快。以下是一些示例：

```
withFile statefile WriteMode $ \h ->
    hPutStr h (serializeEntries replicas)

forM_ conflicts $ \(LDAPEntry dn attrs) ->
    putStrLn dn

```

看，没有括号！

*收获利益。* 有时候，你可能会出于纯粹的教育目的而尝试用另一种语言编写程序。但除此之外，如果你掌握一种语言，并且它对你来说很有效，除非有强有力的理由，否则你不会真的想去改变。以下是用 Haskell 编写代码的强有力理由：

+   当你与外部世界互动时，你会很快发现自己需要某种形式的并发执行：也许你想提交一个查询，但如果十秒钟内没有返回就超时，或者你想要同时进行几个 HTTP 请求，或者你想要监视一个条件直到它被满足然后做其他事情。Haskell 让这类事情变得非常容易，而这在同时也是可以解释的语言中极为罕见的。

+   因为你没有自动测试，一旦你编写了一些代码并手动验证它工作正常，你希望它保持工作状态，即使你在程序的其他部分工作时也是如此。如果你构建了需要演变的辅助函数：如果你更改了一个辅助函数的 API 并忘记更新所有调用站点，你的代码将会编译，但当你回去尝试运行一个旧的代码路径时，你会发现你有一堆微不足道的错误需要修复。静态类型会让这些问题消失。严肃点。

+   Haskell 提供了非常非常便宜的抽象。在 Python 中，你可能会因为更一般的版本需要高阶函数并且看起来很丑，而不得不完整地编写出来，但在 Haskell 中，这些东西非常自然和简单，你真的不需要说太多就能做很多事情。我的一个朋友曾经抱怨说 Haskell 鼓励你花费太多时间在抽象上；这是事实，但我也相信一旦你深入到 Oleg 的领域中一次，你以后会更好地感知何时以及何时不适合使用抽象。

+   使用 Maybe 进行严格的 NULL 处理会让你更早地考虑到错误条件。很多时候，你会想中止，因为你不想去处理那个错误条件，但有时你会想要更优雅地处理事情，而显式的类型会始终提醒你何时可能做到这一点：

    ```
    case mhost of
        (Just host) -> do
            let status = maybe "no status found" id mstatus
            printf ("%-" ++ show width ++ "s : %s\n") host status
        _ -> warnIO ("Malformed replication agreement at " ++ dn)

    ```

+   在完全随意的方式下进行输入的分割和切割是可行且简洁的：

    ```
    let section = takeWhile (not . isPrefixOf "profile") . tail
                . dropWhile (/= "profile default") $ contents
        getField name = let prefix = name ++ " "
                        in evaluate . fromJust . stripPrefix prefix
                                    . fromJust . find (isPrefixOf prefix)
                                    $ section

    ```

    但同时，将这段代码换成一个真正的解析库并不需要太多额外的代码行数。这是 Haskell 中更一般模式的一个实例，即从脆弱的妥协到健壮的代码转换非常容易（另见，静态类型系统。）

*一些缺点。* 给我的脚本添加选项解析实在是令人烦恼，看了一会儿 cmdargs 和 cmdlib 后，我决定用 getopt 自己写，结果在我的脚本中变成了一个相当不小的代码块。我不太确定这里出了什么问题，但其中一部分问题是我对命令行 API 的非常特殊的口味（毕竟基于 Git），而且不明显如何使用更高级别的库来达到我想要的效果。也许最明显的是，大多数主要的 Haskell 命令行应用程序也都自己编写了命令解析器。更多内容请看另一篇文章。

使用 LDAP 也是一次有趣的练习：这是一个相当高质量的库，可以工作，但它并不全面（最终我提交了一个支持 `ldap_initialize` 的补丁），也没有经过充分测试（它对 OpenLDAP 和 Fedora DS 之间长期存在的 bug 没有解决方案——更多内容请看另一篇文章。）这是一个随时间而改善的事情，但在那之前期望与上游密切合作，特别是对于专业化的库。

<!--yml

类别：未分类

日期：2024-07-01 18:18:27

-->

# 类型操作：*行业诀窍*：ezyang 的博客

> 来源：[`blog.ezyang.com/2010/02/type-manipulation-tricks-of-the-trade/`](http://blog.ezyang.com/2010/02/type-manipulation-tricks-of-the-trade/)

我在这里介绍了一些传统的典故，对于那些擅长 Haskell 的人来说，这些技巧在分析类型看似毫无意义的代码时非常有用。我们将建立实用的技巧来推断类型，以便能够自己推导出 `fmap fmap fmap` 的类型。请注意，你*可以*只是问 GHCI 它的类型，但那会破坏乐趣！（更严肃地说，通过手动解决问题集中的例子，就像一个良好的问题集一样，有助于培养对可能发生的事情的直觉。）

*柯里化与类型。* 三种具有表面相似性的类型签名分别是 `a -> b -> c`，`(a -> b) -> c` 和 `a -> (b -> c)`。如果你对 Haskell 的自动柯里化没有直观的感受，很容易混淆这三种类型。在这种特定情况下，`a -> b -> c` 可以理解为“接受两个参数 `a` 和 `b` 并返回 `c`”，等价于 `a -> (b -> c)`，可以理解为“接受 `a` 并返回一个接受 `b` 并返回 `c` 的函数”。这些与 `(a -> b) -> c` 是不同的，它表示“接受一个 `a -> b` 的函数并返回 `c`”。在这些情况下，你可以应用一个视觉规则：类型签名右侧与括号对齐的括号可以自由添加或移除，而其他位置的括号则不能。

*高阶函数。* 如果我将一个 `Int` 传递给 `id :: a -> a`，很显然 `id` 的类型是 `Int -> Int`。如果我将一个函数 `a -> a` 传递给 `id :: a -> a`，那么 `id` 的类型变成了 `(a -> a) -> a -> a`。就我个人而言，我觉得类型参数的重载有点令人困惑，所以如果我有一堆函数，我试图推导它们的类型，我会给它们所有人不同的名称。由于 `id id` 有点微不足道，我们将考虑一些更恶劣的东西：`(.) (.)`。回想一下 `(.) :: (b -> c) -> (a -> b) -> a -> c`。我们实际上不会使用这些字母进行操作：因为我们的表达式有两个 `(.)` 的实例，我们将第一个命名为 `a`，第二个命名为 `b`，并从一到三编号。然后：

```
(.) :: (a2 -> a3) -> (a1 -> a2) -> a1 -> a3
(.) :: (b2 -> b3) -> (b1 -> b2) -> b1 -> b3

```

稍微不那么美观，但我们没有更多的冲突类型了。下一步是识别类型变量中存在的等价性，并消除冗余。因为我们将第二个 `(.)` 作为第一个 `(.)` 的参数传递：

```
(a2 -> a3) == (b2 -> b3) -> (b1 -> b2) -> b1 -> b3

```

至于你可能会说，“这些函数签名看起来一点都不像！”这将引导我们到下一个要点：

*柯里化和类型替换.* 如果你的函数类型是*n*-元的，而你想要匹配的类型是*m*-元的，请柯里化你的函数使其成为*m*-元的！因此，如果你有`a -> b -> c`，而你想把它当作`d -> e`来传递，那么实际上你有`a -> (b -> c)`，因此`d == a`且`e == (b -> c)`。如果情况反过来，`d -> e`实际上被限制为`d -> (e1 -> e2)`，其中`e == (e1 -> e2)`且显然的相等性成立。

回到我们的原始例子，第二个`(.)`会被分组如下：

```
(.) :: (b2 -> b3) -> ((b1 -> b2) -> b1 -> b3)

```

并且我们得到了类型相等性：

```
a2 == (b2 -> b3)
a3 == (b1 -> b2) -> b1 -> b3

```

现在，让我们将这些值替换为第一个`(.)`：

```
(.) :: ((b2 -> b3) -> (b1 -> b2) -> b1 -> b3) ->
       (a1 -> b2 -> b3) -> a1 -> (b1 -> b2) -> b1 -> b3

```

并丢弃第一个参数，因为它已经被应用了：

```
(.) (.) :: (a1 -> b2 -> b3) -> a1 -> (b1 -> b2) -> b1 -> b3

```

也许你会想知道那个庞大的类型签名是干什么用的...

*解释类型签名.* 多态类型的一个很棒的特性是，几乎没有非病理行为可以被指定：因为类型是完全多态的，我们实际上不能把手伸进箱子里并利用它实际上是一个整数的事实。这一特性使得像[Djinn](http://lambda-the-ultimate.org/node/1178)这样的程序能够自动推导函数的内容，只要稍加练习，你也能够理解。

逆向思维：我们首先看一下`b3`。我们的函数没有办法神奇地生成一个类型为`b3`的值（不包括`undefined`或底部，这被认为是病态的），因此我们的脚本中必须有其他东西来生成它。果不其然，它就是第一个参数，但我们需要先传递`a1`和`b2`：

```
(.) (.) w x y z = w undefined undefined

```

我们依次重复这些类型的过程：`a1`在哪里指定？好吧，我们把它作为第二个参数传递进去。`b2`在哪里指定？好吧，我们有另一个函数`y :: b1 -> b2`，但我们需要一个`b1`，它是`z`。太棒了，我们现在有了一个完整的实现：

```
(.) (.) w x y z = w x (y z)

```

*点无关风格作为操作符组合.* 所以，我们现在知道`(.) (.)`做什么了，但我们确实没有一个好的理由为什么会这样。（通过理由，我指的是，看看`(.) (.)`，将函数组合看作面值，并意识到，“哦，是的，它应该这样做。”）因此，我们真正想要关注的是`(.)`的语义，即函数组合，以及我们是如何柯里化它的。可能有一种思路是：

1.  函数组合被定义为`(f . g) x = f (g x)`。

1.  我们部分应用了组合，所以实际上我们有`(f.) g x`，但是缺少`g`。（如果`(f.)`看起来对你来说有点奇怪，可以将它与`(2+)`比较，后者是部分应用的加法。注意加法是可交换的，所以你更有可能看到`(+2)`，当应用时变成`(x+2)`。）

1.  `f`实际上是另一个组合运算符。由于函数组合是单参数导向的，我们希望专注于`(.)`的柯里化版本，它接受一个函数并返回一个函数（1），后者接受另一个函数（2）和一个值，并返回第一个函数应用于第二个函数应用于该值的结果。

1.  读出参数。由于`(f.)`在外面，第一个参数完成了柯里化。接下来的参数是实际将通过第一个参数传递的内容，而其结果将通过`f`传递。该返回值是另一个函数，但是（在之前的讨论除外）我们还没有弄清楚那可能是什么。尽管如此，我们已经弄清楚了前两个参数可能是什么样子。

如果我们现在作弊并查看类型签名，我们可以看到我们的假设得到了验证：

```
(.) (.) :: (a1 -> b2 -> b3) -> a1 -> (b1 -> b2) -> b1 -> b3

```

第一个参数`g :: a1 -> b2 -> b3`完成了柯里化，然后下一个参数直接传递给它，因此它必须是`a1`。得到的值`b2 -> b3`传递给下一个组合运算符（注意它不是单一变量，因为下一个组合强制它是一个一元函数），现在等待另一个函数来完成柯里化，这就是下一个参数`b1 -> b2`（即`b1 -> b2 -> b3`）。然后只需提供剩余的参数即可。

我发现将函数视为部分应用并等待“完成”可以更深入地直观理解复杂的高阶函数链可能会做什么。

*把这些放在一起。* 现在是时候为`fmap fmap fmap`确定类型了。我们首先写出每个`fmap`的类型：

```
fmap :: (Functor f) => (a1 -> a2) -> f a1 -> f a2
fmap :: (Functor g) => (b1 -> b2) -> g b1 -> g b2
fmap :: (Functor h) => (c1 -> c2) -> h c1 -> h c2

```

进行应用后我们看到：

```
(a1 -> a2) == (b1 -> b2) -> g b1 -> g b2
f a1 == (c1 -> c2) -> h c1 -> h c2

```

幸运的是，我们有足够的参数来填充第一个`fmap`，因此复杂度减少了一层。我们还可以进一步分解这些：

```
-- from the first argument
a1 == b1 -> b2
a2 == g b1 -> g b2
-- from the second argument
a1 == h c1 -> h c2
f == (->) (c1 -> c2)

```

最后一个等式源于这样一个事实，即对于`(c1 -> c2) -> h c1 -> h c2`，只有一个合理的函子实例；即函数的函子，即读者单子，以`(c1 -> c2)`作为其“读入”。

我们可以进行更多的简化：

```
h c1 -> h c2 == b1 -> b2
b1 == h c1
b2 == h c2

```

把所有东西代入，现在我们看到：

```
fmap fmap fmap :: (Functor g, Functor h) =>
   (c1 -> c2) -> g (h c1) -> g (h c2)

```

解释这些类型我们意识到，`fmap fmap fmap`将一个函数`c1 -> c2`提升了两次到两个函子。所以我们可以运行`fmap fmap fmap (+2) [Just 3]`并得到`[Just 5]`（利用外部列表和内部 maybe 的函子实例）。

我们还注意到`f`函子消失了；这是因为它被迫到了一个特定的形式，所以实际上`fmap fmap fmap == fmap . fmap`。这使得我们更清楚我们正在进行双重提升：函数被`fmap`一次，然后结果再次被`fmap`。

我们甚至可以利用这个结果来弄清楚`(.) (.) (.)`（或`(.) . (.)`）可能会做什么；在函数中 `fmap = (.)`，所以通过第一个 `fmap` 将一个普通函数提升到一个读取器上下文中，通过第二个 `fmap` 又提升到另一个读取器上下文中。因此，我们期望`(.) . (.) :: (a -> b) -> (r2 -> r1 -> a) -> (r2 -> r1 -> b)`（记住，如果`f = (->) r`，那么`f a` 变成 `r -> a`），而事实上确实如此。复合函数与复合函数组合后，只是一个可以将二元函数作为其第二个参数并“做正确事情”的复合函数而已！

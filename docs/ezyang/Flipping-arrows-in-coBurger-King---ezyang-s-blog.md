<!--yml

category: 未分类

date: 2024-07-01 18:18:14

-->

# 在 coBurger King 中翻转箭头：ezyang 的博客

> 来源：[`blog.ezyang.com/2010/07/flipping-arrows-in-coburger-king/`](http://blog.ezyang.com/2010/07/flipping-arrows-in-coburger-king/)

*为工作中的 Haskell 程序员提供的范畴论速成课程。*

在讨论对偶数据结构（最常见的是 co-monad）时经常出现的一个问题是：“co- 是什么意思？”范畴论的口气答案是：“因为你翻转了箭头。”这令人困惑，因为如果你看一看 monad 和 co-monad 类型类的一个变体：

```
class Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  return :: a -> m a

class Comonad w where
  (=>>) :: w a -> (w a -> b) -> w b
  extract :: w a -> a

```

这里有很多“箭头”，只有少数箭头被翻转（具体来说，是`>>=`和`=>>`函数的第二个参数内的箭头，以及 return/extract 中的箭头）。本文将准确解释“翻转箭头”的含义和使用“对偶范畴”，即使你对范畴论一窍不通也不例外。

*符号.* 本文中将会有几个图表。你可以把任何节点（又名对象）看作是 Haskell 类型，把任何实线箭头（又名态射）看作是连接这两种类型的 Haskell 函数。（不同的概念将用不同的颜色箭头来区分。）所以如果我有`f :: Int -> Bool`，我会这样画出来：

*Functors.* Functor 类型类对于工作中的 Haskell 程序员来说并不陌生：

```
class Functor t where
  fmap :: (a -> b) -> (t a -> t b)

```

虽然类型类似乎暗示了 Functor 实例的只有一个部分，即`fmap`的实现，但还有另一个几乎微不足道的部分：`t`现在是一个 kind 为`* -> *`的类型函数：它接受一个类型（`a`）并输出一个新的类型（无聊地命名为`t a`）。因此，我们可以用这个图表示它：

箭头以不同的颜色标注是有充分理由的：它们指示完全不同的东西（并且碰巧出现在同一个图表中）。红色箭头表示一个具体的函数`a -> b`（`fmap`的第一个参数），而虚线蓝色箭头并不是声称存在一个函数`a -> t a`：它只是指示 functor 如何从一个类型映射到另一个类型。它可能是一个没有合法值的类型！我们也可以假设该类型的一个函数的存在；在这种情况下，我们将有一个 pointed functor：

```
class Functor f => Pointed f where
  pure :: a -> f a -- aka return

```

但是对于我们的目的来说，这样一个函数（或者说是吗？）在我们达到 monads 之前并不是很有趣。

你可能听说过 Functor 定律，这是所有 Functor 都应满足的一个等式。在这里，它以文本形式出现：

```
fmap (g . f) == fmap g . fmap f

```

并且以下是以图形方式表示：

你可以将这个图想象成一个巨大的`if..then`语句：如果存在`f`、`g`和`g . f`，那么`fmap f`、`fmap g`和`fmap (g . f)`也存在（只需对它们应用`fmap`！），并且它们恰好以相同的方式组合。

事实上，如果我们有`f :: a -> b`和`g :: b -> c`，则`g . f`也必然存在，因此我们实际上不需要绘制箭头。这是函数组合的一个如此隐含的概念，所以我们会花一点时间问一下：为什么会这样？

原来当我画红色箭头的图表时，我在画数学家称为带有对象和箭头的*范畴*。最近几个图表都是在所谓的范畴 Hask 中绘制的，该范畴的对象是 Haskell 类型，箭头是 Haskell 函数。范畴的定义内置了箭头的组合和身份：

```
class Category (~>) where
  (.) :: (b ~> c) -> (a ~> b) -> (a ~> c)
  id :: a ~> a

```

（你可以在头脑中将`~>`与`->`替换为 Hask），并且有使箭头组合成为可结合的箭头的法则。最相关的是，当你谈论对偶范畴时，范畴箭头恰好是你翻转的箭头。

“太棒了！”你说，“这意味着我们完成了吗？”不幸的是，还没有。虽然余单子是对偶（或双重）范畴的单子，但它并不是范畴`Hask.`（这不是你要找的范畴！）尽管如此，我们花了这么多时间在`Hask`中舒适地绘制图表，如果不好好利用一下就太可惜了。因此，我们将看到 Hask 的对偶范畴的一个例子。

*逆变函子。* 你可能听说过`fmap`被描述为将函数“提升”到函子上下文的函数：这个“函子上下文”实际上只是另一个范畴。（要真正数学地证明这一点，我们需要证明函子定律足以保留范畴定律。）对于普通函子来说，这个范畴就是 Hask（实际上是它的子范畴，因为只有类型`t _`符合对象的条件）。对于逆变函子来说，这个范畴是 Hask^op。

在 Hask 中的任何函数`f :: a -> b`都会成为逆变函子中的函数`contramap f :: f b -> f a`：

```
class ContraFunctor t where
  contramap :: (a -> b) -> t b -> t a

```

这里是对应的图表：

请注意，我们将图表分成了两部分：一部分在 Hask 中，另一部分在 Hask^op 中，注意从一个范畴到另一个范畴的函数箭头（红色）翻转，而函子箭头（蓝色）则没有翻转。`t a`仍然是一个逆变函子值。

你可能会想，头疼不已地想知道：我们是否可以使用`contramap`的任何实例？事实上，有一个非常简单的例子直接来自我们的图表：

```
newtype ContraF a b = ContraF (b -> a)
instance ContraFunctor (ContraF a) where
  contramap g (ContraF f) = ContraF (f . g)

```

对于本文其余部分来说，理解这个实例并不太重要，但感兴趣的读者应该将其与普通函数的函子进行比较。除了新类型的包装和解包之外，只有一个变化。

*自然变换。* 我要提前给出结论：在余单子的情况下，你要找的箭头是自然变换。什么是自然变换？什么样的范畴以自然变换为箭头？在 Haskell 中，自然变换大致上是多态函数：它们是在函子上定义的映射。我们将用灰色表示它们，并且引入一些新的符号，因为我们将处理多个函子：下标表示类型：`fmap_t`是`fmap :: (a -> b) -> t a -> t b)`，而`η_a`是`η :: t a -> s a`。

让我们回顾一下围绕的三种箭头类型。红色箭头是函数，它们是 Hask 范畴中的态射。蓝色箭头指示了类型之间的函子映射；它们还作用于函数以生成更多函数（同样在 Hask 范畴中：这使它们成为*自函子*）。灰色箭头同样是函数，因此它们也可以被视为 Hask 范畴中的态射，但是在从一个函子到另一个函子的所有类型（对象）之间，灰色箭头的集合共同形成了自然变换（图表中描绘了自然变换的两个*分量*）。单个蓝色箭头*不是*函子；单个灰色箭头*不是*自然变换。相反，适当类型的集合才是函子和自然变换。

因为`f`似乎在图表中杂乱无章，我们可以轻松地省略它：

*Monad.* 这是类型类，为了提醒你：

```
class Monad m where
  (>>=) :: m a -> (a -> m b) -> m b
  return :: a -> m a

```

你可能听说过一种定义**Monad**类型类的另一种方法：

```
class Functor m => Monad m where
  join :: m (m a) -> m a
  return :: a -> m a

```

其中：

```
m >>= f = join (fmap f m)
join m = m >>= id

```

`join`更深入地扎根于范畴论（事实上，它定义了使 monad 成为 monoid 的臭名昭著的二元运算的自然变换），你应该确信`join`或`>>=`都能胜任。

假设我们对我们正在处理的 monad 一无所知，只知道它是一个 monad。我们可能会看到什么类型？

趣味的是，我这里将箭头标成了自然变换，而不是我们在 Hask 中为不显著函数所做的红色标记。但是，函子在哪里？`m a`很简单：任何 Monad 也都是函子的有效实例。`a`看起来像一个普通值，但也可以视为`Identity a`，即`a`在恒等函子中的形式：

```
newtype Identity a = Identity a
instance Functor Identity where
  fmap f (Identity x) = Identity (f x)

```

而 `Monad m => m (m a)` 只是一个函子两层深：

```
fmap2 f m = fmap (fmap f) m

```

或者，以无参数风格：

```
fmap2 = fmap . fmap

```

（每个 fmap 将函数嵌入到更深的函子中。）我们可以精确地表示这些函子与类似以下内容组合的事实（抄袭自 [sigfpe](http://blog.sigfpe.com/2008/11/from-monoids-to-monads.html)）：

```
type (f :<*> g) x = f (g x)

```

在这种情况下 `m :<*> m` 是一个函子。

尽管这些图表直接源自 monad 的定义，但也有重要的 monad 定律，我们也可以为其绘制图表。我将只画带有 `f` 的 monad 恒等律：

`return_a`表示`return :: a -> m a`，而`join_a`表示`join :: m (m a) -> m a`。这里是其余的部分，去除了`f`：

你可以将浅蓝色文字解释为“新鲜”—它是自然变换创建（或压缩）的新“层”。第一个图表示恒等律（传统上为`return x >>= f == f x`和`f >>= return == f`）；第二个表示结合律（传统上为`(m >>= f) >>= g == m >>= (\x -> f x >>= g)`）。这些图表等同于以下代码：

```
join . return == id == join . fmap return
join . join == join . fmap join

```

*余单子。* 单子属于自函子 `Hask -> Hask` 的范畴。自函子的范畴以自函子为对象，并（毫不奇怪地）以自然变换为箭头。因此，当我们制作余单子时，我们翻转自然变换。有两种：join 和 return。

这是类型类：

```
class Functor w => Comonad w where
  cojoin :: w a -> w (w a)
  coreturn :: w a -> a

```

它们分别已重命名为`duplicate`和`extract`。

我们还可以翻转自然变换箭头来得到我们的余单子法则：

```
extract . duplicate == id == duplicate . extract
duplicate . duplicate == fmap duplicate . duplicate

```

*下一次。* 尽管从联结和核返推导出`<<=`是完全合理的，但一些读者可能会感到被愚弄，因为我实际上从未讨论过 Haskell 程序员经常处理的单子功能：我只是改变了定义，直到哪些箭头翻转为明显为止。因此，希望在未来某个时候，我能为 Kleisli 箭头绘制一些图表，并展示其含义：特别是为什么`>=>`和`<=<`被称为 Kleisli 组合。

*致歉。* 早晨三点，我竟然遗漏了所有正式定义和证明！对此我是个非常糟糕的数学家。希望在阅读完这篇文章后，你能去查阅每个主题的维基百科文章，并理解它们的描述！

*附言。* 你可能会对这篇关于在更简单环境中的对偶性的[后续文章](http://blog.ezyang.com/2012/10/duality-for-haskellers/)感兴趣。

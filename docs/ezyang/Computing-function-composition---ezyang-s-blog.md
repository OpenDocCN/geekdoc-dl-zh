<!--yml

category: 未分类

date: 2024-07-01 18:17:47

-->

# 计算函数组合：ezyang 的博客

> 来源：[`blog.ezyang.com/2011/05/computing-function-composition/`](http://blog.ezyang.com/2011/05/computing-function-composition/)

这是我在[Thunk 泄漏解剖](http://blog.ezyang.com/2011/05/anatomy-of-a-thunk-leak/)中的第二个例子的附录，其中我想提出另一个解决空间泄漏的方案，涉及计算所有这些 thunk 的组合。这个解决方案特别显著，因为它保留了原始函数的指示，即 `f l (undefined, undefined) = (undefined, undefined)`。这应该是令人惊讶的，因为我声称 GHC 不可能通过更急切地评估某些 thunk 来优化具有这种指示的函数以消除空间泄漏。这并不矛盾：我们想在这里应用的优化是部分评估的一种。不理解？别担心，一个具体的例子即将来临。

正如 Heinrich Apfelmus 指出的那样，空间泄漏可以被视为一个大的表达式图，尚未折叠为单个值：`1 + (1 + (1 + (1 + (1 + (1 + ...)))))`。我们可以将这个图像化为函数连续迭代构建的过程：

引入严格性（而改变函数的指示）的要点在于我们持续地（评估）树的折叠。

但请注意红色高亮显示的值：在进行任何计算之前，我们必须知道这个值是什么。但是如果这个值是未知的（或者在我们的情况下，如果我们在形成这个图时不想评估它），我们的策略实际上不起作用。我们无法折叠整个树。然而，（这是关键），因为加法是结合的，我们可以旋转树，然后评估（现在是左侧的）子树。

实际上，所有的 thunk 都已经合并在一起：而不是 `1 + 1 + 1 + X`，现在我们有了 `3 + X`。简单！这里是实现：

```
f l (x0, x1) = go l (0, 0)
    where go [] (!c0, !c1) = (c0 + x0, c1 + x1)
          go (x:xs) !c     = go xs (tick x c)

tick x (!c0, !c1) | even x    = (c0, c1 + 1)
                  | otherwise = (c0 + 1, c1)

```

`go` 本质上是 `f` 的严格版本，但在迭代结束时返回一个带有两个 thunk 的对：`c0 + x0` 和 `c1 + x1`，其中 `c0` 和 `c1` 都已完全评估。

这是我们正在做事情的另一种思考方式：

如果能够自动完成这个过程将会很酷，并且在其他领域也非常适用。结合结合性函数在[并行化时是一种宝贵的资源](http://blog.ezyang.com/2010/04/creative-catamorphisms/)。

<!--yml

category: 未分类

date: 2024-07-01 18:17:42

-->

# 并行化以堵住空间泄漏：ezyang 的博客

> 来源：[`blog.ezyang.com/2011/07/parallelism-to-plug-space-leaks/`](http://blog.ezyang.com/2011/07/parallelism-to-plug-space-leaks/)

创造一个组合器将两个折叠操作合并成单次输入列表操作的折叠，并不是太困难（请滚动至“非语句”）。如果你的输入列表很大，这一点非常重要，因为分开折叠可能导致空间泄漏，正如著名的“平均”空间泄漏所示：

```
import Data.List
big = [1..10000000]
sum' = foldl' (+) 0
average xs = fromIntegral (sum' xs) / fromIntegral (length xs)
main = print (average big)

```

（我重新定义了 `sum`，以免栈溢出。）我曾认为合并折叠函数非常模块化，因为它们具有相当规范的接口，可以互相组合，并且真正代表了什么时候可以消除这种空间泄漏的核心概念：显然，如果你有两个需要对列表元素进行随机访问的函数，它们将始终保留整个列表。

当然，我的一位同事抱怨说：“不！这实际上并不是模块化的！”他想要编写代码的漂亮版本，而不是一些可怕的巨大折叠函数。这让我思考：编译器是否真的无法判断在流数据结构上两个计算是否可以并行运行？

等等！我们可以告诉编译器并行运行这些：

```
import Data.List
import Control.Parallel
big = [1..10000000]
sum' = foldl' (+) 0
average' xs =
    let s = sum' xs
        l = length xs
    in s `par` l `par` fromIntegral s / fromIntegral l
main = print (average big)

```

令人惊讶的是，空间泄漏消失了（不要忘记用 `-threaded` 编译并至少用 `-N2` 运行）。利用多线程的力量，两个操作可以同时运行，因此没有不必要的保留。

或许并不奇怪，`par` 能够解决空间泄漏问题，因为 `seq` 也能做到。但是 `seq` 具有表示内容；`par` 没有，并且在单线程时什么也不做。这使得这种解决方案非常脆弱：在运行时，我们可能会根据核心的可用性决定是否并行评估其他惰性求值。但是，在单线程环境中，我们仍然可以有益地使用 `par`，如果它能够管理流的两个消费者之间的抢占式切换。这将是一个非常有趣的原语，并且看到某种明确说明这样一个函数有益于空间效果的语义也是很有趣的。另一个未成形的想法是，我们已经有了对流融合的好的生产者和消费者的概念。看起来我们可以使用这种分析来确定何时可以合并消费者，从而改善空间使用。

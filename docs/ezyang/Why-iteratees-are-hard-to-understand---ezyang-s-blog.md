<!--yml

类别：未分类

日期：2024-07-01 18:17:38

-->

# 为什么迭代器难以理解：ezyang 的博客

> 来源：[`blog.ezyang.com/2012/01/why-iteratees-are-hard-to-understand/`](http://blog.ezyang.com/2012/01/why-iteratees-are-hard-to-understand/)

有两个主要原因解释了为什么迭代器的低级实现——迭代器、枚举器和变换器——往往难以理解：*纯函数实现*和*控制反转*。这些特性的奇异性进一步加剧了用户被鼓励将迭代器视为接收器、枚举器视为源头、变换器视为转换器。这种直觉对迭代器库的客户有效，但让那些对内部机制感兴趣的人感到困惑。

在本文中，我想通过将其与传统的*命令式*面向对象语言中可能看到的实现进行比较，来解释*纯函数实现*所带来的奇异性。我们将看到，在命令式设置中显而易见且简单的概念，在纯函数设置中稍微困难一些。

### 类型

*以下讨论使用枚举器库的命名约定，因为在撰写本文时，它似乎是当前使用最广泛的迭代器实现。*

迭代器背后的基本实体是`Step`。通常的直觉是它表示迭代器的“状态”，即完成或等待更多输入。但我们警告过不要过度依赖隐喻，所以让我们看看类型：

```
data Step a b = Continue (Stream a -> m (Step a b)) | Yield b
type Iteratee     a b =                  m (Step a b)
type Enumerator   a b = Step a b ->      m (Step a b)
type Enumeratee o a b = Step a b -> Step o (Step a b)

```

我从枚举器库中进行了一些极为重要的简化，其中最重要的是显式地写出了`Step`数据类型，而我们本应看到的是`Iteratee`，并使`Enumeratee`成为纯函数。接下来的三节的目标是解释每个类型签名的含义；我们将通过将其类比于迭代器的命令式等价物来实现这一目标。对大多数程序员来说，命令式程序应该感觉直观，希望纯编码只是一个小跳跃。

### 步骤/迭代器

我们希望设计一个对象，它可以等待输入或完成某些结果。以下可能是一个提议的接口：

```
interface Iteratee<A,B> {
  void put(Stream<A>);
  Maybe<B> result();
}

```

这一实现关键依赖于类型为`Iteratee`的对象的标识，该对象在对`put`进行任意调用时都保持不变。对于我们的目的，我们需要将`put :: IORef s -> Stream a -> IO ()`（第一个参数是 Iteratee）转换为纯函数接口。幸运的是，如果我们理解`State` Monad 的工作原理，就不难看出如何做到这一点：我们将旧类型替换为`put :: s -> Stream a -> s`，它接受迭代器的原始状态（`s = Step a b`）和一些输入，并将其转换为新状态。最终定义`put :: Step a b -> Stream a -> m (Step a b)`也考虑了当迭代器接收数据时可能存在其他副作用的情况，但我们没有使用此 Monad 实例的必要；如果我们将其设置为身份 Monad，则我们的迭代器没有副作用（在这里可能更合适的术语是`StateT`）。实际上，这恰好是`Continue`构造函数中字段的访问器。

### 枚举器

我们希望设计一个对象，它接受一个迭代器并向其提供输入。这非常简单，只是一个变异其输入的函数：

```
void Enumerator(Iteratee<A,B>);

```

枚举器的类型意味着什么？

```
type Enumerator a b = Step a b -> m (Step a b)

```

如果我们将其解释为状态转换函数，那么明显枚举器是一个将迭代器从一种状态转换为另一种状态的函数，就像`put`一样。然而，与`put`不同的是，枚举器不从流中获取任何输入，并且可能导致多个状态转换：这是一个重要的步骤，其中所有中间状态都被隐藏起来。

此转换的性质没有指定，但常见的解释是，枚举器重复向步骤中的继续传递输入。执行可能会展开为以下内容：

```
-- s :: Step a b
-- x0, x1 :: Stream a
case s of
    Yield r -> return (Yield r)
    Continue k -> do
        s' <- k x0
        case s' of
            Yield r -> return (Yield r)
            Continue k -> do
                s'' <- k x1
                return s''

```

请注意，我们的类型签名不是：

```
type Enumerator a b = Step a b -> m ()

```

就像命令式 API 可能建议的那样。这样的函数将能够运行迭代器（并触发其任何附带的副作用），但我们将丢失迭代器的返回结果。这种轻微的修改也不行：

```
type Enumerator a b = Step a b -> m (Maybe b)

```

这里的问题在于，如果枚举器实际上没有成功完成运行迭代器，我们已经丢失了迭代器的最终状态（它从未返回！）这意味着你不能连接枚举器。

> 现在，我已经展开了所有`Iteratee`的定义，这一点应该是清楚的：在`enumerator`库中，枚举器和具有副作用的状态转换器之间的简单对应关系被不幸的类型签名所掩盖：
> 
> ```
> type Enumerator a b = Step a b -> Iteratee a b
> 
> ```
> 
> 关于这一点，Oleg 的原始处理方法在这个问题上要清楚得多，因为他定义了步骤本身就是迭代器。

### 枚举器

最后，我们现在已经准备好处理最复杂的结构，即枚举器。我们的命令式语法告诉我们，像这样的类可能会起作用：

```
interface Enumeratee<O,A,B> implements Iteratee<O,B> {
    Enumeratee(Iteratee<A,B>);
    bool done();
    // inherited from Iteratee<O,B>
    void put(Stream<O>);
    Maybe<B> result();
}

```

就像我们最初的`Iteratee`类一样，它支持`put`和`result`操作，但在构造时它包装另一个`Iteratee`：在这个意义上，它是从类型`O`到类型`A`的*适配器*。对外部`put`使用类型为`O`的对象可能会导致在内部`Iteratee`上使用类型为`A`的对象的零个、一个或多个调用；对`result`的调用只是简单地传递。一个`Enumeratee`也可以决定它已经“完成”，也就是说，它将永远不会再调用内部迭代器的`put`；`done`方法可能对测试这种情况很有用。

在我们继续讨论类型之前，值得反思的是这个命令式表述中涉及的有状态对象：它们是外部的`Enumeratee`和内部的`Iteratee`。我们需要维护*两个*而不是一个状态。命令式表述自然为我们管理这些（毕竟，即使枚举器正在运行，我们仍然可以访问内部迭代器），但在纯函数实现中，我们必须手动安排。

这是`Enumeratee`的类型：

```
type Enumeratee o a b = Step a b -> Step o (Step a b)

```

很容易看出为什么第一个参数是`Step a b`；这是我们包装的内部迭代器。不太容易看出为什么`Step o (Step a b)`是正确的返回类型。由于我们的命令式接口导致一个实现了`Iteratee<O,B>`接口的对象，我们可能会倾向于写出这样的签名：

```
type Enumeratee o a b = Step a b -> Step o b

```

但请记住；我们需要跟踪两个状态！我们有外部状态，但内部状态呢？在早些时候提到的我们的替代宇宙`Enumerator`类似情况下，内部迭代器的状态将永远丢失。也许如果这个枚举器打算用于输入的其余部分（即`done`总是返回 false），这并不是什么大问题，但如果我们需要停止使用`Enumeratee`，然后继续在流`Step a b`上操作，则这一点非常重要。

通过迭代器的设计，我们只能在它完成后才能得到结果。这迫使我们在第二个参数中返回状态，给出最终类型：

```
type Enumeratee o a b = Step a b -> Step o (Step a b)

```

“等等！”你可能会说，“如果迭代器只在最后才返回结果，这是否意味着内部迭代器只在最后更新？”然而，通过*控制反转*的力量，情况并非如此：当枚举器接收值并更新其自身状态时，它也执行并更新内部迭代器。中间的内部状态是存在的；它们只是对我们不可见。（这与命令式版本形成对比，对于那个版本，我们可以窥视内部迭代器！）

> 另一个很好的问题是，“为什么`enumerator`库在`Enumeratee`中悄悄加入了一个额外的单子？”即，
> 
> ```
> Step a b -> m (Step o (Step a b))
> 
> ```
> 
> 我的理解是，单子是不必要的，但如果您的`Enumeratee`需要在接收任何输入之前执行副作用（例如初始化），它可能会有用。

### 结论

不幸的是，我在这里不能宣称有很多新颖的东西：所有这些主题都在[Oleg 的笔记](http://okmij.org/ftp/Haskell/Iteratee/IterateeIO-talk-notes.pdf)中有涵盖。然而，我希望通过参考迭代器的命令式类比，使类型选择更加清晰。

使用这种纯编码有一些重要的含义，类似于使用 IORefs 和使用状态单子之间的差异：

+   迭代器可以分叉并在不同线程上运行，同时保持本地状态的隔离。

+   旧的迭代器状态副本可以保留，并稍后恢复，作为一种回溯的形式（用新的输入替换坏的输入）。

这些保证在简单的可变引用情况下是不可能的。然而，有一个重要的警告，即虽然迭代器的纯组件很容易被撤销，但我们无法撤销在单子中执行的任何破坏性副作用。在分叉的情况下，这意味着任何副作用必须是原子的；在回溯的情况下，我们必须能够回滚副作用。据我所知，撰写利用这种风格的迭代器的艺术并没有得到很好的研究，但在我看来，这是值得探讨的。最后，我要指出，新导管背后的一个论点是，纯度对支持大多数流处理并不重要。在我看来，这个问题还有待解决。

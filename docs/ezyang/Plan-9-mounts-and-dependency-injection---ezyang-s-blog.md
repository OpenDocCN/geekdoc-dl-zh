<!--yml

category: 未分类

date: 2024-07-01 18:17:24

-->

# Plan 9 挂载和依赖注入：ezyang 的博客

> 来源：[`blog.ezyang.com/2012/11/plan-9-mounts-and-dependency-injection/`](http://blog.ezyang.com/2012/11/plan-9-mounts-and-dependency-injection/)

“一切皆文件。”[1] 这是在[Plan 9](http://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs)中被推向逻辑极限的设计哲学。你能想象到的任何接口都被表示为一个文件。网络端口、像素缓冲区、内核接口——所有这些都统一在一个常规 API 下：文件操作（`open`、`read`、`write`...）。Plan 9 利用这一点消除了大部分系统调用：只有三十九个，与现代 Linux 的庞大的三百二十六个形成了对比。

当我第一次听说 Plan 9 时，我首先想到的是，“但这是作弊，对吧？”毕竟，他们减少了系统调用的数量，但增加了定制文件的数量：复杂性只是被重新分配了。但是我的一个[实验室同事](https://plus.google.com/107333307248367605396/about)给了我一个理由，说明这仍然很有用：每个进程的挂载点。这些挂载点意味着我可以给每个进程提供他们自己的文件系统视图——通常是相同的，但有时会有一些关键的不同之处。假设我想要隧道化我的一个应用程序的网络连接：这个应用程序将通过某些文件访问网络，因此我可以将一个网络文件系统挂载到另一个系统的网络文件上，并且透明地实现代理，而不需要我的应用程序的任何合作。[2]

让我们暂时放下编程语言的帽子。假设文件是一个抽象数据类型，而用于操作文件的系统调用接口是此数据类型的接口。在这个宇宙中，挂载是什么？我的另一个[朋友](https://plus.google.com/116034118081904229710/about)指出了一个非常明显的类比：

> 文件：挂载 :: 抽象数据类型：依赖注入

特别是，挂载是一种修改本地命名空间的机制，因此当请求文件时，可能由完全不同的文件系统提供文件，这与进程可能期望的不同。类似地，依赖注入指定了一个命名空间，因此当请求对象时，具体实现可能完全不同于调用者可能期望的内容。

总体结论是，当开发人员实施依赖注入时，他们重新实现了 Plan 9 的本地挂载。你的依赖注入是否是分层的？能否替换层次结构（`MREPL`），或在现有文件系统之前（`MBEFORE`）或之后（`MAFTER`）挂载你的文件？支持挂载时的运行时更改？支持层次结构中实体之间的词法引用（例如点点 `..` ）？我怀疑现有的依赖注入框架可以从 Plan 9 的设计中学到一些东西。而在 Haskell 中，似乎人们能够在不创建依赖注入框架的情况下取得更大进展，这些经验是否能映射回可挂载文件系统的设计呢？*我在想。*

* * *

[1] 功能程序员可能会想起一个类似的口号，“一切皆函数。”

[2] 长期以来，Linux 未提供进程级别的挂载命名空间，即使今天这一特性对非特权用户也不可用——相比之下，Plan 9 从一开始就向所有用户提供了这一功能。还有一个小问题，即在 Linux 中，处理进程级挂载实际上非常麻烦，我敢说主要是由于缺乏适当的工具来帮助系统管理员理解他们的应用程序。

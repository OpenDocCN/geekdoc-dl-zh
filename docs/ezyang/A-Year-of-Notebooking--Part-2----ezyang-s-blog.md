<!--yml

category: 未分类

date: 2024-07-01 18:17:44

-->

# 一年的笔记本（第二部分）：ezyang 的博客

> 来源：[`blog.ezyang.com/2011/06/a-year-of-notebooking-part-2/`](http://blog.ezyang.com/2011/06/a-year-of-notebooking-part-2/)

这是笔记本的第二部分。

### Max Schäfer：重构 Java

大多数内置于诸如 Eclipse 之类的 IDE 中的 Java 重构工具只不过是经过美化的文本操作宏。不能保证重构的结果与原始行为相同：甚至可以重构不编译的代码！为了防止这种情况发生，大多数重构都需要复杂且难以理解的前提条件。Max 提出了两个想法：

+   不要试图编写一个复杂的前提条件，可能不能准确反映安全问题，我们相反地进行转换，然后验证重构没有破坏任何东西。我们可以用程序行为的依赖描述来做这件事，它*过度规范*了原始的语义（否则，这样的分析将是不可判定的）。

+   不要试图编写一个试图处理所有可能情况的庞大重构，我们将重构分解为源语言的简化版本上的微重构。例如，将一块代码移动到一个方法中将涉及到闭包转换（控制）、lambda 提升（数据），然后是实际的外部移动，在这一点上已经是微不足道的。然后我们可以重新将其转换为原始的源语言。这使我们可以抽象处理边界情况。

模块化是一种非常强大的理念，这也是 Hoopl 所采用的。 （有人可能会想知道 Hoopl 是否对重构有用，我观察到的一个大问题是 Hoopl 的表示太低级了，而一个高级语言的要点实际上是你不需要复杂的数据流分析。）

然而，对此有一些错误的假设。它假设我们知道整个程序，它只用一种语言编写（没有 XML 清单文件），并且是静态类型和基于类的。当然，所有真实的程序都违反了这些假设，因此如果我们真的希望人们采用这种工作流程，我们需要一个适合他们的故事。重构是从松散到结构化代码的过渡。（我在页面底部涂鸦了*责任计算*，但现在我不知道这是什么意思。）

语义过度规范让我想起了 SLAM 对程序行为迭代逼近的方法。

### Mike Dodds：确定性并行性的模块化推理

分离逻辑的一个常见问题是，你需要为可能想要建模的每种并发构造引入一个新的原语，因此你最终会得到无数不同的逻辑，每个适合自己的并发模型。迈克提出了一种逐步构建任何你可能想要的语义的方法，使用“并发抽象谓词”。你可以使用谓词生成满足各种其他函数规范的变量。

这次特别讲座的大部分时间都花在了一个名为`wait/grant`的奇怪并发构造上，描述在《安全未来的准静态调度》中。这是一个保持“必要”顺序依赖性的屏障。一些时间实际上用来澄清这个构造的作用，以及它与缓冲通道的区别。托尼·霍尔评论说，这种构造类似于现实生活中的“生产线”，虽然在编程中并不常见，但对于原始论文作者所处理的问题（并行化顺序程序）来说却是相当自然的。

我的笔记鼓励我“在 Haskell 中实现这一点”，并且还有关于“树形位向量传播”的备注，显然这是优化过的版本。还有一堆代码片段，但我肯定可以在幻灯片中找到这些内容。

### 托马斯·佩特里切克：Joinads

F#的 Joinads 是一种用于对计算进行模式匹配的系统（与仅对值进行模式匹配不同）。这与单子有何不同？Joinads 支持额外的操作：`merge :: m a -> m b -> m (a, b)`和`choose :: [m (Maybe (m a))] -> m a`，可以实现特殊的调度属性。这对于未来（Manticore）、事件（FRP）或联接演算（当通道包含值时执行联接：它是廉价而快乐的复用）可能很有用。事实证明，你可以从交换单子中免费获得一个 Joinad，这可能说明了对这些单子有用的语法扩展类型。

无论出于何种原因，我对这次讲座并不特别感兴趣。我想我的理由是我并没有感受到为什么 Joinads 可能是一个特别有趣的理论构造要研究，也没有看到它们在任何意义上是最小的。此外，在 Haskell 中，我们通过 fork 额外的绿色线程来实现复用，这在我看来是一个更好的模型。

### 计算实数

丹·皮波尼之前已经写过这个主题，但这次讲座确实帮助我从更广阔的视角看待了这些问题。

我们可以轻松地处理许多类型的数字：二元域（布尔值）、整数（当然，不考虑溢出），以及有理数（整数对）。但是实数带来了一些困难。它们是有理数集合 Q 的度量闭包，即所有可以作为 Q 的柯西序列极限的东西。这让人想起了十进制展开。

现在我们要考虑实数上的函数。我们如何知道某物是可计算的？我们可能会尝试说它是从数字串到数字串的关系，其中`F(p)`的任何有限前缀可以从`p`的足够长度的有限前缀统一计算得出。但对于像 0.3333 这样的情况，这显然是不够的，因为我们需要读取无限多的数字来判断这是否真的是三分之一。（我要注意，无穷大有点像图灵机领域的预言机。）

相反地，我们说一个有理数序列`q_i`（其中`i`是自然数）代表了一个实数`x`，如果对于所有`i`，`|x - q_i| < 2^-i`。（基数并不重要）。让`p(q) = x`，那么如果存在`F`使得`p(F(prefix)) = f(p(prefix)`，则`f`是可计算的。根据这个定义，加法、乘法、除法、三角函数、指数函数和对数函数都是可计算的。

一个有趣的函数限制是连续性，从任何微积分教科书中都很熟悉：如果对于`f: R -> R`的所有`x`，对于所有`ε > 0`，存在一个`δ > 0`，使得对于`f`的所有定义域中的`y`，当`|x - y| < δ`时，`|f(x) - f(y)| < ε`。有人提出每个可计算函数都是连续的：因此，可计算性源于我们能够逼近事物，这对于不连续的函数来说是做不到的（我们处于不连续处的哪一边？）我们可以进一步限制函数到`C(R,R)`，这是连续函数集合，也可以通过无限序列来逼近（例如多项式）。

考虑单调中间值定理，该定理指出如果`f`是单调的，```f(0) < 0``and ``f(1) > 0```，那么存在某个 x 使得`f(x) = 0`。我们能计算出这个数吗？二分法不起作用，因为确定一个数是否大于或小于另一个数通常是不可计算的。（一般的中间值定理也不可计算，因为我们可以无限接近原点线。）我们可以使用三分法。同时计算`f(0.3)`和`f(0.7)`，并执行以下比较：

1.  如果`f(0.3) < 0`，新的区间是`[0.3, 1]`

1.  如果`f(0.3) > 0`，新的区间是`[0, 0.3]`

1.  如果`f(0.7) < 0`，新的区间是`[0.7, 1]`

1.  如果`f(0.7) > 0`，新的区间是`[0, 0.7]`

你需要做一些工作来得到一个正确性的正式证明，但很容易看出为什么这在直观上可能有效：比较只有在数接近比较点时才会花费无限的时间，但那么我们的另一个比较就一定会成功，因为它与比较点有非无限小的距离。（我有一个小边注：我们可以用这个来做密码学吗？）

结果证明实数的可计算性有各种学派。我刚才描述的观点是波兰学派。然而，俄罗斯学派认为不可计算的点不存在：代码片段就是实数。因此，有效分析不是经典分析。构造数学与经典数学之间存在对应关系。关于巴拿赫空间（线性算子必须是有界的），因此一般情况下微分不可计算，尽管积分是可计算的！（这与符号评估世界非常不同。）欲了解更多，请参阅《可计算分析》，Springer，2000。

### 马丁·埃斯卡尔多：处处选择函数

我没听懂这个讲座。实际上，我对马丁的大部分工作都不太理解。但我有一堆引用：

+   “我不知道为什么它被称为延续单子；没有控制，这个讲座完全失控了。”

+   “我不打算解释这意味着什么，但我将解释这是如何运作的。”

+   “[无法理解的陈述]。这并不太深奥。”

+   “原因是，嗯，可能在下一张幻灯片里。”

+   “每场比赛都是长度为 2 的：你有第一步，然后所有其他的。”

+   “你将可以使用单调单子结构来计算这两个人。”

选择函数选择具有“最高”真值的个体。最大值定理、最小值定理和全局值定理（饮酒者悖论）都是不可计算的。选择函数是一个两阶段过程。`K A -> A`是双重否定消除，`J A -> A`是皮尔斯定律。贝基奇引理给出一个不动点。条形递归和对`p`（连续函数）的归纳（以树形式）进行递归。我们可以计算最优策略。T 系统加上 J-shift 方程是强正则化的。我们可以编码可数选择公理（但这不再是选择了！）。依赖选择：（AC 经典选择，Tychonoff 理论等。参见那篇文章。）为什么 J 是一个单子？

### 罗杰·彭罗斯爵士：纺锤体理论

彭罗斯……的讲话并不是很易懂。嗯，他解释了黎曼球面（一种立体投影）得相当不错，但接下来的事情变得非常模糊。一些引用：“这就是数学中你所必须做的：去想象它。”“小不适用于距离。”“所以我最好的方法是把它画成香肠。”“我不认为我应该解释这幅图。”“首先我会让你更加困惑。”“这可以在板球中完成，我们希望在纺锤体理论中也能做到。”关于余同调有一个有趣的旁白：一个关于不可能性程度的精确的非局部度量；我看到艾舍尔的图片时我觉得很振奋。甚至物理学家们都认为纺锤体理论并不反映现实。这只是一个数学玩物。

没有关联的话题，那晚上 RAG 的相亲活动正在进行。

### 康纳·麦克布赖德：命运的 Kleisli 箭头

“考虑以下程序，哎呀，可怜！”代码幻灯片包含变量 `b` 和 `c`：“有 b 还是没有 b，这是一个问题！...或者为了抵抗一堆麻烦。”“世界上最成功的依赖类型语言：Haskell。”向房间里的 Simon Peyton-Jones 挥手。

我一直想写一篇关于这次演讲的博客文章，或许还会写，尽管这次演讲在我脑海中已不再那么新鲜。Conor 描述了模拟依赖类型所需的技术机制，即使不能显然地将值推入类型中。程序应该是策略树，涵盖所有可能的响应（尽管现实会选择其中一种）。我们不需要依赖类型：我们可以使用参数化的单子来编码 Hoare 逻辑的前后条件。（导致一个可预测的世界。）这些被称为“向上流动的大括号”（向上流动指的是值变成类型）。这次演讲让我想知道 Strathclyde Haskell 扩展是否是会话类型的良好平台，这些类型因缺乏真正的依赖类型而受到极大的影响。（它还让我想到了*高效*的类型级计算。）

魔鬼是 ∀（看看那对角）例如，一个错误的全称量词（我以为你可以将它们视为斯克勒姆变量）。术语在类型上持有证据。（典型的 Conor 会开个关于这个的玩笑。）Kleisli 箭头是 Hoare 三元组（考虑可编程的分号），并且用 bind 不会让您选择结束状态（那里有个存在量）。然而，我们可以使用强制魔鬼给我们值的替代 bind：Atkey 参数化单子。我们还需要确保我们天真的自由单子不会在运行时出问题。这并不是很一致，整理这个故事是我在发布真正的文章之前需要做的事情。

Conor 的主要信息是数据是证明的见证！“我在见证保护计划中。”如果我们有一些数据，我们就履行了一些证明义务。（但我想知道，多态性呢？）

### 并发的 Petri 网

我们想要性能的非确定性，所以我们使用 Petri 网来编码非确定性契约，然后通过图表来推动流量，以确定我们需要什么样的性能。调度和放置很容易处理，因为它们只是 Petri 网上的修改。但我不确定这种方法是否有效，因为 Petri 网可能会变得相当复杂，而且您可能无法获得所需的性能以进行有趣的分析。

### Grant Passmore：计算代数中的策略

自动推理问题是不可判定的，并且是用户引导的。计算代数问题是不可行的，但算法往往是黑盒子、秘密酱的解决方案（例如 Mathematica），具有各种像 Groebner 基、量词消除、非线性复杂算术的 SAT（希尔伯特的弱零点定理）和简化到重写的技巧。

格兰特希望将选择权交还给计算机代数。有许多选择点：二次预处理，成对选择，基础增长，前向简化。他对 ATP 和 GB 进行了比较。在 LCF 中，功能参数是关键。套路可以，但证明过程是一种策略。

1.  算法中有什么可以改变而保持正确性？

1.  我的算法正在做出什么任意选择？

（页边注：我们是否可以通过理解它创建的可变状态来理解融合？）

### （未命名的软件工程讲座）

形式方法的一个持久问题是它们在假设和要求的领域中运作，而无法确定这些假设或要求是否正确！这是一个相当哲学的问题：我们是否可以有“已知的认证缺陷”：一个已知的未知？这些是潜在的反证据来源。不知道有什么最坏的影响？你提出了什么主张？（看看哲学的哪些元素在这里是相关的会很有趣。）有时安全论据只是断言“因为我这么说”：这是认识论不确定性。演讲者认为我们应该用定性的信心论据来交换概率完整性论据：这是安全与信心的问题。我们应该明确承认认证缺陷，并停止太过信任。

我提出了这样一个问题：是否有动机进行这场辩论？（工程师们想要表现得很好。）把它交给评估者显然更糟，因为他们没有适当的位置来评估系统。他没有回答，但说道，“不这样做是不能接受的。”

我有点惊讶地注意到，在接近结束时，他推动了一些处理这个问题的技术软件，显然是他自己研究计划的产物。我对解决这个特定问题的技术解决方案仍然不确定。

### 近似马尔可夫链

标记马尔可夫过程编码连续状态空间，长期以来，我们注意到双仿真适用于离散状态空间，但不适用于连续状态空间。我们将最终状态视为概率分布，并在我们的机器上按下按钮（标签）以更改分布：每个标签是一个随机核（广义二元关系）。当然，推理关于连续状态空间是重要的：它们涵盖像布朗运动、性能、带递归的概率过程代数、混合控制系统（飞行管理系统）等复杂的离散现象，例如人口增长和股票价格。

我并没有理解大部分技术细节，但主要观点是共仿真是正确的方法：这只是巧合，双仿真适用于离散系统。投影极限恰好是最小的双仿真过程。还有一些关于度量空间的材料。这显然是一个我们仅仅从数学的小众领域导入众所周知结果的领域。

### 金融密码学

美国人不知情，他们的金融系统仍然停留在磁条阅读器上，而欧洲的银行卡已经迁移到 EMV，其中在芯片中嵌入了一个微处理器，可以进行真正的挑战-响应认证。本讲座探讨了我们如何通过现有的 EMV 硬件引导一个绕过银行的 P2P 交易系统。

我们该如何做到这一点？我们可以使用称为 CAP 的设备，它有一个小显示屏，当给定一个 PIN 时会生成认证码（双因素认证）。我们将交易与 CAP 码关联起来，这样商家同意接收款项。但是你仍然需要从银行那里获得合作。（这是 SDA 方法。）所以我们完全摆脱了银行，使用 Diffie-Hellman（DDA）。卡只是简单便利的现有基础设施，用于获取名称认证。由于我们一次只能签署 32 位，通常需要更多。 （边注：“威胁模型是隐私倡导者。”）

讲话很短，所以之后我们讨论了为什么这个方案实际上不会起作用。我的反对意见是银行可能会简单地禁止以这种方式使用他们的银行卡。讨论是他们是否技术上能够强制执行这一点：马库斯·库恩用护照作为例子，如果您没有互联网访问权限，您就无法读取护照，因为护照本身有一个嵌入的单调时钟，如果扫描仪软件不是最新版本，则会拒绝向扫描仪提供信息。护照如何知道最新版本是什么？它的时钟在看到新扫描仪时得到更新。）护照安全技术非常有趣！他们为此发明了一个字母表上的块密码。

### 验证 QBF 的有效性。

SAT 是指数级的，当你将量化器加入其中时，得到的是“另一个”指数级，但这次是在证书中。如何验证一个全称量化公式实际上是真的？在这种情况下，证书是扩展变量和见证：我们为所有存在量化的变量提供具体实现，然后可以替换成一个传统的 SAT 问题。因此，一旦我们有了证书，一个 PSPACE 问题现在“只是”一个 NP 问题。

（技术注释：我们希望按拓扑顺序消除假设（使用 Refl、Gen 和 Exists）。正确排列量化器，见证取决于存在变量，扩展变量取决于此。）

讲话描述了他如何钩入 Squolem 的内部，以实际获得这些证书。结果表明，德布鲁因比携带名称更快（这与典型的 QBF 无效性检查不同）。他甚至发现了非 LCF 样式验证器中的一个 bug（由于缺乏循环检查）。

应用：模型检验（有界和无界），PSPACE 问题。（边注：“比较 BDD 和 QBF？”）

这篇笔记本二到此结束。

<!--yml

category: 未分类

date: 2024-07-01 18:17:06

-->

# 不需重新安装的 Cabal 是否即将到来 GHC 8.0？：ezyang’s 博客

> 来源：[`blog.ezyang.com/2015/09/is-no-reinstall-cabal-coming-to-ghc-8/`](http://blog.ezyang.com/2015/09/is-no-reinstall-cabal-coming-to-ghc-8/)

你可能会想：使用 [不需重新安装的 Cabal 的测试版](http://blog.ezyang.com/2015/08/help-us-beta-test-no-reinstall-cabal/)，这个功能是否会被引入到 GHC 8.0 中？（甚至是新版本的 Cabal，因为不需重新安装功能在 GHC 7.10 上也有效）。不幸的是，Cabal 的开发人员在是否应将实际的不需重新安装行为默认加入 Cabal 中存在分歧。尤其是 Duncan Coutts 认为在没有其他（未实施的）对 Cabal 的更改的情况下启用不需重新安装是一个坏主意。由于额外所需的更改尚未完全实施，目前不清楚 Duncan 是否会在 GHC 8.0 中管理它们。

我听说不需要重新安装的 Cabal 对于大多数人来说实际上运行良好，因此我怀疑很多人会赞成直接采取“好”（而非“最佳”）解决方案并将其纳入 Cabal。但我希望促进一个理性的讨论，因此我想解释一下不需要重新安装的（已知的）问题。

### 什么是不需重新安装？

当前，GHC 和 Cabal 在已安装的软件包数据库中维护一个不变量，即对于任何软件包名称和版本（即（源）软件包 ID），数据库中最多只有一个匹配的软件包：

箭头表示“依赖于”关系：因此，如果你有一个数据库，其中包含 bar-0.1、bar-0.2 和一个构建在 bar-0.1 上的 foo-0.1 实例，那么你将不允许安装另一个构建在 bar-0.2 上的 foo-0.1 实例（尽管你可以安装构建在 bar-0.2 上的 foo-0.2）。

如果 cabal-install 希望安装一个与已在数据库中的软件包具有相同软件包 ID 但具有不同依赖项的软件包，则必须破坏性地覆盖先前的条目以维护下面显示的此不变量：

无需重新安装此不变量，因此“重新安装”具有不同依赖项的软件包正常运行：

最近发布的不需重新安装的 Cabal 通过两个小功能实现了这一点。首先，在 GHC 7.10 中，我们为 `ghc-pkg` 添加了 `--enable-multi-instance` 标志，使得 `ghc-pkg` 在尝试向数据库中添加同一软件包的多个副本时不再报错。其次，在 Vishal Agrawal 的 Cabal 补丁集中，修改了 cabal-install 以使用此标志，因此依赖解析器不再需要避免重新安装。

不过，破坏此不变量会产生后果。让我们看看其中的一些后果。

### 问题 1：它在旧版本的 GHC 上不起作用

**总结：** 在 GHC 7.8 及之前的版本中，直接实现无重新安装是不可能的（因为 `ghc-pkg` 将拒绝它）。即使可能，安装一个具有与现有包相同源包 ID 的新包的实例，会导致以下情况之一：（1）使旧包及其所有依赖项从 GHC 的默认视图中隐藏，尽管它们仍然可用；或者（2）未能在 GHC 的默认视图中暴露。

假设包 `foo-0.1` 定义了类型 `Foo`，并且已经使用其依赖项的不同版本编译了两次：

GHC 7.8 无法区分包的两次编译：来自两个包的符号将存在于 `foo-0.1` 命名空间中，并且冲突的符号将简单地被视为相同。灾难！为避免这种情况，GHC 有一个遮蔽算法，从其可见集中移除不兼容的包。以下是一个例子：

我们有两个包数据库，用户数据库和全局数据库，侧边放置（用户数据库位于“顶部”）。当组合数据库中存在冲突的包 ID 时，GHC 更喜欢来自顶部数据库的包：因此，在我们的例子中，全局 `foo-0.1` 被遮蔽（任何直接或间接依赖于它的包也被遮蔽）。当一个包被遮蔽时，对于 GHC 来说它根本不存在：GHC 不会提及它或者暗示它存在。

无重新安装要求我们允许这些重复包存在于同一数据库中！在这种情况下，GHC 将应用遮蔽；然而，不清楚应该遮蔽哪个包。如果 GHC 选择遮蔽旧包，则它们会从 GHC 的默认视图中“消失”（就像它们根本不存在一样）；如果 GHC 选择遮蔽新包，则用户刚刚通过 `cabal-install` 安装的包会神秘地消失！令人头疼。

### 问题 2: 使用多个相同包实例很令人困惑。

**总结：** 在 GHC 7.10 或更新版本中，可以在同一 GHC/GHCi 会话中同时使用多个相同包的实例，这可能导致混乱的类型不等式。

在 GHC 7.10 中，我们现在使用“包键”来测试类型标识。包键是源包 ID 加上所有依赖包键的哈希值。这意味着 GHC 不再需要应用遮蔽来保证完整性，你可以使用 `ghc-pkg` 上的 `--enable-mult-instances` 标志注册包的重复实例。

然而，这仍然可能导致混乱的行为。考虑在 GHC 7.10 中的前述示例：

`foo` 的两个版本都是可见的，因此如果我们尝试导入 `Foo`，GHC 将抱怨不知道我们想要哪个 `Foo`。可以通过隐藏其中一个包或另一个包来解决这个问题。然而，假设 `baz` 和 `qux` 都是公开的，并且它们都导出了类型为 `Foo` 的值 `foo`。尽管它们: (1) 都命名为 `Foo`，并且 (2) 来自名为 `foo-0.1` 的包：它们是 `foo-0.1` 的两个不同实例。令人困惑！

### 问题 3：Nix 对非 sdist 包的哈希是困难的

很容易“欺骗”Cabal 去哈希一组源文件，这些文件并不代表构建系统的真正输入：例如，您可以省略 `other-modules` 字段中的文件，或者在 Cabal 计算源哈希后和构建文件之间修改文件。如果你不能信任 Nix 哈希，那么当你真正需要覆盖 Nix 数据库中的旧条目（它错误地具有与您尝试安装的内容“相同”的哈希）时，现在你必须担心会发生什么。

从 Hackage 下载的 tarballs 不会存在这个问题，因为你可以简单地对 tarball 进行哈希，这可以保证是用于构建文件的完整源代码集。

### Duncan 的补丁集

为了解决这些问题，Duncan 一直在开发一个更大的补丁集，具有以下特性：

1.  为了支持旧版本的 GHC，他维护了一个单独的“默认视图”包数据库（它由裸露的 GHC 和 GHCi 调用使用），与实际的“Nix 存储”包数据库不同。`cabal-install` 负责维护一个一致的默认视图，但也将所有内容安装到 Nix 存储数据库中。

1.  Nix 风格的哈希仅针对 Hackage 包执行；本地源代码树只能构建并安装到沙盒数据库中，而不是全局数据库。因此，实际的 Nix 哈希仅由 `cabal-install` 计算。

1.  他还希望使 `cabal-install` 的安装计划不依赖于 Nix 数据库的本地状态：无论您之前安装了什么，它都应该提供相同的计划。这通过依赖解析而没有任何参考 Nix 数据库的方式来完成，然后一旦为每个包计算了 IPID，就检查它们是否已经构建。这个计划还将使支持 `cabal install --enable-profiling` 成为可能，而无需清空并重建整个包数据库。

### Vishal 的补丁集

Vishal 也意识到了包数据库默认视图的问题，并且他为支持修改包环境而在 GHC 上[工作了一些补丁](https://phabricator.haskell.org/D1119)，这将起到与 Duncan 的额外包数据库类似的作用。不幸的是，这些补丁目前在代码审查中遇到了些许问题，并且它们不会帮助那些使用旧版本 GHC 的用户。虽然这些补丁的代码审查过程可能在不久的将来会有所进展，但我对这些变化是否能够落地表示怀疑。

### 结论

我的观点是，历史上，问题一和问题二一直是“无需重新安装”未被添加为 Cabal 的默认操作模式的主要原因。然而，有越来越多的观点（我认为可以安全地[引用 Simon Marlow](https://www.reddit.com/r/haskell/comments/3ite8n/noreinstall_cabal_a_project_to_move_cabal_to_a/cuk7gn9)在这方面）认为这些问题被夸大了，并且我们应该接受这一现实。

如果我们想在 Duncan 完成他的补丁集之前（不管那会是什么时候 — 或者也许有其他人会完成它），我认为需要一些协同努力来表明，这些问题是为了无需重新安装 Cabal 所付出的小代价，并且 Haskell 社区愿意承担…… 至少在更好的实现方法出现之前。

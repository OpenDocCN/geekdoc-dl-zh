<!--yml

category: 未分类

date: 2024-07-01 18:18:20

-->

# Hackage 上的名称冲突：ezyang’s 博客

> 来源：[`blog.ezyang.com/2010/05/name-conflicts-on-hackage/`](http://blog.ezyang.com/2010/05/name-conflicts-on-hackage/)

*注意保护环境声明。* Hackage 上使用最多的非限定标识符。

或许你害怕这个错误信息：

```
Ambiguous occurrence `lookup'
It could refer to either `Prelude.lookup', imported from Prelude
                      or `Data.Map.lookup', imported from Data.Map

```

这是风笛手的信息，他来收取你不卫生不合格的无限制模块导入风格的应得之债。

或者你是一个库作者，正试图想出一个新的符号来表示你的时髦中缀组合子，但你不确定其他库已经使用了什么。

我取出了 [最新 Hackage 包的归档（TAR）](http://hackage.haskell.org/cgi-bin/hackage-scripts/archive.tar)，为所有内容编写了一个脚本，提取所有公共模块导出的非限定名称，然后统计了使用最多的名称。

*免责声明。* 数据构造器和记录字段，除非它们被明确地导出，否则不包括在此计数中。我也不会计算那些从全局命名空间导出*所有*内容的模块，因为它们忽略了要导出的名称列表。计数是按模块计算的，而不是按包计算的。由于 haskell-src-exts 的限制，CPP 和 HSC 文件未被计数。

*前二十个标识符（截至 2012 年 9 月 2 日）。*

```
106 empty
69 insert
69 toList
66 fromList
56 null
54 singleton
44 run
42 encode
41 decode
41 delete
39 size
37 theModule
35 member
32 parse
31 get
30 lookup
30 union
29 Name
29 space
28 Node

```

*前二十个中缀运算符（截至 2012 年 9 月 2 日）。*

```
25 !
19 <>
17 <+>
14 </>
11 <$>
10 //
10 ><
 9 .:
 9 <$$>
 9 ∅
 8 &
 8 .=
 8 <?>
 8 <||>
 8 \\
 8 |>
 7 #
 7 $$
 7 *.
 7 <->

```

惊叹号已经赢得了“索引”运算符的声誉，并且毫不奇怪地位居榜首。我从 Edward Kmett 那里听说 `<>` 正在以 `mappend` 的形式进入基础库，这是受欢迎的，尽管对其他六个重定义了它用于自己不可告人目的的模块可能不太友好。

*按使用频率和词典顺序排序的所有中缀运算符（截至 2012 年 9 月 2 日）。*

```
! <> <+> </> <$> // >< .: <$$> ∅ & .= <?> <||> \\ |> # $$ *. <-> <. <//>
<| <|> ==> >. ||. ∈ ∉ !! &&. ++ +++ /=. <=. =: ==. >=. ∋ ∌ ∩ ∪ .|. :->
<: ? ∆ ∖ .&. .* .-. <&> <.> << === ?? @@ \/ ^^ |+ |- ||| ~~ !!! !> !? ##
$+$ += +> -<- .*. .:? .<. .==. .>. /=? /\ :- :> :~> <$?> <+< <=> <=? <?
<|?> =. ==? =~ >-> >=? >? @# ^ ~> ¬ ∘ ∧ ∨ ≡ ≢ ⊂ ⊃ ⊄ ⊅ ⊆ ⊇ ⊈ ⊉ !: $# $>
$~ % %> && &&? &= ** *|* + --> ->- -| . .!= .!=. .&&. .&.? .*> .+ .++.
.+. ... ./. ./\. .:: .<=. .=. .=> .>=. .\/. .| .||. :* :+ :. := :=: <*.
<*> <++ <++> <..> <:> <<|> <== <|*|> =$= >+> >=> >>>= >|< ?> ?>= @@@ ^#
^$ ^: ^^^ |* || ||* ||+ ||? ~: ~? ≠   ≮ ≯ ⊕ ⧺ !$ !$? !. !=. !>>= #! #!!
#~~ $ $! $$$ $$$? $$+ $$++ $$+- $$= $- $. $.// $/ $// $= $=! $? $| $~!
%% %&& %+ %/= %: %< %<= %== %>= %|| &#& &&& &+ &. &.// &/ &// &=# &> &@
&| * *! *& *&&&* *&* ***** ****/* ****/*** ****//* ****//*** ****|*
****|*** ****||* ****||*** ***/* ***/** ***/**** ***//* ***//**
***//**** ***|* ***|** ***|**** ***||* ***||** ***||**** **. **/* **/***
**//* **//*** **> **|* **|*** **||* **||*** */* */** */*** */**** *//*
*//** *//*** *//**** *<<<* *=* *=. *=>* *> *>>>* *? *@ *^ *|** *|***
*|**** *||* *||** *||*** *||**** +% ++. ++> ++>> ++@ +/+ +: +:+ +=. +>>
+@ +^ +| - -!- -$ -->> -/\- -: -< -<< -<=- -=. -=> ->> -?- -?-> -?> -?>>
-@ -\/- -^ -|- -~> .! .# .$. .- .--. .->. .... ./ ./= ./=. .:. .::: .<
.<<. .<= .== .>>. .@ .@$ .@~ .\. .|| .~ .~. / /+/ /- /. /<-. /=: />/ /^
/| /~ /~? :*: :+: :-: :<-> :<: :<=: :<> :<~> :=+ :><: :~ <! <#$> <$| <%
<&&> <* <+ <-$ <-- <-. <-: </=? <<! <</ <<: <<< <<? <<\ <<| <<~ <=! <=:
<==? <=@ <=@@ <>>= <?< <??> <@ <@> <@@ <~ =$ =$$= =*= =/= =< =<< =<<!
=<<< =<= =<>= =<? ==! =>> =~= =≪ >! >$$< >$< >*> >-- >-< >: >:> >=! >=:
>== >===> >=>=> >=@ >=@@ >> >>-> >>. >>= >>=# >>== >>=\/ >>=|\/ >>=||
>>=||| >>> >>@ >?> >@ >@@ >||< ?! ?+ ?/= ?: ?< ?<= ?= ?== @! @= @==? @=?
@? @?= @?== \== ^% ^-^ ^. ^>>= ^@ ^^. |#| |$> |*| |-> |-| |. |/ |// |:
|<- |= |=> |=| |? |@ |\ |\\ |||| ~/= ~== ~=? ~?= ~|||~ ~||~ ~|~ ~~# ~~>
~~? ~~~> · ·× × ×· ÷ ⇒ ⇔ ∀ ∃ ≫ ≫= ⊛ ⊥ ⊨ ⊭ ⊲ ⊳ ⋅ ⋈ ⋘ ⋙ ▷ ◁ ★

```

这简直就是一个动物园！（我个人想起了 Nethack 游戏。）

*来源。* 驱动这个演习的可怕代码可以在 [Github](http://github.com/ezyang/hackage-query) 找到。我使用了以下 shell 单行命令：

```
for i in *; do for j in $i/*; do cd $j; tar xf *.tar.gz; cd ../..; done; done

```

以提取压缩文件中的所有 tar 文件。

*附言。* 如果有人能修复我早些时候描述的不一致之处，并在这个领域进行更全面/正确的搜索，那将是很棒的。

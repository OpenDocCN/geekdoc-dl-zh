<!--yml

类别：未分类

日期：2024-07-01 18:17:11

-->

# 非德布鲁因术语的 Eq 实例：ezyang 的博客

> 来源：[`blog.ezyang.com/2015/01/an-eq-instance-for-non-de-bruijn-terms/`](http://blog.ezyang.com/2015/01/an-eq-instance-for-non-de-bruijn-terms/)

**简短总结** *一个非无名术语配备一个指定德布鲁因编号的映射可以支持有效的相等性，而无需辅助函数。更抽象地说，商集不仅适用于证明：它们还可以提高程序的效率。*

**关键点。** 你正在编写一个小编译器，定义表达式如下：

```
type Var = Int
data Expr = Var Var
          | App Expr Expr
          | Lam Var Expr

```

其中`Var`来自某个全局唯一的提供。但是当你在共同子表达式消除器上工作时，你发现自己需要定义表达式的*相等性*。

默认实例不适用，因为它不会说`Lam 0 (Var 0)`等于`Lam 1 (Var 1)`。你的同事尼古拉斯取笑你说，如果你使用*无名表示*，默认实例就能起作用，但德布鲁因级数让你头痛，所以你决定尝试自己写一个正确的实例。然而，你遇到了一个困境：

```
instance Eq Expr where
  Var v == Var v'          = n == n'
  App e1 e2 == App e1' e2' = e1 == e1' && e2 == e2'
  Lam v e == Lam v' e'     = _what_goes_here

```

如果`v == v'`，事情就简单了：只需检查`e == e'`。但如果它们不是... 需要做些什么。一种可能性是在继续之前*重命名*`e'`，但这会导致一个需要二次时间的相等性。你打开了一个著名编译器的源代码，你发现事实上：（1）术语没有 Eq 实例，（2）已定义了一个具有此类型签名的相等函数：

```
eqTypeX :: RnEnv2 -> Type -> Type -> Bool

```

其中`RnEnv2`是一个包含重命名信息的数据结构：编译器通过延迟任何重命名来避免二次增长。

“好吧，这很棒，”你想，“但我想要我的 Eq 实例，并且我不想转换为德布鲁因级别。”还有什么可以做吗？

或许需要换个角度看问题：

**转折点。** 尼古拉斯有正确的想法：无名术语表示具有非常自然的相等性，但你定义的类型太大了：它包含许多表达式，它们应该是相等的，但在结构上却不是。但从另一个角度来看，它也太*小*了。

这里有一个例子。考虑术语`x`，它是`λx. λy. x`的子术语。这个术语中的`x`是自由的；只有通过上下文`λx. λy. x`我们才知道它是绑定的。然而，在使用德布鲁因级别（而不是索引——事实证明，在这种情况下级别更方便）的类似情况中，我们有`0`，它是`λ λ 0`的子术语。我们不仅知道`0`是一个自由变量，而且我们还知道它绑定到最外层的 lambda，*不管上下文如何。*只有`x`，我们没有足够的信息！

如果你知道你不知道某事，你应该学习它。如果你的术语对它们的自由变量了解不足，你应该*为它们提供*必要的知识：

```
import qualified Data.Map as Map
import Data.Map (Map)

data DeBruijnExpr = D Expr NEnv

type Level = Int
data NEnv = N Level (Map Var Level)

lookupN :: Var -> NEnv -> Maybe Level
lookupN v (N _ m) = Map.lookup v m

extendN :: Var -> NEnv -> NEnv
extendN v (N i m) = N (i+1) (Map.insert v i m)

```

当你这样做时，事情可能会按你所希望的方式进行：

```
instance Eq DeBruijnExpr where
  D (Var v) n == D (Var v') n' =
    case (lookupN v n, lookupN v' n') of
      (Just l, Just l')  -> l == l'
      (Nothing, Nothing) -> v == v'
      _ -> False
  D (App e1 e2) n == D (App e1' e2') n' =
    D e1 n == D e1' n' && D e2 n == D e2' n'
  D (Lam v e) n == D (Lam v' e') n' =
    D e (extendN v n) == D e' (extendN v' n')

```

(尽管也许 Coq 在无外援的情况下可能无法判断这个函数是结构递归的。)

> **练习。** 定义一个类型为 `DeBruijnExpr -> DeBruijnExpr'` 的函数及其逆函数，其中：
> 
> ```
> data DeBruijnExpr' = Var' Var
>                    | Bound' Level
>                    | Lam' DeBruijnExpr'
>                    | App' DeBruijnExpr' DeBruijnExpr'
> 
> ```

**总结。** 我们在这里做了什么？我们通过*添加*更多信息对一个类型进行了商集化，使其变得更小。通过这样做，我们恢复了一种简单的方式来定义类型上的相等性，而无需定义一个辅助函数、进行额外的转换或者承受二次复杂性能的损失。

有时候，增加信息是获得最小定义的*唯一*方法。这种情况发生在同伦类型论中，其中*等价性*必须装备有额外的信息，否则它不是一个单纯的命题（具有错误的同伦类型）。如果您，亲爱的读者，有更多例子，我很乐意在评论中听取。我们经常被告知“少即是多”，简约主义的路线在于去除事物：但有时，真正的路径在于*增加约束*。

*后记.* 在 Haskell 中，我们并没有真正地让类型更小：例如，我可以通过投影出底层的 `Expr` 区分出应该等价的两个表达式。一个合适的类型系统，支持商集，将迫使我证明，如果两个元素在商等价关系下是等价的，那么我的消除函数就不能观察到它。

*后记 2.* 这种技术有其局限性。以下是一种情况，我还没有找到正确的商集：假设我的表达式类型是这样的，所有自由变量都是*隐式全称量化*的。也就是说，存在某种量化顺序，对于 `a` 和 `b`，`a b` 等价于 `b a`。有没有办法在不要求在表达式上使用这种商集技术的预处理的情况下，实时地按顺序获取量词？我不知道！

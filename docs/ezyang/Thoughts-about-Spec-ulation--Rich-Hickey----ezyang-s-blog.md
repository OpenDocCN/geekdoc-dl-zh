<!--yml

category: 未分类

date: 2024-07-01 18:17:03

-->

# 关于 Spec-ulation 的思考（Rich Hickey）：ezyang’s 博客

> 来源：[`blog.ezyang.com/2016/12/thoughts-about-spec-ulation-rich-hickey/`](http://blog.ezyang.com/2016/12/thoughts-about-spec-ulation-rich-hickey/)

Rich Hickey 最近在 Clojure/conj 2016 上发表了[主题演讲](https://www.youtube.com/watch?v=oyLBGkS5ICk)，思考语言生态系统中版本控制、规范和向后兼容性的问题。在此，Rich 考虑了["极端"观点](http://blog.ezyang.com/2012/11/extremist-programming/)，*如果我们构建一个语言生态系统，永远不会破坏向后兼容性*。

演讲的大部分时间都花在探讨这一观点的后果上。例如：

1.  假设你想对一个函数进行破坏性的向后兼容性更改。不要*改变*函数，Richard 说，给函数取另一个名字。

1.  好的，但如果有一些系统性的更改需要应用到许多函数中怎么办？这仍然不是借口：创建一个新的命名空间，把所有函数放在那里。

1.  如果有一个你真的不喜欢的函数，你真的想要摆脱它怎么办？不，不要删除它，创建一个新的命名空间，该函数不在其中。

1.  要是听起来很多工作要去除一些东西？是的。所以不要去除东西！

总的来说，Rich 希望我们通过将所有变更转化为*堆积*来避免破坏，这样新旧可以共存。他说：“我们需要将函数式编程[不变性]带到库生态系统中，依赖地狱只是可变性的地狱。” 为此，需要有工具让你承诺库提供和需要的内容，并且在发布新版本软件时不会意外破坏这一承诺。

他在演讲中说了更多，因此我鼓励你如果想要全面了解，请观看整个演讲。

* * *

总的来说，我赞同这种思路，因为我认为大量与软件变更相关的破坏只是疏忽的产物；破坏不是因为任何良好的理由，而是可以通过工具帮助避免的。

话虽如此，我确实对他演讲中未被如此突出展示的话题有一些看法。

**堆积并非万灵药……如果你信仰数据隐藏。** 在他的演讲中，Rich 暗示通过承诺“不移除事物”可以简单地维护向后兼容性。作为一个 Haskell 用户，这对我显然是错误的：如果我改变某些抽象类型的内部表示（甚至是内部不变式），我*无法*简单地加载新旧版本的库并期望在两者之间传递此类型的值。事实上，即使表示方式没有改变，类型检查器也不会允许这样做。

但至少对于 Clojure 来说，我认为 Rich 是对的。原因在于：[Clojure 不相信数据隐藏](http://codequarterly.com/2011/rich-hickey/)！Clojure 代码的流行风格是数据类型由不可变记录组成，具有公共字段传递。因此，对数据表示的更改可能是破坏性的变更；非破坏性的表示更改根本不会发生。（我怀疑类似的理念也解释了为什么 [Node.js 中的重复依赖](http://stackoverflow.com/questions/25268545/why-does-npms-policy-of-duplicated-dependencies-work) 也能够如此成功。）

我不确定我对此的感觉如何。我个人非常信仰数据抽象，但我经常赞赏“一切皆为映射”的实用主义。（我之前在 [推特上发表过](https://twitter.com/ezyang/status/809704816150597633) 这个话题，引发了一些深思的讨论。）

**有害的 API。** 在演讲中的几个点上，Rich 嘲笑那些痴迷于从用户那里夺走功能的开发者。（“我讨厌这个函数。我讨厌它，我讨厌它，我讨厌人们调用它，我只是想让它从我的生活中消失。”）这忽略了无限向后兼容性之所以对我们今天编写的软件非常重要的原因。

无需更进一步，就能看到 Rich 所引用的具有几十年向后兼容性的 [系统](https://youtu.be/oyLBGkS5ICk?t=1h8m18s) ：Unix API、Java 和 HTML。在所有这些情况下，向后兼容性导致有害 API 长期存在，远远超出了它们应该存在的时间：[strncpy](https://randomascii.wordpress.com/2013/04/03/stop-using-strncpy-already/)、[gets](http://stackoverflow.com/questions/1694036/why-is-the-gets-function-so-dangerous-that-it-should-not-be-used)、HTML 的旧解析器（XSS）、[Java 反模式](http://www.odi.ch/prog/design/newbies.php) 等等。在 Android、C 库以及各个地方都有大量的例子。

在我看来，库的作者应该设计 API，使得正确操作变得容易，而错误操作变得困难。是的，这意味着有时候你需要阻止人们使用不安全或容易出错的库调用。

**语义化版本控制并不会导致级联的版本增加，缺乏版本范围才是问题的根源。** 在幻灯片 ["Do deps force Versioning?"](https://youtu.be/oyLBGkS5ICk?t=13m49s) 中，Rich 描述了 Clojure 生态系统中的一个问题，即遵循语义化版本控制时，一个包的新版本通常会导致系统中的级联版本增加。

尽管级联版本升级的问题是一个[真正的问题](https://github.com/mojombo/semver/issues/148)，适用于语义化版本控制的一般情况，但 Rich 在 Clojure 生态系统中提到的“级联版本升级”源于一个更为世俗的来源：最佳实践是在你的包元数据中[指定依赖的特定版本](https://nelsonmorris.net/2012/07/31/do-not-use-version-ranges-in-project-clj.html)。当依赖的新版本发布时，你需要升级包的版本，以便更新依赖的记录版本…… 等等。

我并不是在说 Clojure 用这种方式做事情是*错误的*（版本范围有它们自己的挑战），但在他的演讲中 Rich 暗示这是语义化版本控制的失败…… 事实并非如此。如果你使用版本范围，并且不习惯从你的依赖中重新导出 API，更新依赖的版本范围并不是一个破坏性的变化。如果你有一个求解器为整个应用程序选择一个库的单一副本，甚至可以在你的 API 中公开来自依赖的类型。

* * *

总的来说，我很高兴 Clojure 正在思考如何将向后兼容性放在首位：通常，最极端的应用原则的情况下，我们学到的最多。这是故事的结尾吗？不是；但我希望所有的语言都能慢慢向明确的规范和工具迈进，以帮助你实现自己的承诺。

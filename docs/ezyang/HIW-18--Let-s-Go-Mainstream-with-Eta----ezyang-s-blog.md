<!--yml

category: 未分类

date: 2024-07-01 18:16:54

-->

# HIW’18：让 Eta 走向主流！：ezyang’s 博客

> 来源：[`blog.ezyang.com/2018/09/hiw18-lets-go-mainstream-with-eta/`](http://blog.ezyang.com/2018/09/hiw18-lets-go-mainstream-with-eta/)

## HIW’18：让 Eta 走向主流！

我的名字是 Rahul Muttineni，TypeLead 的 CTO，致力于构建围绕一种名为 Eta 的语言的服务。为了开始，我将概述项目的起源和当前状态。

它起初是一个 HSOC 项目。当时它被称为 GHCVM；当时我们计划使其同时在 JVM 和 CLR 上运行...我们不再考虑 CLR 了。我由 Edward Kmett 指导。我们对此收到了非常好的反馈，所以 Jo 和我决定冒险全职工作在此上。

对 GHC 团队表示衷心的感谢，做得真的很好。我们已经与这个代码库一起工作了两年，随着工作的深入，我们看到了其中有多少令人惊叹的东西。通过与代码的互动，我学到了很多。

什么是 Eta？Eta 是 GHC 的一个分支。在 GSOC 项目期间，它起初是一个使用 GHC API 的 Haskell 程序。在项目的中途，我发现有些事情我想做但做不到，于是花了 3-4 天时间设置了一个分支。我会谈谈那些限制是什么。像 Haskell 一样，它是一种...语言，但其关键区别在于它在 JVM 上运行。这是它自己的一套挑战，主要是尾调用方面。Eta 的好处是它可以在 JVM 上运行，并且可以像那样运行大部分项目。最近，我们在上个月让 Yesod 运行起来了...它的状态很好。Eta 的下一个真正伟大的类型是强类型的 FFI。它与 JVM 中的子类型非常兼容，这个话题的大部分内容都是关于我们如何让它工作的。Eta 的一个主要关注点之一是专注于工业使用。GHC 则专注于工业使用和研究。两者之间存在紧张关系...对于 Eta 的好处是我们不必面对这种紧张关系；很容易做出决策来添加新功能，因为它会帮助公司吗？如果是的话，我们就会添加，否则不会。（SPJ：这可能是一个难以回答的问题！）

Haskell：不惜一切代价避免成功。我们不会为了好处而牺牲语言的核心原则。追求成功，以最小的成本。我们希望尽可能地成功，但是我们希望尽可能少地做出牺牲。这会有点棘手...

什么是 Eta？它支持哪些语言特性？它起初是 GHC 7.10.3 的一个分支。所有在那里工作的扩展，在 Eta 中同样适用。唯一的问题是 TemplateHaskell 和 QuasiQuotes 很长时间内都无法工作。我们在 3-4 个月前解决了这个问题。最大的变化是 JavaFFI。GHC 7.10.3 减去 C FFI。我们本来可以支持它：Java 有 JNI，但我们试图避免这样做，因为我们不想对所有的库做平台特定的绑定。

Joe 将一堆 GHC 8 的特性进行了回溯移植：StrictData、ApplicativeDo、OverloadedLabels。Backpack 是最近获取的。我们不得不这样做有一个非常特别的原因：这与我们默认没有绿色线程有关，我们希望给用户选择线程运行时与阻塞运行时的选择。

编译器？它是 GHC 的一个分支，所以所有编译器通道都是相同的。我们只是在 STG 之后截断了所有内容；例如，C--已经不存在了。我们从 STG 生成字节码。目前我们不进行任何优化，而且未来一段时间也不需要进行优化。我们不必这样做，因为在 JVM 中，它是即时编译的，所以我们不需要像以前那样进行大量优化，因为 JVM 会自动删除未使用的大量代码。关于驱动程序：GHC 生成对象文件...我们决定使用 JAR 文件。它们只是将大量存储 Java 字节码的类文件打包在一起的 ZIP 文件。我们还增加了一种 Uberjars 的模式。这些是将 JAR 文件打包成一个巨大的包。

我会简要谈一下我们如何实现 REPL；模板 Haskell。它通过外部解释器架构工作。在 GHC 中称为 iserv：该进程负责运行代码。因此，编译器仍将执行类型检查和一切工作，但一旦完成所有这些工作，GHC 将生成一个特定的字节码集，以便有效地解释 Haskell。因为我们已经生成了 JVM 字节码。我们不需要那个自定义的字节码集；我们只需关闭优化进行 JVM 字节码编译，然后将其发送到外部进程，加载并执行它们。实现 REPL 非常容易，如何让所有这些工作在一起。JVM 有一个称为类加载的机制，非常灵活。您可以从网络下载字节码，获取代码和运行时。一旦加载了类，它就是静态编译的代码，优化相同等等。

我们使用的构建工具是 **Etlas**。我们不想离开 GHC 太远，所以我们坚持使用 Cabal。在我们开始使用它的时候，我们从 Cabal 2.0 分支出来。主要区别在于它允许你管理 Eta 的版本。Etlas 几乎像 Stack，但它更接近 Cabal。我们将 Stack 的优秀特性加入到了 Cabal 中。另外一点是它进行补丁管理。随着我们添加更多功能并进行反向移植，我们发现 Eta 不完全是 GHC 7.10，也不是 GHC 8.0，它处于一种奇怪的中间状态，因此某些包在没有小改动的情况下不会精确编译，所以我们需要一些系统在实际运行构建之前应用这些改动。因此，我们设置了一个 GitHub 仓库来存储所有的补丁文件。Etlas 的工作方式是，它将为你获取最新的补丁集。然后如果你安装一个包，比如 lens，它将下载 lens，应用补丁，然后进行构建。就在最近，我们一直使用 base 4.8，最近升级到了 base 4.11。但我们无法更新到新的 Generics 架构，因为它会减慢编译时间。因此有一些包会检查它们是否是 GHC 8... 然后使用新的 Generics。所以我们必须为此做一些补丁。但这就是我们必须处理的那种事情。

这次讲座的标题是让 **eta** 成为主流。我想花一点时间说一下，这意味着什么？“被大多数人分享并视为正常或传统的思想、态度或活动。”那么编程语言在何时变得普遍或传统？它必须被大公司使用，解决大型现实世界问题，并且人们必须相信它有效。这是一个非常复杂的问题，多方面的，其中一部分答案是，它应该比现状更容易解决实际问题。举个例子，PHP 就是这样。PHP 是在没有更好的动态网页应用程序编程语言时出现的。它只具备了使其有用于构建这些应用程序所需的最低功能。现在大家都在问这个问题：Haskell 明显比现状更好地解决了许多问题。那么为什么它没有继续发展？这是一个很大的问题，我将讨论我们如何解决它。

我们内部使用的策略是戴上一顶“大公司的帽子”；我们假装自己是一个拥有大量员工、数百万或数十亿行代码的大公司，试图找出他们将面临的问题。一些问题包括构建庞大软件时的漫长构建时间，动态的情况需要确保初级开发人员能够快速上手... 等等。这是为了启动这场对话。

经过长时间的思考，我们将其简化为三个基本原则，我们将如何开发 Eta。

1\. 用户体验

2\. 性能

3\. 安全性

用户体验主要是一种情感体验，当您使用 Eta 技术时的感受，您与之交互时的感觉，当您遇到错误时的感受，心理上的反应。当某物具有良好的用户体验时，我们感觉很好。这是非常主观的事情，不同的人可能有所不同，我们必须找到一种标准化/普遍化的方式。作为软件和工具开发者，我们有时会忘记，开发软件的人是人类。如果他们长时间内不断遇到错误，他们会感到沮丧。机器会一遍又一遍地执行您告诉它们要做的事情。

所以在 Eta 中，我们关注了什么？我们最近做了一些事情；它还没有在主分支中。Jo 和我花了一周时间重构了类型检查器中的错误报告部分。它存储了一个字符串列表；在 GHC 内部，有一个漂亮打印的数据类型，一个这样的列表。问题是我们不能在其上进行后处理。因此，Jo 做的是创建了一个巨大的数据类型，有三百个数据构造器，每个构造器对应 GHC 中的一个错误消息。那个重构花了一周（SPJ：只有一周？！）现在是这样的，它是解耦的，现在你有了，而不是在类型检查 monad 中存储字符串，你存储了一个数据类型，用于存储打印出错误消息所需的相关数据。然后在最后一点，您可以遍历数据类型；根据其他错误的存在，您可以决定要做什么。现在是在某些错误模式上进行模式匹配并进行良好的报告。这是一个例子。我们谈到了简单的错误：重构，添加参数，更改类型，这是您使用 Haskell 时可能遇到的最常见的错误之一。因此，我们首先专注于这些。这显示了一个类型错误的例子... '检查器'，这是一个 IO 操作。

GHC 会告诉你，无法匹配 `Int -> IO ()` 和 `IO ()`。问题在于，对于不了解类型检查器工作方式的人，他们无法理解类型检查器的操作：逐个参数进行。由于我们进行了重构，很容易在这种特定情况下进行模式匹配，并说，嘿，如果用户忘记放置一个参数，可以打印出这种形式的错误消息。你打印一个参数丢失，你突出显示。（SM: 在这种情况下，你可能错过了第一个参数！）这是真的。这很棘手；有时您提供的建议可能不会。我们不告诉人们他们到底做错了什么，因为我们不知道。这不是一件完美的事情，但我们试图给出我们能给出的最佳建议。这的一个重要特征，大多数我们决定这个布局的方式，我们研究了像 Elm 和 Purescript 这样的语言，它们在这种错误上做了很好的工作。PureScript 和 Elm，它们为一种特定类型的错误所做的事情，如果您不确定该怎么做……例如，我们的信息不完整，他们可以转到特定的链接并查看可能发生的其他事情。因此，我们不必向用户提供每一个建议，我们只需向用户显示可能是其原因的东西。如果是一个棘手的案例，不是我们发布的，我们也会在链接中提到该案例。

(BG: 还有其他可能相关的信息；扩展类型同义词等。你有这些信息吗？) 我们还在考虑这个问题。可能我们会有额外的标志和其他东西。最终，我们将有一个模式，用于 IDE 打印 JSON，这样在 IDE 端更容易解析。(BG: 顺便说一下，有一个学生和理查德一起工作，试图找出类似的东西。)

用户体验的另一个方面是我们添加了 REPL。试图简化入口点，试图使其更容易。你想要类型、种类以及如何找到更多信息。这是一种静态类型语言：你总是要考虑类型。所以我们:set +t：打印出你打印东西时的类型。还有一件事，前 Scala 工程师之一一直在学习 Haskell，并对 REPL 体验的一个方面提出了批评。f 是一个有两个参数的函数。在 REPL 的第二条语句中，我应用了 1\. 找到实例，显示实例，对于 a 转到 a。他说……没有找到显示实例，只是说这是一个函数，你不能打印它。这是我们所做的改变。这对我们来说非常容易做到。

性能：它可以指很多事情。我们讨论的是快速的开发者反馈循环。编译时间和开发时间，减少这种反馈循环。在这方面我们做了一些工作是可重现构建。截至目前，我们在 Eta 中实现了 bit-for-bit 的可重现性。这相当于……尼基塔已经在可重现性方面做了大量工作，他使 Haskell 接口可重现；但最后一英里的 bit-for-bit 非常困难，有很多地方。对于我们的代码生成器来说，情况简单得多，我们不需要做太多工作。只需 20 行代码就能使其确定性。GHC 中的主要非确定性来源是 Unique 数据类型，它在不同的运行环境下会发生变化。我们所做的是添加了一个计数器。我们曾经在 Java 类名中打印 uniques；这将使其变得不确定。所以我们做了一个计数器：将绑定按照进入 STG 的顺序排列相同。

GHCi 以其占用大量内存而闻名，尤其是在使用 IDE 时。**Simon Marlow** 对此做了许多修复；我们也进行了这些修复的回溯。

性能的另一个方面是实际的运行时性能。我们使用的是 JVM，这让我们处于一个巨大的劣势。我们无法控制许多事情。运行时系统……这是 Java。它是面向对象的，所以运行时系统是用 Java 实现的。我们为在 Eta 中定义的值设置了一个层次结构。我们有一个 Closure 类，它是所有值、thunk、WNF 的父类。Closure 类有两个方法。evaluate，评估到 WHNF，enter 实际上会进入……这与 GHC 运行时系统相似。最初的版本完全模仿了 GHC，除了尾调用。术语是相似的。它主要用于函数主体时。Closure 的主要子类是 Thunk 和 Value。Value 将是诸如函数、部分应用函数和数据构造函数之类的事物的父类。Thunk 将是诸如 CAFs、单入口 thunk 和可更新 thunk 的超类。CAF 没有自由变量，因此有一个特例，每次创建一个 blackholing entry，以避免两个线程评估相同的 thunk。UpdatableThunk 在完成评估时会推送一个更新帧，将 thunk 更新为新计算的值。SingleEntryThunk 只评估一次，因此可以直接评估它而不推送更新帧。这些术语也是从 GHC 借来的。

VAlues: DataCon, Function and PAPs. 在早期，甚至现在，每次尾递归调用都只是一个方法调用。这是使其稍微有效的唯一方法。（关于堆栈的更多信息很快就会出现）。对于静态尾递归调用：单递归或互递归，它们会被编译成循环。在大多数情况下，它们会得到一个紧凑的循环。在互递归的情况下，会发生的是，我们收集所有的 SCC，并制作一个进入循环的巨大方法。假设你在偶数/奇数示例中，会发生的是，当偶数调用奇数时，有一个名为目标的变量，一个整数。偶数将被分配为 0，奇数分配为 1，然后设置 1 并重新启动。（BG: 您编译的函数总是有展开可用吗？）这是在同一模块中定义的互递归函数。（SPJ: 它们可能有非常不同的类型参数。）我们将所有参数连接成一个。这个参数的主要问题是，使用 Happy 和 Alex 生成的解析器，我们会遇到限制。（BG: 崩溃？）不是堆栈溢出。JVM 有方法大小限制，所以你只能有 65000 个字节码。这是 Eta 与自身编译的情况。这是唯一阻止我们使用 Eta 的东西。但你需要做的就是将方法分成更小的块。

那么我们如何处理尾调用？当我们知道它，尾递归，假设你不知道。假设你正在使用 CPS。在 Haskell 中，这是如此普遍，任何快速解析器都使用 CPS。在早期，Aeson 只会爆栈，情况非常糟糕。因此，我们默认探索了 trampolining，但那太糟糕了，非常慢。我们所做的是关闭它，让栈溢出。我们找到了一个更好的解决方案。JVM 有...卷栈的唯一方法是抛出异常，或者返回，并继续返回直到完全返回。结果是，通过异常，你可以关闭捕获堆栈跟踪的功能：这是异常中最昂贵的部分。所以我们有一个通用异常。因此，这种 trampoline 机制是可选的。所以，我们有一个函数'trampoline :: a -> a'，运行时原语，它的作用是在上下文中激活一个布尔值，告诉它现在要跳跃，它激活一个代码路径来转换计数器，一旦达到一个可配置的特定数字，它将解开栈，然后继续它所需去的地方。我们的限制是 400，然后我们解开。它曾经在 1000 多个的时候，但是使用 Happy 和 Alex 后，我们需要一个更小的数字。（BG：在这种情况下，成本如何？但观察起来更快。几个月前，我们让 PureScript 在 Eta 上工作，并不是默认的坏？）（SPJ：因此，您可以默认启用它：您所做的只是计数。）计数是我们知道堆栈有多大的方式。在您的主函数中，您可以调用 trampolineIO，并使整个程序跳跃。（SPJ：也许开销很低，您可以随时这样做。）如果低，我们会这样做。（你如何恢复？一旦引发异常，你存储什么？）计数器发生在入口点，并由布尔值保护。因此，如果超出了限制，它将调用另一个接受上下文的函数。因此，我们将所有参数存储在传递给每个 eta 函数的上下文变量中。我们将所有参数存储在一个具有状态的函数中，然后当它解开时，由这个函数标记，它将使用该函数和这些参数调用那个。

如我所提到的，它由一个布尔值来保护。JVM 有一个优化，当它观察到布尔值在许多时刻为 true 时，它甚至不会编译本地代码中的该分支。因此，如果你不使用 trampolining，它对你没有任何影响；计数器的代码将不会存在。

我喜欢 Eta 的一个好处是，你实际上可以获得异常的堆栈跟踪。这是因为，为了让 Eta 有良好的性能，你必须在 JVM 栈上实现大多数原语。这是一个示例堆栈。你有一个调度循环，你正在评估一些 IO 行动。applyV/applyN，这些是部分应用。执行一个 IO 行动。还有一个不错的地方，我们尝试将其编码接近原始名称。因此，你可以看到这个函数调用发生在 statistics.Regression、rnfAll 中。如果你看到，你会注意到有行号。这并不完美，但我们肯定可以稍后做得更好…… GHC 在 STG 时间给了你很多调试信息，但因为 JVM 没有太多的灵活性，我们只能将一个行号附加到代码中，所以我们必须丢弃所有那些信息。这将会变得更好；我们将把调试信息存储在类文件本身中，然后访问它并呈现更好的堆栈跟踪。（BG：这是源注释吗？）是的。

并发性：一个好处是，它是好的还是不好的。如果你正在评估一长串 thunk，你将会耗尽栈空间。这恰好与 GHC 也有空间泄漏的情况相吻合。Neil Mitchell 写了一篇关于如何检测空间泄漏的博文：限制堆栈大小，然后找出正在评估的 thunk。如果你看到这样的堆栈跟踪，并且看到一个巨大的评估链，在一个长链中，你可能有一个空间泄漏。

我如何进行互操作？我们进行互操作的方式是，做了一个叫做 Java monad 的东西。它应该给你编程 JAva 的体验。基本实现受到 IO monad 的启发。Object# c 是“this”，即正在传递的对象。由于这种编码，你得到了 Java 的体验：你可以在 Java 对象上调用点操作符。几乎就像在内部使用 Java 一样。这个参数被称为……这是迫使我们分叉而不是使用 API 的类型构造器。你不能在 API 中声明原始类型。我们不得不引入一个新的低级表示。声明包装器类型，包装 Java 中的 iterable 接口。我们偷了更好的语法，这些是类型应用……以某种方式解决它。我正在声明一个 Eta 类型，包装一个 JAva 类型，@java.lang.Iterable。

你使用 java 函数来运行 Java monad。所有这些都必须被导入。newArrayList，newInteger，但我们引入了一些组合子，让你调用方法。它与 monad 相匹配。这是一个做与 Java 代码相同事情的示例代码。它只是使用标准的 monadic 组合子。如果它是一个固定的 c，那么它是一个实例。

你可以使用 Eta 作为更好的 JAva，具有引用透明性！与 Kotlin 或 Scala 不同。

如何处理子类型？我们通过内建类型家族来定义。我们有一个名为 extends 的类型类。每当你声明一个函数，它接受一个给定类及其任何子类型时，你可以使用约束条件而不是实际的子类型。extends 从 inherits 中获取信息并进行计算。你可以对任何 Iterator 子类使用点操作符。我们不得不稍微扩展类型检查器：很多时候，类型会被卡在 Extends' (List JSTring) (List a)的形式中，其中 a 是无约束的。

导入是令人厌烦的，所以我们正在设置直接的 Java 互操作性；实际上使用 Java 反射获取信息类文件，并生成导入。"import java java.lang.Math"虽然有效，但不可扩展。今年剩下的最重要的优先事项是 Java 互操作性，真正好的 IDE 支持，文档，语言扩展：UnboxedSums，TypeApplications，DerivingVia，QuantifiedConstraints。我们还有一些新的语言扩展在计划中，AnonymousRecords，RowTypePolymorphism...我们会看看会怎样。

我正在考虑方法……我们在同一个代码库上工作，如何进行协作？我们对编译性能感兴趣，支持 unboxed sums。Worker wrapper 有一些小问题，但还没有人来解决。在某个时候，也许不是很快的时候，还有可变字段。这对我们非常重要。（BG：Unboxed sums 使用频繁吗？为什么 unboxed sums？Eta 代码经常使用吗？）不，但很多 JVM 上的人对 Maybe 总是装箱感到恼火。但如果你有 unboxed sums，你可以将其表示为 null。（SPJ：或者你可以说，只需将其装箱，你就不会注意到它。如果始终如此快速，专注于能够产生差异的事物。）

Q: 你考虑过使用 Graal 吗（它是一个支持部分评估和部分逃逸分析的新虚拟机，非常适合函数语言）？

A: 我们研究过，但目前还不完全可以使用，我们也不确定是否值得投入时间。我们一直在关注它。（BG：但你失去了 JVM！）这是阻止我们前进的因素。也许如果它被集成到主流 VN 中，我们可能会考虑。 （主流 Java 正计划集成 Graal）

Q: （SM）你们是否将分支与主 GHC 保持更新？

A: 对于我们来说，有一件事情很难做到，长期以来，那就是所有依赖的 Haskell 工作。其他所有事情，我们都在跟进。如果有任何好的 bug 修复...（SM：所以你们是有选择性地回溯）。

Q: （BG）你考虑过解除 fork 吗？

A: 还没有，没有。

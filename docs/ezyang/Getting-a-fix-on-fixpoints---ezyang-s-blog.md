<!--yml

category: 未分类

date: 2024-07-01 18:18:01

-->

# Getting a fix on fixpoints : ezyang’s blog

> 来源：[`blog.ezyang.com/2010/12/getting-a-fix-on-fixpoints/`](http://blog.ezyang.com/2010/12/getting-a-fix-on-fixpoints/)

以前，我们已经 [绘制了各种 Haskell 类型的哈斯图](http://blog.ezyang.com/2010/12/hussling-haskell-types-into-hasse-diagrams/)，从数据类型到函数类型，并查看了 [可计算性和单调性之间的关系](http://blog.ezyang.com/2010/12/gin-and-monotonic/)。事实上，所有可计算函数都是单调的，但并非所有单调函数都是可计算的。是否有某些函数描述涉及可计算性？是的：*Scott 连续函数*。在这篇文章中，我们将探讨定义*连续性*所需的数学机制。特别地，我们将研究最小上界、链、链完备偏序集（CPOs）和域。我们还将研究连续函数自然产生的不动点。

* * *

在我们之前的类型图中，我们让值以省略号一直延伸到无穷远。

正如几位评论者所指出的，这并不完全正确：所有的 Haskell 数据类型都有一个或多个顶值，即不小于任何其他值的值。（注意，这与大于或等于所有其他值的值不同：某些值是不可比较的，因为我们讨论的是*偏序*。）在 Nat 的情况下，有许多顶值：Z、S Z、S (S Z)，等等是你可以得到的最明确的。然而，还有一个更多：`fix S`，又名无穷大。

在这个值中没有潜伏的底部，但它似乎有点奇怪：如果我们去掉一个 S 构造子（减少自然数），我们又回到了 `fix S`：显然，无限减一还是无限。

实际上，`fix S` 是链 ⊥, S ⊥, S (S ⊥)... 的最小上界。链只是一个值序列，其中 d_1 ≤ d_2 ≤ d_3 ...；它们是我们绘制的图表中向上移动的线条。

自然数的链 0 ≤ 1 ≤ 2 ≤ ... 尽管没有 0 ≤ 1 ≤ 2 ≤ ... 的上界，但自然数有许多最小上界，因为每个元素 n 形成平凡链 n ≤ n ≤ n...

在偏序集中，链不一定有最小上界。考虑具有通常偏序关系的自然数。

链 0 ≤ 1 ≤ 2 ≤ ... 没有上界，因为自然数集合不包含无穷大。我们必须转向 Ω，这是自然数和最小可能的无穷大，序数 ω。

这里链有一个最小上界。

> 尽管 0 ≤ 1 ≤ 2 ≤ ... 没有 0 ≤ 1 ≤ 2 ≤ ... 的上确界，自然数有许多最小上界，因为每个元素 n 形成平凡链 n ≤ n ≤ n...

* * *

这里是一些上界的图形表示。

如果一个链始终小于或等于另一个链，那么该链的上界小于或等于另一个链的上界。

双上界链的工作方式与您预期的方式相同；此外，我们可以对这条链进行对角线处理，以获取两个方向的上界。

* * *

所以，如果我们回想起先前绘制的任何图表，在任何地方有一个“...”，实际上我们可以在顶部放置一个上界，这归功于 Haskell 的惰性。以下是列表类型中具有最小上界的一个链：

正如我们前面看到的，对于所有偏序来说，这并不总是成立，因此我们为总是具有最小上界的偏序赋予了一个特殊的名称：*链完备偏序*或 CPO。

您可能还注意到在每个图表中，⊥位于底部。这也不一定适用于偏序。我们将称具有底部元素的 CPO 为*域*。

（术语*域*实际上在指示语义文献中被相当宽松地使用，许多时候具有超出此处给出的定义的额外属性。我从 Marcelo Fiore 的指示语义讲座中使用了这个最小定义，并且我相信这是域的 Scott 构思，尽管我尚未验证。）

因此，实际上我们一直在处理域，尽管我们一直忽略最小上界。我们将发现，一旦考虑了上界，我们将找到一个比单调性更强的条件，即可计算性。

* * *

考虑以下 Haskell 数据类型，它表示垂直自然数 Omega。

这是一个不可计算的单调函数。

为什么它不可计算？这要求我们对任意大的数和无穷大有不同的处理方式：在有限自然数和无穷大之间存在不连续性。从计算的角度来看，我们无法在有限时间内检查任何给定值是否实际上是无穷大：我们只能不断剥离 Ws，并希望我们不会达到底部。

我们可以如下形式地正式化：一个函数`D -> D`，其中 D 是一个域，如果它是单调的并且保留最小上界，则称为*连续*。这并不是说所有上界都保持不变，而是说如果 e_1 ≤ e_2 ≤ e_3 ...的上界是 lub(e)，那么 f(e_1) ≤ f(e_2) ≤ f(e_3) ...的上界是 f(lub(e))。符号化地：

图形化地表示：

* * *

现在是查看不动点的时候了！我们直接跳到要点：Tarski 的不动点定理声明，连续函数的最小不动点是序列⊥ ≤ f(⊥) ≤ f(f(⊥)) ...的最小上界。

因为函数是连续的，它被迫保持这个最小上界，自动使其成为一个固定点。我们可以将这个序列看作是给我们提供固定点的越来越好的逼近值。事实上，在有限的定义域内，我们可以利用这个事实来机械地计算函数的精确固定点。

我们将首先查看的函数并没有非常有趣的固定点。

如果我们将底部传递给它，我们得到底部。

这里有一个稍微有趣的函数。

从定义上并不明显（尽管在哈斯图上看起来更明显），这个函数的固定点是什么。然而，通过重复在 ⊥ 上迭代 f，我们可以看到我们的值发生了什么变化：

最终我们会达到固定点！更重要的是，我们已经达到了最小的固定点：这个特定函数有另一个固定点，因为 f (C ()) = C ()。

为了完整起见，这里还有一个集合。

* * *

我们可以从这些图表中看到为什么塔斯基的固定点定理可能有效：我们逐渐向上移动定义域，直到我们停止向上移动，这就是固定点的定义，并且由于我们从底部开始，我们最终得到最小的固定点。

有几个问题需要回答。如果函数将值向下移动会怎样？那么我们可能会陷入无限循环。

然而，我们是安全的，因为任何这样的函数都会违反单调性：对于 e₁ ≤ e₂的循环将导致 f(e₁) ≥ f(e₂)。

我们的有限例子也是全序的：我们的图表没有分支。如果我们的函数将一个分支映射到另一个分支（这是完全合法的操作：考虑`not`）会怎样？

幸运的是，要*达到*这样的循环，我们必须打破单调性：从一个分支跳到另一个分支意味着某种程度的严格性。这种情况的特例是，严格函数的固定点是底部。

* * *

固定点的**典范**示例是递归函数的“Hello world”：阶乘。与我们之前的例子不同，这里的定义域是无限的，因此需要无限次地应用 f 才能得到真正的阶乘。幸运的是，计算阶乘`n!`只需要`n`次应用。请记住，阶乘的固定点风格定义如下：

```
factorial = fix (\f n -> if n == 0 then 1 else n * f (n - 1))

```

下面是阶乘函数的定义域随着连续应用的增长方式：

鼓励读者验证这是否为真。[下次](http://blog.ezyang.com/2010/12/omega-i-m-lubbin-it/)，我们将不再看自然数的平面域，而是看垂直域的自然数，这将很好地将我们迄今为止涵盖的许多内容联系在一起。

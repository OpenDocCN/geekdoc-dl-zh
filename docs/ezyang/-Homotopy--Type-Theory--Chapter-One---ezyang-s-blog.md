<!--yml

类别：未分类

日期：2024-07-01 18:17:21

-->

# （同伦）类型论：第一章：ezyang’s 博客

> 来源：[`blog.ezyang.com/2013/06/homotopy-type-theory-chapter-one/`](http://blog.ezyang.com/2013/06/homotopy-type-theory-chapter-one/)

现在看来已经是老生常谈的事情了，智库的人们发布了《同伦类型论：数学的同构基础》。有一些（元）评论（[丹·皮波尼](https://plus.google.com/107913314994758123748/posts/VzWAsojiifE)，[鲍勃·哈珀](http://existentialtype.wordpress.com/2013/06/22/whats-the-big-deal-with-hott/)，[安德烈·鲍尔](http://math.andrej.com/2013/06/20/the-hott-book/)，[弗朗索瓦·G·多雷](http://dorais.org/archives/1425)，[史蒂夫·奥威迪](http://homotopytypetheory.org/2013/06/20/the-hott-book/)，[卡尔洛·安朱利](http://www.carloangiuli.com/blog/homotopy-type-theory-univalent-foundations-of-mathematics/)，[迈克·舒尔曼](http://golem.ph.utexas.edu/category/2013/06/the_hott_book.html)，[约翰·贝兹](https://plus.google.com/117663015413546257905/posts/cm1sKge8qxX)），尽管在互联网上进行数学教科书的阅读需要时间，所以不要指望非作者能够提供详细的技术评论一段时间。

当然，作为一个渺小的研究生，我当然对书中“再次马丁·洛夫直觉性类型论介绍”贡献最感兴趣，例如第一章。经典的介绍当然是马丁·洛夫写的论文（请注意：这篇论文有许多版本，所以很难找到合适的版本，尽管看起来乔瓦尼·桑宾的笔记最容易找到），但是为了“同伦类型论”的类型论介绍必须做出某些调整，这导致了一些新颖的呈现。特别是，章节讨论的“同一性类型”比我在其他地方看到的要详细得多（这并不奇怪，因为同一性对同伦类型论至关重要）。在讨论构成该理论的类型时，也有相当多的学术细节/结构，让人想起了《PFPL》（尽管我相信这一特定章节大部分是由其他人撰写的）。当然，在理论如何实际组合和详细解释方面也有许多小的变化，在章节注释中也进行了详细阐述。

更详细地说：

**定义性和命题性相等性。** 章节花了一点时间仔细区分了定义性相等性（纯语法概念，通过计算）和命题性相等性（涉及证据），这一点我很赞赏。当我最初学习逻辑时，内部和外部推理系统中出现的连接词的差异是我困惑的主要点。

**引入新类型的一般模式。** 引入逻辑连接词的现代风格是将规则分类为各种类型，例如引入规则和消除规则，然后在展示中坚持这种规律性。通常，读者被期望“看到它”，但这本书通过一个有用的备注阐述了这种风格。我发现一个有用的练习是将规则重新组织，例如将所有的消除规则放在一起并进行比较。

**递归和归纳。** [我之前写过关于这个主题的文章](http://blog.ezyang.com/2013/04/the-difference-between-recursion-induction/)，主张递归和归纳并不是同一回事，因为归纳需要针对索引类型进行操作。这是正确的，但我没有提到一个重要的观点：*归纳是广义的递归*。这是因为当你将类型族 *P* 指定为*常数类型族*，它忽略其索引时，依赖关系被抹去，你得到了一个普通的递归器。事实上，这是一个[CPDT 练习](http://adam.chlipala.net/cpdt/html/InductiveTypes.html)；我认为在 Coq 和非正式数学中看到这一点可以澄清事情的广义维度。

**恒同类型。** 我不会撒谎：我在这一部分遇到了一些困难，即使在这一部分的最后有一个非常长的注释，我仍然不完全理解路径归纳为什么起作用。（此外，尽管注释指向一些关于该主题的文献，我看了这些论文，但没有看到任何类似于他们对路径归纳的呈现。）默认情况下，Coq 认为等同类型的归纳原则应该是这本书所说的相同者的不可辨认性：

```
> Check eq_rect.
eq_rect
     : forall (A : Type) (x : A) (P : A -> Type),
       P x -> forall y : A, x = y -> P y

```

（顺带一提，家族 *C* 的使用有些混乱；当讨论前面原则的泛化时，读者需要想象 `C(x) -> C(y)  ===  C(x, y)` ——这些 C 显然是不同的。）路径归纳要求更多：

```
eq_ind
     : forall (A : Type), forall (C : forall (x y : A), x = y -> Type),
       (forall (x : A), C x x (eq_refl x)) -> forall (x y : A), forall (p : x = y), C x y p

```

这也许并不太令人惊讶，因为这些机制主要受同伦类型理论的驱动。此外，归纳原则遵循与为其他类型定义的其他归纳原则相同的模式。问题在于对为什么这个归纳原则有效的沮丧讨论，即使在 HoTT 设置中，你可能期望，并非所有的相等性都是通过自反性证明的。我对此的理解是与`forall (x : A)`量化器的放置有关。允许将其中一个 x 移动到顶层（基于路径归纳），但不能*两者都移动*。（这在变量名称的重用中有些模糊。）还有一种几何直觉，即当路径的两个端点都是自由的（内部量化）时，我可以将路径收缩为空。但我很难将这一点映射到任何严格的论证上。也许你能帮助我搞清楚。

> 作为旁注，我对从函数式编程背景学习类型理论有一些一般性的评论。我注意到，即使不了解太多类型理论，使用 Coq 也不是太难，而且更容易错过类型理论可能有帮助的点。但最终，理解发生的事情真的很有用，因此研究为什么依赖积和和广义的依赖和一般化方式的原因是非常值得的。看起来人们对 pi 和 sigma 符号感到困惑：如果意识到它们是代数双关语，会有所帮助。不要跳过归纳原则的定义。

如果本帖有任何不准确或误导性的倾向，我深感抱歉。我总体上的印象是，这一章对类型理论是一个非常清晰的介绍，但是关于同一类型的部分可能有点难以理解。现在，继续看第二章吧！

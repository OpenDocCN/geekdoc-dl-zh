<!--yml

category: 未分类

date: 2024-07-01 18:17:58

-->

# 对受检异常和证明义务的看法：ezyang's 博客

> 来源：[`blog.ezyang.com/2011/02/on-checked-exceptions-and-proof-obligations/`](http://blog.ezyang.com/2011/02/on-checked-exceptions-and-proof-obligations/)

Java 中的受检异常是一个非常受批评的特性，尽管理论上它应该是一个非常好的主意。其中的张力在于这两种推理之间：

> 精心编写的程序处理所有可能的边缘情况，如果可能的话，对其进行处理，并在无法处理时优雅地失败。很难跟踪*所有*可能的异常，因此我们应该让编译器帮助我们，提醒我们是否有我们忘记处理的边缘情况。因此，受检异常提供了一种机制，确保我们已经处理了所有边缘情况。

and

> 频繁检查的异常是我们在接近错误位置无法合理恢复的错误条件。将受检异常通过所有中介代码传递需要每一层了解其所有异常。受检异常的心理设计鼓励开发人员不负责任地吞下异常。受检异常在大量代码中不可扩展。

在这篇文章中，我提出了另一种管理受检异常的方法：证明代码*不可能*抛出这样的异常。

“证明代码不可能抛出异常？”你可能会说。“不可能！毕竟，大多数受检异常来自外部世界，我们肯定不能预测将会发生什么。恶魔可能会选择最坏的情况并将其输入到我们的代码中。”

对怀疑论者的第一个回答是确实存在完全确定性发生的受检异常的例子，并且可以证明不会抛出。例如，考虑 Java 反射 API 中的这段代码：

```
Object o, Field f; // defined elsewhere
f.setAccessible(true);
f.get(o);

```

最后一次调用可能会抛出受检异常`IllegalAccessException`，但假设`setAccessible`调用未失败（在多种条件下可能失败），这个异常不会发生！因此，实际上，即使它*确实*抛出了`IllegalAccessException`，它也违反了我们程序员对 API 应该执行的期望，而一个漂亮的运行时错误会让我们注意到发生了什么。`setAccessible`的调用*解除了对`IllegalAccessException`情况的证明义务*。

但这可能只是在一个以 IO 为主的检查异常世界中的一个边缘案例。所以我对质疑者的第二个回答是，当我们编写与外部世界交互的代码时，我们通常并不假设恶魔会给我们提供最糟糕的输入数据。（也许我们应该假设！）我们有自己内部的模型来预测这些交互可能如何工作，如果写一些快速而粗糙的东西，假设交互会按照某种方式进行可能会很方便。因此，一旦我们编写了所有的验证代码以确保这确实如此（如果不是的话，抛出类似于失败的断言的运行时异常），我们再次可以假设静态知识可以解除我们的证明义务。是的，在某种程度上这是一种逃避，因为我们没有证明任何东西，只是告诉编译器，“我知道我在做什么”，但关键的额外因素是，一旦我们建立了我们的假设，我们就可以用它们来证明事实，而且只需要在运行时检查我们的假设。

当然，Java 不会很快引入依赖类型，所以这都是一场相当理论性的讨论。但是检查异常，就像类型一样，*是*形式化方法的一种形式，即使你不是用依赖类型语言编写你的应用程序，该领域能够为你的应用程序的基本结构提供有用的见解。

### 资源

我在听康纳·麦克布赖德（Conor McBride）关于[《命运的荒谬箭头》](http://personal.cis.strath.ac.uk/~conor/GUtalk.pdf)的讲座时，突然间对检查异常与证明之间的对应关系有了一些想法。希望能尽快撰写关于这次讲座的总结；它阐明了我一直在思考的一些关于会话类型的问题。

在描述现有的 Java 检查异常观点时，我参考了以下文章。

<!--yml

类别：未分类

date: 2024-07-01 18:17:37

-->

# 你本可以发明分数级联：ezyang 的博客

> 来源：[`blog.ezyang.com/2012/03/you-could-have-invented-fractional-cascading/`](http://blog.ezyang.com/2012/03/you-could-have-invented-fractional-cascading/)

假设你有*k*个排序数组，每个数组的大小为*n*。你想要在每个*k*个数组中搜索单个元素（或其前一个元素，如果不存在）。

显然，你可以分别对每个数组进行二分搜索，结果是 ![O(k\lg n)](img/lg n") 的运行时间。但我们可能认为我们可以做得更好：毕竟，我们在每次搜索时都做了相同的搜索，也许我们可以“重复使用”第一次搜索的结果。

下面是另一种显而易见的方法：对于第一个数组中的每个元素，让我们给它一个指向第二个数组中具有相同值的元素的指针（或者如果值不存在，则指向前一个元素）。然后，一旦我们在第一个数组中找到了这个元素，我们只需按顺序跟随这些指针就可以找出这个元素在所有其他数组中的位置。

但是有一个问题：有时，这些指针对我们毫无帮助。特别是，如果后面的列表完全“处于”第一个列表的两个元素之间，我们必须重新进行整个搜索，因为指针没有给我们任何我们不已经知道的信息。

那么我们该怎么做呢？考虑*k=2*的情况；如果我们能保证第一个列表包含了能为第二个数组提供有用信息的正确元素，那么一切都会好转。我们可以简单地合并这些数组，但如果我们在一般情况下这样做，我们最终会得到一个大小为![kn](img/b2931d4dac72237e5ab420c094722a83.png "kn")的完全合并数组，如果*k*很大，这并不理想。

但我们并不需要第二个数组的所有元素；每隔一个元素就够了！

让我们重复这样做。取最后一个数组，取每隔一个元素并合并到倒数第二个数组中。现在，对于新的倒数第二个数组，对下一个数组执行相同操作。反复这样做。第一个数组最终会有多大？你可以解决这个递归式：![T(k) = n + T(k-1)/2](img/ae7430846af6a2f79ef9b1e4192acce5.png "T(k) = n + T(k-1)/2")，这是等比级数 ![n + n/2 + n/4 + n/8 + \ldots = 2n](img/ldots = 2n")。令人惊讶的是，新的第一个列表仅增加了两倍的大小，这只是二分搜索中的一个额外步骤！

我们刚刚实现的就是**分数级联**！数组中的一部分级联到其他数组中。

还有一个需要注意的细节。当我沿着指针向下跟随时，我可能会落到一个实际上不是当前数组成员的元素上（它是被级联上来的）。我需要能够有效地找到下一个属于当前数组的元素（可能有许多级联元素挤在它和下一个成员元素之间，因此进行左扫描可能需要很长时间）；因此，对于每个级联元素，我存储一个指向前任成员元素的指针。

分数级联是一种非常有用的转换，应用于各种上下文中，包括*分层范围树*和*3D 正交范围搜索*。实际上，它可以通过几种方式进行泛化。首先，我们可以级联某个固定的分数α的元素，而不是我们这里所做的 1/2。此外，我们不必局限于将数组列表级联起来；我们可以级联任意图形，将许多列表合并在一起，只要我们选择α小于*1/d*，其中*d*是节点的入度。

*练习.* 之前，我们描述了[范围树](http://blog.ezyang.com/2012/02/visualizing-range-trees/)。分数级联如何用于将查询复杂度减少一个因子![O(\lg n)](img/lg n)")？

*练习.* 实际上，我们可以通过另一种方式设置分数级联数据结构中的指针。与其为每个元素保留向下指针，不如仅在相同的元素之间维护指针（也就是说，它们被级联上来了）。当构建数据结构时，这种方式更为方便。但是，现在你需要维护另一组指针。它们是什么？（提示：考虑搜索落在非级联成员元素上的情况。）

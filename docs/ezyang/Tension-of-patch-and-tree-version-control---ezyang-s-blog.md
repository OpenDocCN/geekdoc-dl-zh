<!--yml

category: 未分类

日期：2024-07-01 18:18:09

-->

# 补丁和树版本控制的张力：ezyang 的博客

> 来源：[`blog.ezyang.com/2010/09/tension-of-patch-and-tree-version-control/`](http://blog.ezyang.com/2010/09/tension-of-patch-and-tree-version-control/)

*本文并非对 Darcs 的抨击，而是对两种版本控制哲学差异的观察。另外，我对 Darcs 还有些陌生，因此可能存在一些事实不准确的地方。请指出来！*

我希望有一天能写一篇*给 Git 用户的 Darcs 指南*，总结我作为一个高级 Git 用户在与 Darcs 搏斗时的经验。但或许最重要的一点是：*不要试图把 Git 的底层存储模型套用在 Darcs 上！*一旦我意识到这一点，我发现 Darcs 与我偏爱的 Git 开发风格——持续变基本地补丁直到它们被提交到官方仓库——非常契合。

这种变基工作流是如何运作的？尽管名字有些滑稽，但它是一个早于版本控制的通用工作流：核心操作是*提交一个补丁*。也就是说，在完成编码、重新编译并清理完你的修改后，你会拉取仓库的原始副本，生成一个统一的 diff，并将其发送到官方邮件列表。如果统一的 diff 不能干净地应用于官方开发版本，上游会要求你将补丁应用到软件的新版本上。

Git 通过*变基*优化了这一工作流。顾名思义，你正在改变应用补丁的基准提交。补丁的身份比仓库的“历史”更重要。交互式变基允许你重新排序补丁，并将历史切割成供上游阅读的漂亮形式。

由于 Git 同时支持基于树和基于补丁的工作流，两种思想之间的张力是显而易见的。在衍合时，旧的提交对象变得无法访问，你必须依赖像 reflog 这样的机制来检索旧树。良好的实践是永远不要对已发布的仓库进行衍合，因为一旦发布，一致的历史比漂亮的历史更重要。

Darcs *仅支持* 基于补丁的工作流。像在衍合时必须保持补丁的良好排序那样，这很难做到，但也没必要：`darcs send --dry-run` 会让你知道本地的哪些补丁还没放入上游仓库，在进行任何有趣的命令时，都需要用 `-p` 明确指定你所引用的补丁。Darcs 可以轻松合并和拆分补丁，即使它们深埋在你的 `darcs changes` 日志中也可以编辑旧补丁。

不过，有时我确实会想念基于树的模型：特别是，虽然接近很容易，但却没有简单的方法来准确获取仓库两天前的结构（比如说，你的构建仍在工作时）。Git 显式地将仓库的任何给定状态实现为一个树对象，这使得补丁抽象变得不那么流畅，但意味着你将*永远不会丢失提交的数据*。不幸的是，对于 Darcs，没有“特定仓库状态”的简写；你可能会注意到 `darcs send` 必须明确列出你要发送的特定补丁之前的*每一个*补丁。从这个角度看，我认为 Darcs 做了太多的工作：虽然最近的 N 次更改应该被视为补丁而不是树的快照，但我可能不太关心项目的古老历史。Darcs 已经通过标签支持了这一点，但我在像 GHC 这样快速移动的仓库上的经验告诉我，你也希望有一个标签时间线来跟踪最新的“官方”仓库 HEAD。

关于冲突解决的主题也有，但由于我还没有遇到任何复杂的情况，这里我就少说几句。

<!--yml

category: 未分类

date: 2024-07-01 18:18:16

-->

# 设置 Cabal、FFI 和 c2hs：ezyang 的博客

> 来源：[`blog.ezyang.com/2010/06/setting-up-cabal-the-ffi-and-c2hs/`](http://blog.ezyang.com/2010/06/setting-up-cabal-the-ffi-and-c2hs/)

这是 [c2hs 六部分介绍的第二部分](http://blog.ezyang.com/2010/06/the-haskell-preprocessor-hierarchy/)。今天，我们讨论的是首次编译这个该死的东西。

*读者先决条件.* 你应该知道如何为纯 Haskell 编写、配置和构建一个普通的 Cabal 文件。幸运的是，通过 [cabal init](http://byorgey.wordpress.com/2010/04/15/cabal-init/)，现在比以往任何时候都更容易。我将讨论如何为链接 C 文件设置 Cabal 文件，这对于任何类型的 FFI 编写都适用（事实证明，启用 c2hs 只是小菜一碟）。

*启用 c2hs.* 这是一个技巧性问题；Cabal 会自动检测扩展名为 `chs` 的文件，并对其使用适当的标志运行 `c2hs`。然而，如果用户没有安装 `c2hs`，这个操作可能会失败，因此你应该将以下行添加到你的 Cabal 文件中：

```
Build-tools: c2hs

```

现在，你应该能够编译一个以 `chs` 作为文件扩展名的空 Haskell 模块了。

（这里有一些用于添加 c2hs 预处理器支持的 Cabal 钩子代码，但完全不必要。）

*查看生成的 hs 文件.* 一旦 `chs` 文件被预处理，Cabal 就不会再查看它了。你不应该害怕查看预处理器的输出；在许多情况下，当你试图修复类型错误时，这些输出会更有启发性。一般来说，`hs` 文件会位于 `dist/build` 目录下，正如这条构建消息（由 GHC 而非 c2hs 生成）所示：

```
 Building abcBridge-0.1...
[ 5 of 11] Compiling Data.ABC.Internal.VecPtr (
  dist/build/Data/ABC/Internal/VecPtr.hs,
  dist/build/Data/ABC/Internal/VecPtr.o )

```

你看到的代码会类似于这样：

```
-- GENERATED by C->Haskell Compiler, version 0.16.2 Crystal Seed, 24 Jan 2009 (Haskell)
-- Edit the ORIGNAL .chs file instead!

{-# LINE 1 "src/Data/ABC/Internal/VecPtr.chs" #-}{-# LANGUAGE ForeignFunctionInterface #-}

module Data.ABC.Internal.VecPtr where

```

`LINE` pragma 会确保当由生成的 Haskell 代码引起类型错误时，你会得到指向原始 `chs` 文件的行号。这并不是绝对可靠的；有时错误会在 c2hs 声称错误所在的行号之前或之后出现。

*导入和语言特性.* c2hs 生成的 Haskell 代码需要一些语言特性和导入。你应该明确地在程序的顶部添加 `ForeignFunctionInterface` 语言 pragma；虽然可以通过 Cabal 文件启用它，但最好使你的 hs 文件尽可能独立。

在当前版本的 c2hs 中，模块导入稍微复杂一些。c2hs 有一个名为 C2HS 的遗留模块，执行导入、重新导出和额外的编组函数（只有在使用 `fun` 时才需要），默认情况下 c2hs 可能会生成。然而，它已经快被抛弃了，而 c2hs Cabal 包实际上并没有提供这个模块：你需要用 `c2hs -l` 将它复制到你的源目录中。这个模块依赖于 `haskell98`。你不应该重新导出这个模块，因此它应该放在你的 Cabal 文件的 `Other-modules` 字段中。

现代的方法是显式地导入和定义自己的模块。需要导入的模块是`Foreign`和`Foreign.C`，并且有一小部分与 Haskell 将在你尝试使用该编码器与其一起使用时，Haskell 将会抱怨没有定义。将来的 C2HS 版本将进一步减少必要的函数。gtk2hs 采用这种方法（尽管他们还放弃了大部分 C2HS 的自动编码支持）。

*加载库。* 如果幸运的话，你的包管理器已经有了你想要创建绑定的库。在这种情况下，你只需将库的名称添加到 Cabal 文件中`Library`部分的`Extra-libraries`字段即可。例如，如果你想使用 readline，就将`readline`添加到字段中，GHC 将会知道在`/usr/include/readline`找到头文件，并在运行时动态链接`/usr/lib/libreadline.so`。在某些情况下，库会安装在默认情况下不会搜索的标准位置（例如 Linux 系统上的 Oracle，以及 Windows 上的基本任何库）；在这种情况下，你可以告诉 Cabal 这个“非标准标准”位置在哪里，使用`Extra-lib-dirs`。

如果你的 C 库不是一个良好的模块（许多小众库就是这种情况），就需要采取一些额外步骤。以下是一些常见情况，以及如何处理它们的建议：

1.  *这个库很小且构建过程简单。* 在这种情况下，可以将库的源代码与你的包捆绑在一起，并完全使用 Cabal 管理其编译。如果你的库没有`make install`，那么除了要求用户手动提供必要的链接器选项来连接这两个安装之外（这并不是一个用户友好的选项，特别是使得运行`cabal install`变得复杂）。你应该只在少量源代码的情况下这样做，因为与通常的构建相比，GHC 指导的编译速度要慢得多。详见*使用 Cabal 编译库*和*管理包含文件*。

1.  *出于某些原因，我想捆绑这个库，但它的构建过程很复杂。* 在这种情况下，可以设置 Cabal 来调用库的构建过程，然后使用生成的文件进行 Haskell 构建过程。这种方法存在许多缺点，包括 Cabal 文件和安装过程混乱，因此如果你能够选择第三个选项，我建议使用那个。详见*使用挂钩编译库*。你还应该阅读*管理包含文件*。

1.  *我不想捆绑这个库。* 在这种情况下，你需要提供给最终用户下载、编译和安装外部库的指南。如果你作为包的作者，将该库打包为各种发行版的工作将会使用户的操作变得更加简单，尽管这是一个安装较少的库。如果用户不愿意在规范路径安装该库，他们将需要向`cabal`传递适当的选项。参见*手动链接*。

*使用 Cabal 编译库.* Cabal 有能力以非常简单的方式编译 C 代码：它从 Cabal 字段`C-sources`中获取文件列表并按顺序编译它们。特别地，它不执行任何依赖跟踪，因此当你提供文件列表时，请确保它们的顺序正确！这使得这种机制只适用于少量的 C 代码，包括您可能自己编写以帮助绑定过程的 C 代码。在`cbits`中放置`c`文件，并在`include`中放置`h`文件是一种日益普遍的惯例。然后，你可以使用以下几行告诉 Cabal 这些目录的位置：

```
-- This ensures that Cabal places these files in the release tarball,
-- which is important if you plan to release
Extra-source-files: cbits, include
-- ...
Library foobar
  -- ...
  -- The C source files to compile, in that order
  C-sources: cbits/foobar.c, cbits/foobaz.c
  -- The location of the header files
  Include-dirs: include
  -- The header files to be included
  Includes: foobar.h, foobaz.h
  -- Header files to install
  Install-includes: foobar.h, foobaz.h

```

关于“includes”字段的几句话：

+   当编译顺利进行时，`Includes`字段可能不会对用户造成显著影响。然而，明确指定它是个好习惯，因为 Cabal 会在编译之前检查这些包含文件是否存在并且可用，从而在出现问题时为用户提供更好的错误消息。*用法.* 指定任何标准头文件和包含在你的软件包中使用的任何捆绑头文件。

+   `Install-includes`字段将导致 Cabal 在安装时将这些头文件放置在公共位置。这对于旧版本的 GHC 编译您的代码或者如果使用您的模块的模块需要执行 C 包含您的库或`cbits`是必需的；通常情况下，安装您的头文件是一个很好的做法。*用法.* 指定您的软件包使用和导出的捆绑头文件。

*使用钩子编译库.* 如果有超过一打的 C 文件需要编译，你可能希望让传统的`configure && make`流程为你处理。在这种情况下，使用 Cabal 的`Setup.hs`中的小钩子设置可能是合适的，通过实验性钩子接口来调用编译过程。以下是一个简单的示例构建脚本：

```
import Distribution.Simple
import Distribution.Simple.Setup
import Distribution.Simple.Utils (rawSystemExit)

main = defaultMainWithHooks simpleUserHooks
    { preBuild = \a b -> makeLib a b >> preBuild simpleUserHooks a b }

makeLib :: Args -> BuildFlags -> IO ()
makeLib _ flags =
    rawSystemExit (fromFlag $ buildVerbosity flags) "env"
        ["CFLAGS=-D_LIB", "make", "--directory=abc", "libabc.a"]

```

我们在`preBuild`中添加了我们自己的`makeLib`构建脚本（同时保留旧版本的`simpleUserHooks`），并使用 Cabal 的实用函数`rawSystemExit`来完成大部分工作。请注意，需要将`--directory=abc`传递给`make`；Cabal 在与`cabal`文件相同的目录中运行，因此你可能需要调整你的工作目录到库目录。`setCurrentDirectory`可能会派上用场。

你的构建过程可能会将生成的`libfoo.a`文件放在*不是*`dist/build`的某个地方。你可以使用`Extra-lib-dirs`字段告诉 Cabal 查找那个目录。

上述步骤足以使你的软件的干净源码检查工作正常进行，但是为了确保用户能够安装`cabal sdist`的结果，你需要再进一步。

首先，任何构建过程中需要的*任何*源文件都必须在`Extra-source-files`中显式列出。Cabal 只支持一种有限的通配符匹配形式，文件名必须包含文件扩展名，所以这个列表可能会很长（我们建议你使用脚本生成它）。

其次，构建过程创建的静态/动态库可能不会放置在 GHC 编译时会查找的位置，导致此错误：

```
Linking dist/build/abc-test/abc-test ...
/usr/bin/ld: cannot find -labc
collect2: ld returned 1 exit status

```

我们可以在与 Cabal 在安装期间放置 Haskell 模块的静态库相同的位置放置我们的库，这需要另一个钩子：

```
import Distribution.Simple
import Distribution.Simple.Setup
import Distribution.Simple.Utils (rawSystemExit)
import Distribution.PackageDescription (PackageDescription(..))
import Distribution.Simple.LocalBuildInfo (
        LocalBuildInfo(..), InstallDirs(..), absoluteInstallDirs)

main = defaultMainWithHooks simpleUserHooks
    { preConf = \a f -> makeAbcLib a f >> preConf simpleUserHooks a f
    , copyHook = copyAbcLib
    }

-- ...

copyAbcLib :: PackageDescription -> LocalBuildInfo -> UserHooks -> CopyFlags -> IO ()
copyAbcLib pkg_descr lbi _ flags = do
    let libPref = libdir . absoluteInstallDirs pkg_descr lbi
                . fromFlag . copyDest
                $ flags
    rawSystemExit (fromFlag $ copyVerbosity flags) "cp"
        ["abc/libabc.a", libPref]

```

`libPref`右侧的咒语决定了 Cabal 将要安装库文件的位置，然后我们只需将我们的库复制到该位置。

（*Nota bene.* 如果你确信没有人会全局安装此库，那么只有在确保库不与同名的非二进制兼容库一起浮动时才真正使用此技巧是*非常有趣的*。）

*管理包含。* 任何需要位于包含路径中的非标准目录应添加到`Include-dirs`。如果库中有*很多*这样的目录，请考虑另一种解决方案：在`include`中为所有相关头文件创建符号链接，然后只需将该目录添加到`Include-dirs`。

*手动链接。* 如果需要手动告诉 Cabal 相关头文件和库的位置，你可以在`cabal configure`或`cabal install`中使用`--extra-include-dirs`和`--extra-lib-dirs`标志。它们的功能与`Include-dirs`和`Extra-lib-dirs`完全相同。

*共存的库和可执行部分。* 对于测试，你可能会发现在你的 Cabal 文件中定义多个`Executable`部分很方便，在这种情况下，你会注意到似乎需要将所有与 C 相关的 Cabal 字段复制到每个可执行部分中。好吧，在 Cabal 1.8.0.4 中，你现在可以将`Build-depends`设置为指向你自己的包（"self-reference"）；因此，你为每个可执行文件声明了一个`Build-depends`，而与 C 相关的 Cabal 字段是不必要的。

你需要告诉 Cabal 可以使用此字段来使用这个特性：

```
Cabal-version:      >= 1.8.0.4

```

*附言。* 感谢 Duncan Coutts 帮助澄清和建议改进本教程的各个部分。

*下次再说。* [FFI API 设计原则](http://blog.ezyang.com/2010/06/principles-of-ffi-api-design/)。

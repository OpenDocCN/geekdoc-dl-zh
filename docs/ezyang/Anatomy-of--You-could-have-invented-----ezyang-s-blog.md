<!--yml

category: 未分类

date: 2024-07-01 18:17:36

-->

# 《“你本可以发明…” 的解剖：ezyang 的博客》

> 来源：[`blog.ezyang.com/2012/02/anatomy-of-you-could-have-invented/`](http://blog.ezyang.com/2012/02/anatomy-of-you-could-have-invented/)

## “你本可以发明…” 的解剖

*你本可以发明...* 的文章遵循一种特定的方案：

1.  简单介绍一个易于理解的问题，

1.  尝试解决问题，但卡在显而易见的方式上，

1.  简单介绍一个易于理解的见解，

1.  方法 ically 解决其余的细节，最终得出最终结果。

为什么以这种方式构建问题有助于解决？

+   虽然步骤 4 中涉及的细节导致结构并不一定显而易见（因此给人一种概念难以理解的印象），但其见解非常易于理解，其余部分只是“苦工”。*推导解决方案的方法*比*解决方案本身*更易于压缩，因此更容易学习。

+   选择一个非常具体且易于理解的问题有助于我们在一个具体示例中打下基础，而结果结构可能过于一般化，难以获得良好的直觉。

很重要的是问题要容易理解，“解决细节”过程要简单。否则，展示会感觉刻意。当观众足够聪明，能够直接看到最终结果并在直觉层面理解时，这种方法也不合适。通常是因为他们*已经看过示例*。但对于我们其他人来说，这是一种非常有效的教学方法。

我将利用这个机会分析两个特定的例子。第一个是丹·皮波尼的经典文章，[你本可以发明单子](http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html)。以下是四个步骤：

1.  假设我们想调试纯函数，类型签名为 `f :: Float -> Float`，使它们也能返回一个发生了什么的字符串消息，`f' :: Float -> (Float, String)`。

1.  如果我们想组合这些函数，手动线程状态的显而易见解决方案确实很烦人。

1.  我们可以将这种模式抽象为一个高阶函数。

1.  我们可以在许多其他例子上做同样的配方，然后显示其泛化。泛化即是一个单子。

第二篇是我的文章，[你本可以发明拉链](http://blog.ezyang.com/2010/04/you-could-have-invented-zippers/)：

1.  我想做两件事：访问树中节点的父节点和子节点，并对树进行*持久*更新（例如，无需变异）。

1.  如果我们做显而易见的事情，我们必须更新树中的所有节点。

1.  我们只需要翻转一个指针，使其指向父节点。

1.  我们可以创建一个新的数据结构来保存这些信息（说实话，有点丑陋），然后展示这个过程的泛化。泛化即是一个拉链。

所以下次当你试图解释看似复杂但实际简单的事物时，请试试这种方法！下次：*你本可以发明分数级联*。

*附录.* 这是一种常见的学术论文结构，尽管很少有论文以此为题。然而，一个显著的区别是，通常“细节工作”并不明显，或者需要一些新颖的技术方法。有时，研究人员会发现一种真正重要的技术方法，并且这种方法会在学术界广泛传播，以至于对于任何在该领域工作的人来说都是显而易见的。在某些方面，这正是一个真正成功的论文的特征之一。

<!--yml

category: 未分类

date: 2024-07-01 18:17:01

-->

# Prio：私密、强大和可扩展的聚合统计计算：ezyang 的博客

> 来源：[`blog.ezyang.com/2017/03/prio-private-robust-and-scalable-computation-of-aggregate-statistics/`](http://blog.ezyang.com/2017/03/prio-private-robust-and-scalable-computation-of-aggregate-statistics/)

我想借此机会宣传一下我的一位同事[Henry Corrigan-Gibbs](https://www.henrycg.com/)（与备受尊敬的 Dan Boneh 合作）关于在收集聚合统计数据时保护隐私的一些新工作。他们的新系统名为[Prio](https://www.henrycg.com/pubs/nsdi17prio/)，将出现在今年的 NSDI 上。

他们解决的基本问题是：假设你是谷歌，你想收集一些关于用户的统计数据以计算一些聚合指标，例如平均值或线性回归拟合：

一个大问题是如何在不损害用户隐私的情况下收集这些数据。为了保护隐私，*你不想*知道每个个别用户的数据：你希望以完全匿名的形式获取这些数据，并且只在收集期结束时获得一个聚合统计数据。

这是一个古老的问题；有许多[现有系统](https://github.com/google/rappor)在实现这一目标时有不同的权衡。Prio 解决了在私人聚合数据收集领域中一个特别棘手的问题：面对恶意客户的强大性。假设你正在为线性回归收集数据，而你的客户发送给你的输入是完全匿名的。一个恶意客户可能会发送给你一个糟糕的数据点，这可能会使整个数据集产生偏差；而且由于你从未看到数据集的个别数据点，你永远也不会注意到：

因此，Prio 关注匿名收集数据的问题，同时能够*验证*数据是否合理。

Prio 实现这一目标的机制非常酷，因此在这篇文章中，我想解释一下他们协议的关键见解。Prio 在一个客户*秘密共享*他们的秘密给一组被假定为不串通的服务器的情况下运作；只要至少有一个服务器是诚实的，直到服务器共同同意发布聚合统计数据之前，关于客户的秘密不会被透露。

这里是问题所在：给定某个隐藏值的秘密共享，我们如何*高效地*检查它是否有效？为了回答这个问题，我们首先必须解释一下秘密共享的世界。

* * *

秘密分享方案允许您将一个秘密分成许多片段，以便原始秘密除非您拥有某些片段的子集，否则无法恢复。有惊人简单的秘密分享构造：假设您的秘密是某个域中的数字*x*（例如，模某个质数*p*的整数），并且您希望将其分成*n*部分。然后，让前*n-1*份额是域中的随机数，最后一个随机数是*x*减去前面份额的总和。通过将所有份额相加来重建秘密。此方案在信息理论上是安全的：仅使用*n-1*份额，您对底层秘密不知道任何信息。此秘密分享方案的另一个有趣属性是，它在加法上是同态的。让你的*x*和*y*的份额分别是 ![[x]_i](img/3a777f041687882a2aac1f63411c4503.png "[x]_i") 和 ![[y]_i](img/09843b233ecfaaee21603f5d66cc7880.png "[y]_i")：那么 ![[x]_i + [y]_i](img/36543bd41d0031b6e5f86d169388897b.png "[x]_i + [y]_i") 形成*x + y*的秘密分享，因为域中的加法是可交换的（因此我可以将每对总和重新分配为 x 的总和和 y 的总和）。

通常，设计支持同态加法的方案很容易，但是具有同时支持加法和乘法（以便您可以计算有趣的算术电路）的方案则稍微困难一些。假设您希望在某个秘密分享值上计算算术电路：加法很容易，但要执行乘法，大多数多方计算方案（Prio 使用[Beaver 的 MPC 协议](https://www.cs.bris.ac.uk/~nigel/FHE-MPC/Lecture8.pdf)）都要求您进行一轮通信：

虽然您可以批量处理电路中相同“级别”的乘法，以便您只需执行电路中最大乘法深度的轮次，但对于大型电路，您可能需要进行相当多的通信。亨利告诉我，全同态秘密分享已经成为一些正在进行的研究课题；例如，去年[Crypto 大会](https://eprint.iacr.org/2016/585)关于同态秘密分享的论文获得了最佳论文奖。

* * *

返回到 Prio，回想一下我们有用户提供输入的秘密分享，并且我们想要检查它是否根据某个算术电路有效。正如我们上面看到的那样，我们可以尝试使用多方计算协议来计算电路输出的份额，揭示电路的输出：如果它说输入有效，则接受它。但这将需要相当多的通信轮次来实际进行计算！

Prio 的一个关键洞察是：我们不需要服务器来*计算*电路的结果--一个诚实的客户端完全可以做到这一点--我们只需要它们来*验证*电路计算的有效性。这可以通过客户端发送电路中每条线上所有中间值的份额，让服务器重新计算这些份额的乘积，然后将结果与客户端提供的中间值进行比较来实现：

当我们将问题从*计算*问题转换为*验证*问题时，我们现在有一个*尴尬并行*的验证电路，只需要一个轮次来乘以电路的每个中间节点。

最后有一个问题：我们如何检查重新计算的份额乘积和客户端提供的中间值是否一致？我们不能发布电线的中间值（这将泄露有关输入的信息！）我们*可以*建立一个更大的电路来进行比较并将结果组合在一起，但这将需要更多的通信轮次。

为了解决这个问题，Prio 采用了 Ben-Sasson'12 的一个巧妙技巧（《近线性无条件安全的多方计算与不诚实少数派》）：不是公开*所有*中间线的详细内容，而是将它们视为多项式，并在随机点上发布每个多项式的评估。如果服务器行为正确，它们不会泄露任何关于原始多项式的信息；而且很可能，如果原始多项式不相等，那么在随机点上的多项式评估也不会相等。

* * *

这一切都非常精彩，但我想以一个警示故事来总结一下：在设置这些多项式时，你必须非常小心。这里有个陷阱：假设一个恶意的服务器同态地*修改*了它们输入的份额之一，例如，添加了一些增量。由于我们的秘密份额是可加的，将增量添加到一个份额会导致秘密也被这个增量修改！如果对手可以用这个修改后的份额完成协议的其余部分，当协议运行结束时，他会发现*修改后的*秘密是否有效。这会泄露关于输入的信息：如果你的有效性测试是“输入是否为 0 或 1”，那么如果你（同态地）给输入加一，并且它仍然有效，你就知道它肯定是零！

幸运的是，这个问题可以通过*随机化*多项式来解决，因此即使输入份额被移动，它计算的其余中间值也不能以相同的方式移动。详细内容请参阅“为什么要随机化多项式？”部分。我认为这只是展示了加密系统设计有多棘手的一个例子！

无论如何，如果这引起了你的兴趣，[去阅读这篇论文](https://www.henrycg.com/pubs/nsdi17prio/)吧！如果你在麻省理工学院，你还可以在[3 月 22 日](http://css.csail.mit.edu/security-seminar/details.html#Mar2217)参加亨利在麻省理工学院 CSAIL 安全研讨会上的演讲。

<!--yml

category: 未分类

date: 2024-07-01 18:17:57

-->

# 半自动化测试：ezyang’s 博客

> 来源：[`blog.ezyang.com/2011/02/semi-automatic-testing/`](http://blog.ezyang.com/2011/02/semi-automatic-testing/)

## 半自动化测试

当程序员自动化某些事情时，我们常常希望全面自动化所有事情。但是要记住，手动测试在机器辅助下仍然有其存在的价值：与其花费指数级的努力去自动化一切，不如自动化容易的部分，并对困难的研究问题硬编码答案。当我编制下面的测试数据来源图表时，我注意到在“自动化”和“非自动化”的两端存在显著的极化现象。

一个理想的测试框架将支持结合所有这些数据来源和所有这些测试机制。一些新颖的方法包括：

+   通过手动验证随机生成的测试用例。显然，您无法手动验证成千上万个测试用例，但几个具体的例子对文档目的非常有帮助，而随机生成可以防止我们只选择“好”的输入。

+   作为旧版本代码的参考实现。到极限，您自动接受旧实现的输出并将其保存到您的测试套件中，当测试开始失败时，框架会要求您检查输出，如果比以前“更好”，则用新的数据覆盖旧的测试数据。 GHC 的测试套件就有类似的功能。

+   你已经编写了很多代数定律，现在正使用 Quickcheck 进行验证。您应该能够用来自采样数据源的确定性数据流替换随机生成器。您可能希望为各种源格式和将它们转换为目标表示形式的迷你 DSL。当您选择了手动输入时，这也非常有效，但*确切*指定输出结果却很痛苦，因为它又大又复杂。这就是[数据驱动测试](http://en.wikipedia.org/wiki/Data-driven_testing)。

+   Quickcheck 和 Smallcheck 这样的非模糊测试框架在处理运行时异常时表现相当不错，但在处理像分段错误这样更严重的故障时则不然。这些框架的驱动程序应利用无状态性质来注意其运行程序何时莫名其妙地终止，并告知用户重现崩溃所需的最小调用方式 —— 经过这种修改，这些框架涵盖了当前以临时方式构建的模糊器。

如果我们不必致力于一种测试方法，并且可以在围墙的两侧重复利用工作以获得巨大的胜利，那将是非常好的。

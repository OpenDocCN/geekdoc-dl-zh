<!--yml

类别：未分类

日期：2024-07-01 18:17:26

-->

# Haskeller 的对偶：ezyang 的博客

> 来源：[`blog.ezyang.com/2012/10/duality-for-haskellers/`](http://blog.ezyang.com/2012/10/duality-for-haskellers/)

*这篇文章是* [在 coBurger King 中翻转汉堡](http://blog.ezyang.com/2010/07/flipping-arrows-in-coburger-king/) 的精神前身。

什么是*对偶*？一个范畴论者会说，“它是相同的东西，只是所有箭头都反过来了。”这个答案似乎令人沮丧地模糊，但实际上它是相当精确的。唯一缺少的就是知道*哪些*箭头要反转！如果你知道这些箭头，那么你就知道如何对偶化。在这篇文章中，我想介绍一些对于 Haskeller 而言很好知道的结构，描述这些结构的箭头是什么样子的，然后展示当我们反转这些箭头时，我们得到了一个对偶的概念。

### 产品与总和

假设你有一些类型为 `Either a b` 的数据。对于所有的数据，我们希望能够执行两个基本操作：我们想能够*构造*它和*解构*它。Either 的构造函数是 `Left :: a -> Either a b` 和 `Right :: b -> Either a b`，而一个合理的解构函数选择可能是 `either :: (a -> r) -> (b -> r) -> Either a b -> r`（情况分析，其中第一个参数是左侧情况，第二个参数是右侧情况）。让我们画个图：

我添加了两个额外的箭头：它们表示 `either f g . Left == f` 和 `either f g . Right == g`；这些方程在某种意义上表征了构造函数和解构函数之间的关系。

好的，那么当我们反转这些箭头时会发生什么？这一节的标题已经透露了答案，但让我们来看看：

这些箭头中的一些很容易解释。曾经是我们的构造函数（`Left` 和 `Right`）现在是我们的*解构函数*（`fst` 和 `snd`）。但是 f 和 g 以及我们的新构造函数呢？实际上，`\x -> (f x, g x)` 在某种意义上是对于成对值的*广义构造函数*，因为如果我们设置 `f = const a` 和 `g = const b`，我们可以轻松地获得成对值的传统构造函数（其中成对值的规范本身是箭头——当你第一次看到它时会有点惊讶）：

因此，总和和乘积在彼此之间是对偶的。因此，总和经常被称为*余积*。

（敏锐的读者可能已经注意到这个演示是颠倒的。这主要是为了避免引入似乎突如其来的 `\x -> (f x, g x)`。）

### 顶部和底部

单元类型（称为顶）和底类型（没有元素的类型）在彼此之间表现出对偶关系。我们可以这样看待：对于任何 Haskell 类型，我都可以轻松地构造一个函数，它接受该类型的值并产生单元；它是 `const ()`：

此外，忽略惰性计算，这是唯一可以完成这一技巧的*函数*：它是唯一的。让我们反转这些箭头：是否存在一种类型 A，对于任何类型 B，都存在一个函数 `A -> B`？乍一看，这似乎是不可能的。B 可以是任何东西，包括一个不可居住的类型，在这种情况下，我们很难生成适当值。但等等：如果 A 是不可居住的，那么我什么也不用做：函数不可能被调用！

因此，**上**和**下**相互对偶。实际上，它们对应于类别**Hask**中的*终端对象*和*初始对象*的概念（分别）。

关于终端对象的一个重要说明：`Int` 是一个终端对象吗？可以肯定的是，有些函数的类型为 `forall a. a -> Int`（例如 `const 2`）。然而，这个函数并不唯一：还有 `const 0`，`const 1` 等。因此，`Int` 不是终端对象。也有很好的理由：有一个易于证明的定理表明所有终端对象彼此同构（对偶地：所有初始对象彼此同构），而 `Int` 和 `()` 显然不是同构的！

### 折叠和展开

函数式编程语言中最重要的组成部分之一是递归数据结构（也称为归纳数据结构）。有许多方法可以操作这些*数据*，但其中最简单且最广为人知的是折叠，可能是可以使用的最简单的递归形式之一。

折叠的图表稍微复杂一些，所以我们将从头开始推导，思考函数式程序员最常见的折叠，即列表的折叠：

```
data List a = Cons a (List a) | Nil
foldr :: (a -> r -> r) -> r -> List a -> r

```

前两个参数“定义”了折叠，而第三个参数只是提供了实际要折叠的列表。我们可以尝试立即绘制一个图表：

但是我们遇到了一点小麻烦：我们的图表有点无聊，主要是因为对偶 `(a -> r -> r, r)` 并没有一个好的解释作为箭头。那么我们该怎么办呢？我们真正想要的是一个单一的函数，它能编码我们最初编码的所有信息。

好吧，这里有一个例子：`g :: Maybe (a, r) -> r`。假设我们最初有一对 `(f, z)`，然后定义 `g` 如下：

```
g (Just (x, xs)) = f x xs
g Nothing = z

```

直观地说，我们通过用一个和类型替换输入参数将折叠函数和初始值合并为一个函数。为了运行 `f`，我们传递一个 `Just`；为了获取 `z`，我们传递一个 `Nothing`。稍微概括一下，任何折叠函数都可以通过一个函数 `g :: F a r -> r` 来指定，其中 `F a` 是适合问题中的数据类型的函子（在列表的情况下，`type F a r = Maybe (a, r)`）。我们重复使用 `Maybe`，这样我们就不必定义一个新的数据类型，但我们可以更有启发性地重命名 `Just` 和 `Nothing`，作为 `data ListF a r = ConsF a r | NilF`。与我们原始的 `List` 定义 (`Cons a (List a) | Nil`) 相比，它是相同的，但所有递归出现的 `List a` 都用 `r` 替换了。

有了这个定义，我们可以更详细地构建我们的图表：

最后一步是以某种方式关联 `List a` 和 `ListF a r`。记得 `ListF` 看起来很像 `List`，只是用 `r` 替换了 `List a`。所以如果我们有 `ListF a (List a)` —— 简单地将 `List a` 替换回函子中。我们预计这与 `List a` 有关系，确实有一个简单而独特的函数可以将一个转换为另一个：

```
in :: ListF a (List a) -> List a
in (ConsF x xs) = Cons x xs
in NilF = Nil

```

谜题的最后一块是：我们如何从 `ListF a (List a)` 转换到 `ListF a r`？嗯，我们已经有一个函数 `fold g :: List a -> r`，所以我们需要做的就是用 `fmap` 将其提升起来。

我们有一个交换图表，并要求 `g . fmap (fold g) = fold g . in`。

现在剩下的就是泛化了。一般来说，`ListF` 和 `List` 使用一个叫做 `Mu` 的小技巧相关联，定义为 `data Mu f = Mu (f (Mu f))`。`Mu (ListF a)` 和 `List a` 是同构的；直观地说，它用所定义的数据结构替换了所有的 `r`。所以一般来说，图表看起来像这样：

现在所有这些初步工作都已经完成，让我们来对偶化！

如果我们来看一下 Prelude 中 unfold 的定义：`unfold :: (b -> Maybe (a, b)) -> b -> [a]`；那么 `Maybe (a, b)` 正好对应我们的 `ListF`！

这里的情况与和积的故事非常相似：在递归世界中，我们主要关注如何 *析构* 数据。在核递归世界中，我们主要关注如何 *构造* 数据：`g :: r -> F r`，现在告诉我们如何从 `r` 进入更大的 `Mu F`。

### 结论

对偶化是一个优雅的数学概念，在你知道去哪里找到它后，它就随处可见！此外，从范畴论学家的角度来看，它非常好，因为当你知道两个概念是对偶的时候，你所拥有的所有定理都会自动翻转到另一侧！（这是因为范畴论中的所有基本概念都可以对偶化。）如果你有兴趣了解更多信息，我建议阅读 [Dan Piponi 关于数据和余数据的文章](http://blog.sigfpe.com/2007/07/data-and-codata.html)。

<!--yml

category: 未分类

date: 2024-07-01 18:16:50

-->

# 让我们谈谈 PyTorch 调度器：ezyang's 博客

> 来源：[`blog.ezyang.com/2020/09/lets-talk-about-the-pytorch-dispatcher/`](http://blog.ezyang.com/2020/09/lets-talk-about-the-pytorch-dispatcher/)

如果这是你第一次了解 PyTorch 内部工作原理，你可能想先看看我的[PyTorch internals](http://blog.ezyang.com/2019/05/pytorch-internals/)文章。在这篇文章中，我想谈谈 PyTorch 内部的一个特定部分：[调度器](https://pytorch.org/tutorials/advanced/dispatcher.html)。乍一看，调度器只是一个被美化的 if 语句：基于一些关于张量输入的信息，决定调用哪段代码。那么我们为什么要关注调度器呢？

嗯，在 PyTorch 中，让一个操作符起作用需要很多东西。当然，有实际工作的内核；但还有对反向模式自动微分的支持，例如使`loss.backward()`工作的位。哦，如果你的代码在`torch.jit.trace`下，你可以获得运行的所有操作的跟踪。我提到了如果你在`vmap`调用内部运行这些操作，操作符的批处理行为会有所不同吗？有很多不同的方式来解释 PyTorch 操作符的不同，如果我们试图在一个名为`add`的单个函数内处理它们所有，我们的实现代码很快就会变得难以维护。调度器不仅仅是一个 if 语句：它是我们在 PyTorch 内部结构化代码的一个非常重要的抽象...而且它必须在不太降低 PyTorch 性能的情况下做到这一点。

在本文末尾，我们的目标是理解这幅图中的所有不同部分是如何组合在一起的。本文将分为三个部分进行。

首先，我们将讨论调度器本身。什么是调度器，它如何决定调用哪个内核？其次，我们将讨论操作符注册 API，这是我们将内核注册到调度器的接口。最后，我们将讨论装箱和解箱，这是调度器中的一个横切特性，让您可以一次编写代码，然后使其在所有内核上工作。

### 什么是调度器？

好的，那么什么是调度器？对于每个操作符，调度器维护一个函数指针表，该表为每个*调度键*提供实现，这些键大致对应于 PyTorch 中的一些横切关注点。在上面的图表中，您可以看到该表中有针对后端（CPU、CUDA、XLA）以及像 autograd 和追踪等更高级别概念的调度条目。调度器的工作是根据输入张量和其他一些内容（稍后详述）计算调度键，然后对表中指向的函数进行间接跳转。

如果你熟悉 C++ 的话，你可能会注意到函数指针表在某种程度上和 C++ 中的虚函数表很相似。在 C++ 中，对象的虚方法是通过将每个对象关联到一个虚函数表的指针来实现的，该表包含了该对象的每个虚方法的具体实现。在 PyTorch 中，我们本质上重新实现了虚函数表，但存在一些区别：

+   分派表是按操作员分配的，而虚函数表是按类分配的。这意味着我们可以通过简单地分配新的分派表来扩展支持的操作员集合，这与常规对象不同，常规对象可以从类扩展，但不能轻松添加虚方法。与正常的面向对象系统不同，在 PyTorch 中，大部分的可扩展性在于定义新操作员（而不是新子类），因此这种权衡是有道理的。分派键不是公开可扩展的，我们通常期望希望分配新分派键的扩展，向 PyTorch 核心提交补丁以添加它们的分派键。

+   关于这一点，在下一张幻灯片中会有更多信息，但我们计算分派键的过程考虑了操作员的所有参数（多分派）以及线程本地状态（TLS）。这与虚函数表不同，后者只考虑第一个对象（`this`）的内容。

+   最后，分派程序支持封装和解封装作为操作员调用约定的一部分。关于这一点，在演讲的最后部分会有更多解释！

有趣的历史注解：我们曾经使用虚方法来实现动态分派，当我们意识到我们需要更多功能而虚函数表无法提供时，我们重新实现了它们。

那么我们究竟如何计算用于索引到分派表的分派键呢？我们用于计算要使用的分派键的基本抽象是分派键集，它是对分派键的位集合。总体概念是，我们从各种来源联合分派键集（有时排除某些分派键），得到最终的分派键集。然后，我们选择集合中的第一个分派键（分派键按某种优先级隐式排序），这就是我们应该分派到的地方。这些来源是什么？

+   每个张量输入都会贡献一个分派键集，其中包含了张量上的所有分派键（直观上，这些分派键可能是诸如 CPU 的内容，告诉我们相关张量是 CPU 张量，并应由分派表上的 CPU 处理器处理）

+   我们还有一个本地包含集，用于“模态”功能，例如追踪，它与任何张量无关联，而是某种用户可以在某些范围内开启和关闭的线程本地模式。

+   最后，我们有一个全局集合，其中包含始终考虑的分派键。（自撰写本幻灯片以来，Autograd 已经从全局集合移至张量。然而，系统的高层结构并未改变。）

还有一个本地排除集合，用于在调度中排除调度键。一个常见模式是某些处理程序处理一个调度键，然后通过本地排除集合将自身屏蔽，这样我们就不会尝试在稍后重新处理此调度键。

让我们通过一些示例来逐步了解调度键的演变。

（警告：此描述对于 PyTorch 主版本已过时。Autograd 不再全局存在，而是存在于张量上。其余一切如前所述。）

调度机制运行的最典型例子是它如何处理自动求导。从顶部到底部阅读图表。在最顶部，Autograd 位于全局集合中，并且本地排除集为空。当我们进行调度时，我们发现自动求导是最高优先级的键（比 CPU 优先级更高），我们将操作符的调度分派给自动求导处理程序。在自动求导处理程序内部，我们进行一些自动求导操作，但更重要的是，我们创建 RAII 保护`AutoNonVariableTypeMode`，将 Autograd 添加到本地排除集合中，防止在此操作符内部的所有操作中处理自动求导。当我们重新调度时，我们现在跳过自动求导键（因为它被排除），并将操作分派给下一个调度键，例如 CPU。由于在调用树的其余部分维护本地 TLS，所有后续的调度也都会绕过自动求导。最后，在函数结束时，RAII 保护从本地排除集合中移除 Autograd，因此后续的操作符调用再次触发自动求导处理程序。

另一个类似的例子是**追踪**，它类似于自动求导，当我们进入追踪处理程序时，会使用`ExcludeDispatchKeyGuard`来禁用嵌套调用的追踪。然而，它与自动求导的不同之处在于追踪如何最初被触发：追踪是通过将调度键添加到本地包含集合来切换的，当你启用追踪时（使用`IncludeDispatchKeyGuard`），而不是像自动求导那样使用全局调度键（更新：现在是张量上的调度键）。

最后一个例子是**BackendSelect**键，它与普通键的操作有些不同。BackendSelect 解决的问题是有时，默认的调度键集合计算算法不知道如何确定正确的调度键应该是什么。这种情况的一个显著案例是工厂函数，它们没有任何张量参数（因此，天真地说，不会分配到任何东西）。BackendSelect 在全局调度键集中，但仅为少数操作员注册（对于其余操作员，它是一个回退键）。BackendSelect 处理程序检查参数并决定最终的调度键应该是什么，然后直接分派到该键，绕过调度键计算。

该幻灯片总结了在 PyTorch 中分发某些操作时处理的一些最常见的处理程序序列。大多数情况下，它是 autograd，然后是后端（如果是工厂函数，则在中间有一个后端选择）。对于 XLA，还有一个 XLAPreAutograd 键（更新：此键现在简称为 AutogradXLA），它可以用来覆盖 Autograd 键的行为。当然，如果你同时打开 PyTorch 中的每个功能，你可能会停在很多处理程序上。请注意，处理程序处理的顺序很重要，因为处理程序不一定是可交换的。

### 操作符注册

因此，我们谈论了如何决定调用调度表中的函数指针，但这些指针首先如何进入调度表呢？这是通过操作符注册 API。如果你以前从未见过这个 API，请查看 [C++ 中的调度器](https://pytorch.org/tutorials/advanced/dispatcher.html) 教程，它在高层次上描述了 API 的工作原理。在本节中，我们将更详细地探讨注册 API 如何精确映射到调度表。下面，您可以看到与操作符注册 API 交互的三种主要方式：您定义操作符的模式，然后在调度键上注册实现；最后，还有一种 `fallback` 方法，您可以使用它来为*所有*操作符在某些调度键下定义一个处理程序。

为了可视化这些注册操作符的影响，让我们想象所有操作符的调度表集体形成一个网格，如下所示：

在一个轴上，我们有 PyTorch 支持的每个操作符。在另一个轴上，我们有系统中支持的每个调度键。操作符注册的行为涉及在这两个轴下填充实现的单元格。

当我们为特定调度键上的单个操作符注册一个内核时，我们会填充一个单元格（下面显示为蓝色）：

当你将一个内核注册为操作符中所有调度键的“通用”内核时，你会用一个内核填充操作符的整行（下面显示为红色）。顺便说一句，如果这看起来像是一个奇怪的想法，那是因为确实如此！我们正在努力取消这种能力，而是更倾向于为一部分键填充更具体的值。

当您将一个内核注册为单个调度键的后备内核时，您会填充该调度键的列（绿色）。

这些注册有一个优先顺序：精确的内核注册具有最高优先级，并且通用内核优先于后备。

### 包装和取消包装

我想在这篇文章的最后部分谈论我们调度器中的包装和取消包装功能，这些功能在启用后端后备时非常重要。当你是一个程序设计语言设计者时，你必须做一个经典的权衡决策，即决定是否使用数据的包装或非包装表示：

装箱或同构表示是一种数据表示，其中系统中每种类型的对象具有相同的布局。通常，这意味着你有一些表示，其中包含描述所讨论对象的头部，然后是一些常规载荷。同构表示在代码中很容易处理：因为你总是可以假设数据有某种常规布局，所以可以编写可以在任何类型数据上多态工作的函数（例如，在 Java 中接受任意对象的函数）。大多数垃圾收集语言都有堆对象的某种装箱表示，因为垃圾收集器需要能够处理*任何*类型的堆对象。

相比之下，未装箱或异构表示允许对象根据问题的数据有不同的布局。这比同构表示更有效，因为每个对象可以根据需要的任务调整其内部表示。然而，缺点是我们不能再轻松地编写单个函数，使其在许多类型的对象上多态工作。在 C++中，通过使用模板来解决这个问题：如果需要一个函数能够处理多种类型，C++编译器会为每种使用的类型专门创建函数的新副本。

默认情况下，C++采用异构布局，但我们通过 IValue 结构（解释器值的缩写）在 PyTorch 中实现了同构布局，该结构实现了一个装箱表示，我们可以在解释器中使用。一个 IValue 是一个两个字长的结构，由一个载荷字（通常是指针，但也可以是直接打包到字段中的整数或浮点数）和一个标签字组成，告诉我们 IValue 是什么类型的值。

这意味着在 PyTorch 中函数有两种调用约定：通常的、C++的、未装箱约定，以及使用堆栈上的 IValues 的装箱约定。调用（来自最终用户）可以来自未装箱 API（直接 C++调用）或装箱 API（来自 JIT 解释器）；同样，内核可以作为直接的 C++函数（未装箱约定）实现，也可以作为装箱回退（由于它们在所有操作符上是多态的，因此必须装箱）实现。

如果我从装箱 API 调用到装箱回退，很容易看出如何将这两个组件连接在一起...

...但是我如何从未装箱 API 到装箱回退？

我们需要某种适配器来将未装箱的输入转换为 IValues，以便可以通过装箱的调用约定传递它们。这是通过装箱适配器完成的，该适配器是通过 C++模板自动生成的，基于外部 API 中的未装箱 C++类型。

还有一个反向的问题，即如果我们有来自装箱 API 的输入，并且需要调用未装箱内核，该怎么办。类似地，我们有一个拆箱适配器，负责执行这种转换。与装箱适配器不同的是，这个适配器应用于内核本身，因为 C++模板只能在未装箱类型静态可用的地方工作（在装箱 API 站点，这些类型是未知的，因此你实际上无法实现这个。）请注意，我们始终保留未装箱 API，以便如果用户从未装箱 API 调用，我们可以直接快速通往未装箱内核。

所以这就是整体上看待装箱和拆箱的方式：

装箱和拆箱是实现装箱回退的关键特性：没有它们，我们无法让人们编写可以在任何地方运行的单个内核（事实上，在过去，人们会编写代码生成器来为每个函数生成重复的内核）。通过基于模板的装箱和拆箱，您可以编写一个单一的装箱内核，然后使其适用于操作符，即使这些操作符是从库外定义的也是如此。

### 结论

这就是 PyTorch 调度程序的要点！调度程序仍在不断地进行工作；例如，Ailing Zhang 最近重新设计了如何处理自动求导调度键，这意味着我们实际上不再具有单一的自动求导键，而是为 AutogradCPU/AutogradCUDA 等分拆了自动求导键。我们通常对改进为调度程序注册内核的用户体验感兴趣。如果您有任何问题或意见，请告诉我们！

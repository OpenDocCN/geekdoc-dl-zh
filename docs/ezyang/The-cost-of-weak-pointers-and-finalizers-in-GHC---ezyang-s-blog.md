<!--yml

类别：未分类

日期：2024-07-01 18:17:15

-->

# GHC 中弱指针和终结器的成本：ezyang 的博客

> 来源：[`blog.ezyang.com/2014/05/the-cost-of-weak-pointers-and-finalizers-in-ghc/`](http://blog.ezyang.com/2014/05/the-cost-of-weak-pointers-and-finalizers-in-ghc/)

[弱指针和终结器](http://community.haskell.org/~simonmar/papers/weak.pdf)对于许多类型的程序都是一个非常便利的功能。弱指针用于实现记忆表和解决某些类型的内存泄漏问题，而终结器则用于将“分配/释放”内存模型适配到垃圾回收语言中。当然，这些功能并非免费提供，因此人们可能会想知道在 GHC 中使用这两个（密切相关的）功能的*代价*是什么。在这篇博文中，我想解释一下在 GHC 运行时系统中如何实现弱指针和终结器，并描述通过使用它们而增加的额外开销。本文假定读者对运行时系统和复制垃圾回收的基本工作原理有一定的了解。

### 用户界面 API

弱指针的 API 在[System.Mem.Weak](http://hackage.haskell.org/package/base-4.7.0.0/docs/System-Mem-Weak.html)中；总体而言，弱指针由一个键和一个值组成，其特性是，如果键存活，则值被视为存活。（"简单"的弱引用只是键和值相同的引用。）弱指针还可以选择地与终结器关联，当对象被垃圾回收时运行。Haskell 的终结器不能保证运行。

在[Foreign.ForeignPtr](http://hackage.haskell.org/package/base-4.7.0.0/docs/Foreign-ForeignPtr-Safe.html)中的外部指针也具有附加 C 终结器的能力；即，可能在垃圾回收期间运行的函数指针。事实证明，这些终结器也是使用弱指针实现的，但是 C 终结器与 Haskell 终结器处理方式不同。

### 弱指针的表示

弱指针是一种特殊类型的对象，具有以下布局：

```
typedef struct _StgWeak {   /* Weak v */
  StgHeader header;
  StgClosure *cfinalizers;
  StgClosure *key;
  StgClosure *value;                /* v */
  StgClosure *finalizer;
  struct _StgWeak *link;
} StgWeak;

```

正如我们所见，我们有指向键和值的指针，以及单个 Haskell 终结器的独立指针（只是一个普通闭包）和 C 终结器的指针（其类型为`StgCFinalizerList`）。还有一个用于将弱指针链接在一起的链接字段。实际上，当创建弱指针时，它被添加到幼儿园弱指针列表中（恰如其名为`weak_ptr_list`）。截至 GHC 7.8，此列表是全局的，因此在分配新的弱指针时我们必须[锁定全局锁](https://ghc.haskell.org/trac/ghc/ticket/9075#ticket)，但是在 HEAD 中已经移除了该锁。

### 垃圾回收弱指针

突击测试！当我们对弱引用进行（轻微的）垃圾收集时，`StgWeak` 中的哪些字段被认为是指针，哪些字段被认为是非指针？正确答案是：只有第一个字段被认为是“指针”；其余字段在正常 GC 中被视为非指针。这其实是可以预料的：如果我们在 GC 期间将键和值字段处理为正常的指针字段，那它们根本就不是弱引用。

一旦垃圾收集完成（扣除所有弱引用），我们会遍历弱引用列表并检查键是否存活。如果存活，那么值和终结器应被视为存活，我们将它们标记为存活，并继续执行更多的垃圾收集。只要我们继续发现新的弱引用来处理，此过程将继续进行；然而，这只会发生在键和值不同的情况下（如果它们相同，则键必定已被 GC 处理）。存活的弱引用将从“旧”列表中移除，并放入下次存活弱引用的新列表中。

一旦没有新发现的存活指针，死指针列表将被收集在一起，并安排终结器（`scheduleFinalizers`）。C 终结器在 GC 期间立即运行，而 Haskell 终结器则被批量处理并放入新创建的线程中运行。

还有一些有关如何处理终结器的细节（终结器也是堆对象，因此即使对象已经死亡，我们也必须保留终结器以供下一个 GC 使用），以及线程（弱引用的终结器可以保持线程的存活）。

### 统计成本

总结一下，以下是弱引用的额外成本：

1.  分配弱引用需要获取全局锁（将在 GHC 7.10 中修复），并且消耗六个字（对于 Haskell 堆对象来说相当可观）。

1.  在每次轻微 GC 期间，处理弱引用的时间与正在收集的所有代的弱引用列表大小成线性关系。此外，此过程涉及遍历一个链表，因此数据局部性并不好。这个过程可能会多次发生，尽管一旦确定了弱引用是存活的，就不会再次处理。当发现弱引用存活时，重新执行 GC 的成本仅仅是同步所有并行 GC 线程的成本。

1.  您必须在 GC 和处理弱引用之间进行切换的次数取决于堆的结构。从一个根对象到达对象所需的最小弱链接数，并添加一个特殊的“弱链接”，从一个键到其依赖的弱值。然后，我们可以根据从根到对象的最小弱链接数分类对象：将其称为“弱距离”。假设给定的弱引用的弱距离为 n，则在轻微 GC 期间处理该弱引用需要 O(n)的时间。最大弱距离决定了我们需要重新执行 GC 的次数。

简而言之，当弱引用没有深度嵌套时，它们的成本是相当便宜的：你只需在每次垃圾回收时支付一次遍历你分配的所有指针的链表的成本。在最坏的情况下（弱链接的链条，其中每个弱指针的值直到我们在前一个迭代中发现其键是活动的时候才被认为是可达的），我们可能会花费二次时间处理弱指针。

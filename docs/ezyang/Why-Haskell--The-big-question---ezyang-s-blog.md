<!--yml

类别: 未分类

日期: 2024-07-01 18:18:33

-->

# 为什么选择 Haskell？重要问题：ezyang 的博客

> 来源：[`blog.ezyang.com/2010/01/why-haskell/`](http://blog.ezyang.com/2010/01/why-haskell/)

## 为什么选择 Haskell？重要问题

语言选择是一个有争议的事情，通常是在“选择适合工作的语言”和“尽可能少地使用语言以增加思维共享”之间做出妥协。例如，谷歌限制了他们的员工可以使用的编程语言；我已经开始认为，为自己的项目选择任何想要的语言是不负责任的，曾经有人告诉我，“是的... 那个项目是用 X 语言写的，除了写它的人以外没有人知道 X 语言... 也许把时间花在它身上并不是一个好主意。” 当然，我自己也很有过失；我曾用 Haskell 编写了刺客公会的会员会费跟踪系统，除非发生奇迹，我对未来的维护者能否处理它有些怀疑。

当我不负责任的时候，Python 是我大多数脚本需求的首选语言，因此我对 Haskell 能够消除的语言中的怪癖痛苦地有所了解。

+   Python 代码是动态类型的，变量没有作用域。除非执行了代码路径，否则不会捕捉到脑残类型错误、变量错误命名和纯粹的破损代码。 *它变得更好的地方:* `pylint -e` 可以捕捉到大类错误（但你通常必须在递归限制错误中寻找它，我坚信任何不在编译器内置的错误检查最终都会被最需要它的人忽视），以及无论你有什么自动化测试，都可以完全覆盖代码。 *Haskell 的优点:* 静态分析足够完整，如果编译通过，那么运行就是正确的。

+   Python 运行速度慢。如果你不相信：问问自己为什么运行时不能快速加载以使 Python 作为 CGI 可行，或者为什么 Google 已经禁止在公共面向代码中使用它，或者为什么工程师们在无法再挤出更多速度时，会认为将 Python 守护程序重写为 C++ 是不可避免的结论。 *它变得更好的地方:* 并不是所有东西都必须运行得飞快。 *Haskell 的优点:* 疯狂的人们编写疯狂的编译器，如 GHC，可以编译成本地二进制文件，并具有绝对史诗般的速度。

+   Python 对于可理解的代码高尔夫有其局限性。虽然在 Python 中高级代码结构的重复程度不像在 Java 或 C++ 中那样严重，但是试图进一步净化代码往往会导致需要大量文档的高度难以理解的高阶函数。正如人们所说，“不要用 Python 写 Haskell。” *Haskell 的优点:* 类型系统不仅成为代码文档的重要部分，还作为一个框架，用户可以像拼乐高积木一样“捻”合子和数据，大大提高了对复杂性的容忍度。

+   Python 继承了一种老旧的面向对象范式。然而，我越来越确信基于类型类的系统（[Go](http://golang.org/) 是其中一种明确采纳的命令式语言）是未来的发展方向。结合类型签名，它们提供了面向对象编程的两个主要优点：功能的逻辑组织和多态性，而避免了多重继承、混入、元类等复杂的问题。*Haskell 之所以优秀：* 对类型类的一流支持。

+   Python 的线程支持极差。它有全局解释器锁。*Haskell 之所以优秀：* 它不仅拥有快速、绿色线程和纯洁性的概念，使得分割计算变得可行，还极大地简化了用于计算的调度算法的实验。在这个领域我说不了更多，因为我几乎没有编写并行 Haskell 代码的经验。

但是，如果我尝试在 Haskell 中编写我在像 PHP 或 Python 这样的命令式语言中完成的大型项目之一（我提到这两种特定语言，因为我在它们之中构建了 [两个](http://htmlpurifier.org) [系统](http://scripts.mit.edu/wizard) ，而这些系统实际上非常大），我会感到不安，原因如下：

+   Haskell 的库支持尚不足以成为完全多范式。我对于任何给定的 Python 代码的直接移植是否可能持高度怀疑；尽管通过像 Text.Printf 这样的包将 Python 的更动态特性引入 Haskell 的类型系统取得了巨大进展，但命令式程序固有的远距离操作要求在 Haskell 中进行大量的 IO 巧妙操作。

+   在命令式领域中，很难确定哪些问题确实更适合保留在命令式领域，正如 [James Hague](http://prog21.dadgum.com/54.html) 最近所思索的。 Haskell 社区普遍认为，尽可能少地将代码放在 IO 单子中是合理的，但是当我们引入命令式世界的小部分来帮助我们，例如状态单子，我们承认命令式范式是有用的…… 或者至少是一种轻松的出路。也许如果我们更加努力，我们可以找到一个更加优雅、可维护的纯函数解决方案；而学术界喜欢做的事情之一就是弄清楚这些事情。但是即使对于那些习惯于功能性思维的人来说，这也是困难的，答案通常需要发现，更不用说实现了。

+   所有从多年对大型命令式代码库的开发中积累的工程传说、智慧和最佳实践，可能不再适用于函数式代码库。如果函数式库鼓励尽可能解耦，我们是否需要在 API 中进一步解耦？纯代码是否需要记录日志，或者其确定性使其易于调试？我们需要进行哪些测试，我们对类型有多少信任？函数式代码库的 API 文档和交叉引用需要如何发展？在纯 Haskell 代码的逻辑错误调试中应该如何进行？

然而，有[一些公司](http://www.galois.com/)正在使用 Haskell 编写生产规模的代码库，这让我对这些问题的答案很乐观；即使不是对于 Haskell，对于其他纯函数式语言也是如此。而在命令式世界中的“经典”解决方案往往导致潜在的错误，特别是在多线程应用程序的世界中，我们*决不能*满足于“够好”的状态。软件糟糕透了，但具有强大、灵活类型的纯函数式系统有望消除大部分这种问题。这就是为什么我选择 Haskell。

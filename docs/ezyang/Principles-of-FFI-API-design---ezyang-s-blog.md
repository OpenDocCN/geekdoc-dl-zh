<!--yml

category: 未分类

date: 2024-07-01 18:18:16

-->

# FFI API 设计原则：ezyang 的博客

> 来源：[`blog.ezyang.com/2010/06/principles-of-ffi-api-design/`](http://blog.ezyang.com/2010/06/principles-of-ffi-api-design/)

本文是关于[c2hs 的六部分教程系列中的第三部分](http://blog.ezyang.com/2010/06/the-haskell-preprocessor-hierarchy/)。今天，我们从 FFI 绑定的细节回顾中退后一步，讨论您的库的更一般设计原则。

一方面，编写 FFI 绑定可能只不过是生成胶水代码，让您能够在“Haskell 中使用 C”，而您的库的 API 则完全取决于原始库的作者的心血。另一方面，您可以立志使您的接口与纯 Haskell 编写的内容无异，引入自己的适度创新，以将 C 代码中非正式记录的不变量编码到类型系统中。

*整体设计.* 更大的绑定从分为两个层面中受益：低级绑定和更高级的用户友好绑定。使 C 函数可供 Haskell 调用需要大量的代码，将其存储在自己的命名空间中是显而易见的，通常名称中包含`Internal`。

*低级设计.* 在低级绑定中，应按照 C 头文件的方式组织您的外部导入项。保持名称相似。虽然不可能拥有相同的 C 函数名称和 Haskell 函数名称——C 函数允许以大写字母开头，而 Haskell 函数不允许（类型和数据构造函数相反），但仍可以采用一致的转换。默认情况下，c2hs 将 C 中的`Foo_BarBaz`转换为`fooBarBaz`；即在下划线后的单词大写，第一个字母不大写，并移除下划线。

然而，原始 API 还有改进的空间。经验法则是，如果可以进行改进安全性或可用性的非侵入/局部更改，则应该这样做。这些包括：

+   将普通 C 值（如`int`、`float`甚至`char*`，如果它是以空字符结尾的字符串）转换为它们自然的 Haskell 形式（`Int`、`Float`和`String`）。需要小心，因为本地 Haskell 类型会损失其 C 对应类型的精度，因此应确保应用程序不需要挤出每一个更高的位（例如通过位字段）。80%的时间，可以接受有损转换，

+   将`int`从某种命名约定转换为`Bool`（也许布尔值以`f`作为`flag`的前缀），

+   将`malloc`分配的指针放入外部指针的内存管理中。这个建议值得重复强调：Haskell 有内存管理，而且尽快使用它*是非常重要的*。此外，您不必编写显式的 Haskell 释放函数。

+   将一些初始化某些内存空间的函数（`set_struct_default`）转化为使用`unsafePerformIO`、`alloca`和`peek`的纯版本（`structDefault`）。请注意，你应该与适当的`Storable`实例一起执行此操作，以将 C 结构体转换为持久的 Haskell 数据类型。

+   将更复杂的 C 值（主要是数组）转换为 Haskell 列表，假设边界信息一致且本地可用。

我们将在接下来的帖子中更详细地讨论这些技术，因为这正是 c2hs 最常用的地方。

知道何时不进行简化是有用的：某些类型的库可能对大型结构有高效的内存表示；将它们从 Haskell 中逐出和入驻是浪费的。编写不好的 C 代码也可能会给你传递数组，你很难找到它们的长度；推迟它们的逐出和入驻到更高级别的接口可能是一个更好的选择。决定哪些结构明确地*不*逐出和跨越整个委员会。我的偏好是逐出不包含指针的扁平结构，其他的什么都不做。

*高级设计*。虽然肯定有像箭头、应用函子和余函子这样的异国情调的计算结构，在某些领域可能很有用，但我们将限制讨论到 Haskell 程序员常用的工具：纯函数和单子。

+   *纯函数*。将 C 语言构建的可变底层转化为更为宝贵的纯函数和持久数据结构是一个棘手的任务，充满了`unsafePerformIO`。特别是，仅仅因为一个 C 函数表面上看起来不涉及任何变异，它可能执行一些共享状态改变或重新平衡输入数据结构，或者在失败时进行`printf`，你必须考虑到这一点。除非你的文档非常好，否则你需要进行源代码深入挖掘来手动验证不变量。

    将一些可参考透明的函数变成纯函数是一个珍贵的商品，可以轻松转换。从这里开始，你需要做出关于库如何使用和不使用的决定。一组内部状态变换函数可能不适合纯处理，但也许一个将它们一起编排的函数不会泄露共享状态。本来打算被改变的数据结构可以转换为不可变的 Haskell 版本，或者通过你的 API 冻结，不向最终用户公开它们的变异方法（好吧，除了带有`unsafe`前缀的方法）。

+   *单子*。首先是一个显而易见的选择：你是将所有函数都扔进 IO 单子中，还是给用户一个更为受限的单子堆栈，这个堆栈在底层执行 IO 操作，但只允许用户执行与你的库相关的操作。（这并不难做到：你可以使用`newtype`定义你的单子堆栈，然后简单地不导出构造函数并省略`MonadIO`实例。）

    ```
    newtype MyMonad a = MyMonad { unMyMonad :: ReaderT Env IO a }
      deriving (MonadReader Env, Monad, Functor)

    ```

    您将经常传递隐藏状态，以指针的形式。这些应该用新类型封装起来，而不暴露给最终用户。有时，这些将是指针的指针，例如具有参数`**ppFoo`的库的情况，它接受您的指针并将其重写以指向其他地方，吞并原始对象。

    ```
    newtype OpaqueStruct = OpaqueStruct { unOpaqueStruct :: ForeignPtr (Ptr CStruct) }

    ```

    共享状态意味着线程安全也成为重要问题。Haskell 是一种非常友好的多线程语言，作为库的用户，很容易假设任何给定的库都是线程安全的。这是任何库作者值得追求的一个令人钦佩的目标，但这一目标因您依赖于基于 C 的库而变得更加困难。幸运的是，Haskell 提供了使线程安全变得更加容易的原语，特别是 MVar、TVar 和 TMVar；只需将您的指针存储在这个共享变量中，并且不让任何其他人使用这个指针。对于复杂的指针图形，需要额外的注意确保，如果您有一个表示某些共享状态锁的 MVar，那么没有其他 C 代码会随意使用别处隐藏的指针。当然，如果您有持久化结构，维护一致性就变得微不足道。

    ```
    withMVar (unOpaqueStruct o) $ \o_ ->
      withForeignPtr o_ $ \p ->
        -- peek ’n poke the piggy, erm, pointer

    ```

    一种特别好的技术，用于防止最终用户从您的美丽线程安全部分中走私指针，是应用类似于`ST`单子的二阶类型。基本假设是，您编写一个类型为`(forall s. m s a) -> a`的函数。对该函数参数的`forall`约束要求结果`a`在其类型中不包含`s`（对于技术上更倾向的人来说，`forall`是一个声明，我应该能够将任何`s`放在声明中，并且它是有效的。如果某个特定的`s'`在`a`中，那么只有当我将我的`s`设置为那个`s'`时，它才有效，而且没有其他`s`）。因此，您只需将幻影类型变量`s`添加到任何您不希望从单子中走私出去的数据类型中，类型系统将会处理其余的事情。单子区域在此基本概念上构建，赋予其*组合性*（区域多态性）。

    ```
    newtype LockedMonad i a = LockedMonad { unLockedMonad :: ReaderT Env IO a }
      deriving (MonadReader Env, Monad, Functor)
    runLockedMonad :: (forall i. LockedMonad i a) -> IO a
    runLockedMonad m = runReaderT (unLockedMonad m) =<< newEnv
    data LockedData i a = LockedData a

    ```

我们不会讨论这些想法作为 c2hs 的一部分；预处理器的使用在设计过程的大部分时间内是独立的。但是，这确实是一个非常有趣的主题！

*下次再讲.* [c2hs 的第一步](http://blog.ezyang.com/2010/06/first-steps-in-c2hs/)

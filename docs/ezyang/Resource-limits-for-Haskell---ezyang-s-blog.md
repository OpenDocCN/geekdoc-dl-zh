<!--yml

分类：未分类

日期：2024-07-01 18:17:22

-->

# Haskell 的资源限制：ezyang 博客

> 来源：[`blog.ezyang.com/2013/04/resource-limits-for-haskell/`](http://blog.ezyang.com/2013/04/resource-limits-for-haskell/)

上周，我第一次向 ICFP 提交了我的论文！主题是？一个我曾经热衷的老问题：如何限制 Haskell 程序的空间使用。

> 我们描述了 Haskell 资源限制系统的第一次迭代，利用资源限制与性能分析的语义和实现策略相同的关键观察。我们特别关注限制常驻内存使用的问题：我们描述了一种简单的实现技术来执行增量堆调查，并描述了一种处理强制资源回收的新型信息流控制解决方案。该系统实现为 GHC 的一组补丁。

你可以在[这里获取提交的副本。](http://ezyang.com/papers/ezyang13-rlimits.pdf) 我在下面重现了关于如何分析 Haskell 的背景部分；如果你对此感兴趣，可以查看论文的其余部分！

* * *

Haskell 的性能分析是通过将计算成本分配给“当前成本中心”来完成的。*成本中心*是一个抽象的、由程序员指定的实体，可以向其收取成本；在任何给定时间内，每个线程只能有一个活动的*成本中心*，而*成本语义*决定了程序执行过程中当前成本中心的变化。例如，`scc cc e`表达式（设置成本中心）在评估`e`期间修改当前成本中心为`cc`。成本中心在编译时静态定义。

Haskell 的成本语义是由 Sansom 等人（1995 年）定义的。此前，在惰性评估和高阶函数存在的情况下，如何分配成本并没有形式化的解释；这篇论文解决了这些问题。他们论文的两个关键观点是：首先，他们明确指出成本分配应该与评估顺序无关。为了易于理解，一个 thunk 是立即评估还是稍后评估不应影响谁为其付费。其次，他们观察到在函数的成本分配上有两种方式，直接对应于词法作用域和动态作用域之间的差异。

通过这个程序可以看到成本分配无关顺序的原则：

```
f x = scc "f" (Just (x * x))
g x = let Just y = f x in scc "g" y

```

当调用`g 4`时，评估`x * x`的成本应该由谁承担？对于严格评估，很容易看出应该由`f`承担，因为`x * x`是在`scc`表达式内部立即评估的。而无关顺序则决定，即使将`x * x`的执行延迟到`scc "g" y`的内部，成本仍然应该归于`f`。通常情况下，对于变量`x`的`scc "f" x`是一个无操作。为了实施这样的方案，必须在分配 thunk 时记录当前成本中心，并在强制 thunk 时恢复它。

函数成本归因方面的词法作用域和动态作用域的区别可以在这个例子中看到：

```
f = scc "f" (\x -> x * x)
g = \x -> scc "g" (x * x)

```

这两个函数有什么区别？我们处于类似于 thunks 选择的情况：当前成本中心是否应该与闭包一起保存，并在函数调用时恢复？如果答案是肯定的，我们使用词法作用域，这两个函数是等效的；如果答案是否定的，我们使用动态作用域，`f`中的`scc`是一个空操作。 GHC 当前为`scc`选择的策略是动态作用域。

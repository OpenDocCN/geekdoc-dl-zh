<!--yml

category: 未分类

date: 2024-07-01 18:17:27

-->

# OfflineIMAP 工作原理：ezyang 的博客

> 来源：[`blog.ezyang.com/2012/08/how-offlineimap-works/`](http://blog.ezyang.com/2012/08/how-offlineimap-works/)

作为软件工程师，我们对这样的营销文案总是有些怀疑：

> OfflineIMAP 是安全的；它使用一种设计来防止任何情况下的邮件丢失。由于该算法的设计，即使是编程错误也不会导致邮件丢失。我对这个算法如此自信，以至于我用自己的个人和工作账户来测试 OfflineIMAP 的预发布、开发和测试版发布。

这个算法是什么？它为什么有效？它的正确性证明在哪里？不幸的是，OfflineIMAP 的最终用户文档中没有详细描述这个算法的内容，以便软件工程师能够确信 OfflineIMAP 的正确性。幸运的是，OfflineIMAP 是开源的，因此我们可以找出这个神秘算法的内容。实际上，OfflineIMAP 的同步算法非常简单和优雅。（Nota bene：为简单起见，我们不考虑消息标志的同步。）

### 准备工作

定义我们的本地和远程仓库（分别为 Maildir 和 IMAP）为消息集合 L 和 R。在不删除同步方案中，我们希望执行一些操作集，以使仓库 L' 和 R' 的最终状态为 L ∪ R。

然而，对于邮件而言，不删除的同步方案效果不佳，我们希望能够删除消息并使这些更改传播。为此，OfflineIMAP 定义了第三个称为状态库的仓库，也是一组消息的集合，用于指示消息是否过去曾同步过而没有中间同步删除。现在消息有七种可能的状态，基于它们属于哪些仓库：

考虑所有可能的组合：

+   **已同步** (L,R,S)：消息已完全同步，无需进一步处理。

+   **本地新增** (L)：消息是新添加到本地仓库中，需要上传。

+   **远程新增** (R)：消息是新添加到远程仓库中，需要下载。

+   **状态丢失** (L,R)：消息已同步，但我们的状态已过时。

+   **远程删除** (L,S)：消息已同步，但之后从远程删除；现在应该从本地删除。

+   **本地删除** (R,S)：消息已同步，但之后从本地删除；现在应该从远程删除。

+   **丢失** (S)：消息已在所有地方删除，而我们的状态中有一个过时的条目。

Venn 图表的绿色阴影区域是我们希望在同步结束时 L、R 和 S 覆盖的部分。

### 算法

定义同步操作源、目的地和状态库 `syncto(src, dst, status)` 为以下两个步骤：

1.  计算集合差异 `src - status`，并将这些消息复制到 `dst` 和 `status`。

1.  计算集合差异 `status - src`，并从 `dst` 和 `status` 中删除这些消息。

然后完整的同步算法是：

1.  `syncto(R, L, S)`（下载变更）

1.  `syncto(L, R, S)`（上传变更）

### 如何运作

在没有崩溃的情况下，正确性证明仅涉及验证状态仓库不变式（过去已同步消息且没有中间同步删除的消息），这一不变式在所有四个操作中都得到保持，并且确实是我们希望复制和删除的消息集的精确集合差异。然而，我们也可以尝试查看随着算法的进行，本地、远程和状态仓库的变化。特别是，在第一个 `syncto` 中，状态仓库的内容演变方式略有惊讶，尽管对它应用了相同的操作（然后它与 `remote` 一起同步进展）。

另一个重要的正确性声明是，OfflineIMAP 永远不会“丢失邮件”。在什么情况下会删除邮件？当它存在于状态仓库中，但不在本地或远程仓库中时。因此，很容易看出，当状态仓库“丢失”（无论是损坏还是按照指示删除本地文件夹内容时），OfflineIMAP 将在两个源之间进行全面的、不删除的同步。只要状态仓库不包含比应该有的更多消息的数据，OfflineIMAP 就不会删除您的邮件。

### 变体

假设我在本地磁盘上为 Maildir 提供的磁盘空间比远程 IMAP 服务器多。最终，你将会处于这样的尴尬境地：希望从远程 IMAP 服务器删除消息，而不会从本地邮件存储中彻底删除它们。OfflineIMAP 提供了 `maxage` 选项（其中 OfflineIMAP 拒绝承认比某个滑动窗口更老的消息的存在），但如果我们*真的*希望确保 OfflineIMAP 永远不会从我的本地仓库中删除消息，会怎样呢？

简单：跳过步骤 1-2。

### 结论

通过利用第三个仓库，对程序的部分数据丢失导致*保守*的操作，OfflineIMAP 实现了其*不惜一切代价防止邮件丢失的算法*声明。这也是一个简单的算法，我希望任何使用这个软件的计算机科学家或软件工程师都能花时间确保其正确性，而不是依赖于某些市场材料的传闻。

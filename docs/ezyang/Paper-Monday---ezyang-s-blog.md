<!--yml

category: 未分类

date: 2024-07-01 18:18:12

-->

# Paper Monday : ezyang’s blog

> 来源：[`blog.ezyang.com/2010/08/paper-monday/`](http://blog.ezyang.com/2010/08/paper-monday/)

上周末，我乘坐灰狗巴士去西雅图见了一些朋友。灰狗巴士非常晚：在去程的情况下晚了四十五分钟，这意味着我在没有互联网的车站有了一些自己的时间。我制定了唯一明显的行动方案：开始处理我的待读论文堆积。在这个过程中，我发现一个自 2009 年 12 月以来一直在我的待读列表中的论文实际上直接涉及到我上周四在 Galois 进行调试（不成功）时遇到的一个重要问题。

这里是我阅读过的论文和幻灯片——有些是旧的，有些是新的——以及为什么你可能也对它们感兴趣。（天啊，并不全是 Haskell！）

* * *

[流行就是一切](http://research.microsoft.com/apps/pubs/?id=132859)（2010），由 Schechter、Herley 和 Mitzenmacher 撰写。标语：*当假阳性是一件好事！*

> 我们建议通过允许互联网规模系统的用户选择任何他们想要的密码来加强用户选定的密码对统计猜测攻击的抵抗力，只要这些密码不是已经太过流行。我们创建一个用现有用户密码填充并且每次有新用户密码更新的 Oracle 来识别不受欢迎的流行密码，使用的是一个称为[count-min sketch](http://www.eecs.harvard.edu/~michaelm/CS222/countmin.pdf)的现有数据结构。与大多数概率数据结构的应用不同，这些只追求最大可接受的假阳性率，我们设定了一个最低可接受的假阳性率，以困扰可能查询或甚至获取它的副本的攻击者。

[Nelson](http://blog.nelhage.com/)向我介绍了这篇论文；它是对诸如[Bloom filters](http://en.wikipedia.org/wiki/Bloom_filter)之类的概率数据结构的实际应用，利用它们的假阳性率：试图使用你的密码流行度数据库来弄清哪些密码流行的攻击者将得到大量被称为流行但实际上并非如此的密码。这个数据结构也相当简单：有人应该将其作为一个周末项目与一个流行的 Web 框架的认证机制集成起来！

* * *

[Ropes: an Alternative to Strings](http://www.cs.ubc.ca/local/reading/proceedings/spe91-95/spe/vol25/issue12/spe986.pdf)（1995），由 Boehm、Atkinson 和 Plass 撰写。标语：*你所需的只是串联*。

> 编程语言通常提供‘字符串’或‘文本’类型来允许操作字符序列。这种类型通常至关重要，因为它通常在系统组件之间的大多数接口中被提到。我们认为传统的字符串实现，以及通常支持的功能，不适合这样的通用用途。它们应该限于具有特定且不寻常的性能要求的应用程序。我们提出‘ropes’或‘重量级’字符串作为一种选择，根据我们的经验，这种选择会导致功能和性能更加强大的系统。

当你上次索引字符串以获取单个字符是什么时候？如果你正在处理多字节编码，那么这个操作可能毫无意义！相反，你更可能关心搜索、切片或连接字符串。从业者们可能会认为这是对渐近性能而非真实世界性能的关注，但是这篇论文非常明确地指出，文本编辑器是传统 C 字符串极不高效的非常实际的例子。对于大部分时间都在连接字符串的 Web 开发者来说，Ropes 似乎是一个很好的选择。

* * *

[Autotools 教程](http://web.mit.edu/~ezyang/Public/autotools.pdf)（最后更新于 2010 年）由 Duret-Lutz 撰写。（因为经典网站在撰写时似乎宕机，此处再次托管。）标语：*Hello World：Autotools 版。*

> 这份演示文稿针对熟悉 Unix 开发工具（shell、make、编译器）并希望学习 Autotools 的开发者。

尽管它的标题不起眼，但这份幻灯片已成为大多数朋友的默认推荐，如果你想弄清楚这个“autogoo”究竟是什么。在我看来，它是可移植编译共享库。也许这份演示文稿之所以如此出色，是因为它假定了正确的背景（即大多数对 autotools 感兴趣但是新手的背景），并用许多动画图表清楚地解释了程序生成哪些文件的黑魔法。

* * *

[类型函数乐趣](http://research.microsoft.com/~simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf)（2009）由 Oleg Kiselyov、Simon Peyton Jones 和 Chung-chieh Shan 撰写。另请参阅[Haskellwiki](http://www.haskell.org/haskellwiki/Simonpj/Talk:FunWithTypeFuns)。标语：*放下那些 GHC 文档，来阅读这篇文章吧。*

> Haskell 的类型系统通过两个独特的特性扩展了 Hindley-Milner：类型构造器上的多态性和使用类型类进行重载。这些特性从 Haskell 诞生之初就成为其不可或缺的一部分，广泛被使用和欢迎。最近，Haskell 还增加了类型族或关联类型，允许将类型上的函数像对值的函数一样直接表达。这一功能使得程序员能够通过编写在类型检查期间执行的函数式程序有效地扩展编译器。

我认识的许多程序员对论文和 PDF 有所厌恶：我认识的其中一个曾经说过，如果可以的话，他愿意付钱请人写博客文章而不是写论文。这种态度可能会让他们忽略掉像这样的论文，而这篇论文真正是你一直在寻找的有关类型族的教程。论文中没有讨论底层实现：只有三十五页的类型级别编程示例。在此过程中，他们涵盖了可变引用的接口（考虑 STRef 和 IORef）、算术、图形、记忆化、会话类型、sprintf/scanf、指针对齐和锁！在许多方面，它就是我之前提到的那本烹饪书，我一直在寻找[我的博文 Friday](http://blog.ezyang.com/2010/08/the-gateway-drug-to-type-programming/)。

* * *

[纯函数式惰性非确定性编程](http://www.cs.rutgers.edu/~ccshan/rational/lazy-nondet.pdf)（2009）由 Sebastian Fischer、Oleg Kiselyov 和 Chung-chieh Shan。标语：*分享和关心也可以很有趣！*

> 函数逻辑编程和概率编程展示了将惰性（非严格评估与结果共享）与非确定性结合起来的广泛好处。然而，由于功能语言中用于非严格性、共享和非确定性的现有特性很难组合，这些好处很少被享受到。
> 
> 我们提出了一种实用的方式来编写纯函数式的惰性非确定性程序，既高效又明了。我们通过将程序嵌入现有语言（如 Haskell、SML 和 OCaml）的高质量实现中实现了这一目标，通过惰性选择和非确定性组件来表示数据，通过使用自定义的单子数据类型和搜索策略来工作，并为程序员提供方程法则，以便他们推理自己的代码。

这篇论文正好对我在工作中处理的一些代码问题如实地击中要害：我基本上已经将一个纯粹的有向无环图转换为了一个单子结构，并且在此过程中，我设法破坏了共享常见节点，导致结果树呈指数增长。在处理非确定性环境中共享的显式处理中，为了得到一些理想的特性，帮助我澄清了我对如何破坏共享的思考（我现在完全同意约翰·马修斯的观点，我需要一个显式的记忆机制），因此我期待明天在工作中应用一些这些技术。

* * *

到此为止，或者至少是，直到下一次*Paper Monday*！（如果读者们不先因此杀了我的话。对于那些好奇的人来说，当前的积压稿件有六十六篇，大部分只是浏览过，并没有完全理解。）

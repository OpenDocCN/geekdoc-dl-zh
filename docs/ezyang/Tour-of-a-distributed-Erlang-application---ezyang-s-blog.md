<!--yml

category: 未分类

date: 2024-07-01 18:18:12

-->

# 访问分布式 Erlang 应用程序：ezyang 博客

> 来源：[`blog.ezyang.com/2010/08/tour-of-preach-distributed-erlang/`](http://blog.ezyang.com/2010/08/tour-of-preach-distributed-erlang/)

今天的额外帖子！上周二，John Erickson 在 Galois 的技术讲座中发表了一篇名为 [“工业强度分布式显式模型检查”](http://vimeo.com/13865125)（[视频](http://vimeo.com/13865125)）的演讲，在其中他描述了 [PReach](http://bitbucket.org/jderick/preach)，这是一个基于 [Murphi](http://verify.stanford.edu/dill/murphi.html) 的开源模型检查器，Intel 用它来查找其模型中的错误。它旨在作为 Murphi 内置的分布能力的简化替代方案，利用 Erlang 实现了更简单的网络通信代码。

*第一个问题。* 你为什么在乎呢？

+   *模型检查很酷。* 想象一下，您有一组复杂的相互作用的并行进程，随时间不确定地演变，使用某种协议相互通信。您认为代码是正确的，但为了确保，您添加了一些检查不变量的断言：也许某些状态配置永远不会被看到，也许您希望确保您的协议永远不会死锁。测试这一点的一种方法是在现场运行一段时间，并在不变量失败时报告。模型检查允许您全面测试系统的所有可能状态演变，以查找死锁或违反不变量的情况。有了这个，您可以找出微妙的错误，并且您可以找出导致该事件的精确输入。

+   *分布式应用程序很酷。* 正如您可能想象的那样，需要检查的状态数量呈指数级增长。模型检查器应用算法来合并常见状态并减少状态空间，但是在某个时刻，如果您想测试更大的模型，您将需要更多的机器。PReach 已经让 Intel 的基础模型检查器 Murphi 的运行速度提高了五十倍（使用一百台机器）。

这次讲话更多地关注了 PReach 团队在使核心 Murphi 算法分布式化时遇到的挑战，而不是如何对您的应用程序进行模型检查（尽管我相信一些 Galwegians 也会对这个方面感兴趣）。我认为这给出了一个出色的高层次概述，展示了如何在 Erlang 中设计分布式系统。由于软件是开源的，我们将在高层次实现该系统的过程中链接相关的源代码行。

*该算法。* 从本质上讲，模型检查只是一种广度优先搜索。您获取初始状态，计算它们的后继状态，并将这些状态添加到待处理的状态队列中。

```
WQ : list of state // work queue
V : set of state   // visited states

WQ := initial_states()
while !empty(WQ) {
  s = dequeue(WQ)
  foreach s' in successors(s) {
    if !member(s', V) {
      check_invariants(s')
      enqueue(s', WQ)
      add_element(s', V)
    }
  }
}

```

*并行算法。* 现在我们需要将这个搜索算法并行化。我们可以在多台计算机上复制工作队列，将并行化问题转变为在多台计算机上分发工作负载。然而，访问状态集合比较棘手：如果我们无法将其有效地分区到多台机器上，它将成为共享状态并成为整个过程的瓶颈。

[Stern and Dill (PS)](http://sprout.stanford.edu/dill/PAPERS/verification/SD97.ps) 想出了一个巧妙的解决方案：使用哈希函数将状态分配给处理器。这有几个重要的含义：

+   如果哈希函数是均匀的，现在我们可以通过分割函数的输出空间来均匀地分配工作负载。

+   因为哈希函数是确定性的，任何状态都将始终发送到同一台机器。

+   因为状态粘附在机器上，每台机器可以维护独立的访问状态，并相信如果一个状态出现两次，它将被发送到同一台机器，并因此出现在该机器的访问状态中。

其一个缺点是，机器无法通过决定在本地处理自己的后续状态来节省网络延迟，但这对于不必担心共享访问状态的问题来说是一个公平的权衡，这被认为是一个难以有效解决的问题。

实现大部分这一逻辑的相关源函数是 [recvStates](http://bitbucket.org/jderick/preach/src/514dcacd581c/release-1.1/preach.erl#cl-770) 和 [reach](http://bitbucket.org/jderick/preach/src/514dcacd581c/release-1.1/preach.erl#cl-694)。

*积分机制。* 在运行 PReach 的早期版本时，PReach 的开发人员会注意到集群中的某些机器偶尔会因非确定性地大幅减速或崩溃。

发现这台机器被内存中的 Erlang 请求队列淹没：尽管哈希函数均匀分配消息，如果一台机器稍慢于其他机器，它将收到更多的状态，而无法及时处理。

为了解决这个问题，PReach 首先实现了一种退避协议，然后实现了一种积分协议。其直觉是：如果一台机器还没有确认你之前的 C 条消息，就不要向其发送消息。每次向另一台机器发送消息时，都会发送一个积分；当机器回复说它已处理完状态时，[积分会一同发送回来](http://bitbucket.org/jderick/preach/src/514dcacd581c/release-1.1/preach.erl#cl-794)。如果没有积分，则不发送任何消息。这将队列中待处理消息的数量限制为`N * C`，其中`N`是节点数（通常情况下是约 100 个，当 Intel 运行时）。为了防止内存中待处理状态的积累，当没有积分时，我们将它们保存到磁盘。

Erickson 不确定 Erlang 是否有一个内建功能来执行这个功能；对他来说，这似乎是网络协议的一个相当基本的扩展。

*负载均衡。* 虽然状态的分布是均匀的，但由于异构环境，某些机器可能能够比其他机器更快地处理状态。如果这些机器完成了它们所有的状态，它们可能会闲置不动，摆弄着大拇指，而慢速机器仍在处理它们的队列。

当这种情况发生时，一个要做的事情是让繁忙的节点注意到有一台机器正在空闲，并向它们发送它们的状态。Erickson 引用了[Kumar 和 Mercer (PDF)](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.94.2832&rep=rep1&type=pdf) 关于这个主题的一些工作。他的见解是，过于热衷于负载均衡和根本不进行负载均衡一样糟糕：如果负载均衡器试图保持所有队列完全相同，它将浪费大量网络时间将状态推送到网络中，因为机器的速度波动。相反，只有在注意到某人的状态比你少 X 倍（其中 X 大约为 5）时才发送状态。

一个可能出现的问题是：这种方式的状态移动是否会导致我们早期用于访问状态检查的聪明办法停止工作？答案幸运地是不会！机器上的状态可以在两个地方之一：内存中的 Erlang 接收队列或磁盘上的工作队列。当将消息从接收队列转移到工作队列时，[将执行访问测试](http://bitbucket.org/jderick/preach/src/514dcacd581c/release-1.1/preach.erl#cl-798)。当我们向懒汉推送状态时，这些状态是从我们的工作队列中[获取的](http://bitbucket.org/jderick/preach/src/514dcacd581c/release-1.1/preach.erl#cl-817)：懒汉仅执行不变检查和状态扩展（并且还无害地将该状态添加到他们的访问状态列表中）。

*恢复共享状态。* 当不变量失败时，如何创建一个回溯，显示导致此状态的事件序列？任何给定状态的处理都分散在许多机器上，这些机器需要再次拼接在一起。诀窍是在传递后继状态时，不仅传输当前状态，而且[还传输前一个状态](http://bitbucket.org/jderick/preach/src/514dcacd581c/release-1.1/preach.erl#cl-793)。接收方然后[将这两个状态记录到磁盘](http://bitbucket.org/jderick/preach/src/514dcacd581c/release-1.1/preach.erl#cl-804)。当您想要追溯时，您始终可以[查看先前的状态并对其进行哈希，以确定该状态来自哪台机器](http://bitbucket.org/jderick/preach/src/514dcacd581c/release-1.1/preach.erl#cl-350)。

*在现场中。* Intel 在多达 256 个节点的集群上使用 PReach，以测试多达三百亿状态的微体系结构协议的真实模型（据 Erickson 知道，这是任何模型检查器在真实模型上完成的状态最多的数量）。

*Erlang 的痛点。* Erickson 对 Erlang 的主要抱怨是它没有为与 C++ 大量接口的代码提供良好的性能分析工具；他们希望能够更优化他们的代码性能，但很难确定最慢的部分在哪里。或许一些 Erlang 爱好者对此有所评论？

<!--yml

category: 未分类

date: 2024-07-01 18:17:43

-->

# IVar 泄漏：ezyang 的博客

> 来源：[`blog.ezyang.com/2011/07/ivar-leaks/`](http://blog.ezyang.com/2011/07/ivar-leaks/)

## IVar 泄漏

首先要说服自己的是，确实存在一个问题，即[我上周发布的代码。](http://blog.ezyang.com/2011/07/scheduling-ivar/) 由于这是一个内存泄漏，我们需要跟踪 IVar 的*创建*和*访问*。IVar 分配发生在我们示例的以下情况中：

1.  对`return`的调用，返回一个完整的 IVar，

1.  对`tick`的调用，返回一个空的 IVar 并安排一个线程来填充此 IVar，

1.  对`>>=`的调用，返回一个空的 IVar 和一个附加到左 IVar 的回调的引用。

当我们解引用 IORef、添加回调或填充 IVar 时，发生 IVar 访问。这发生在以下情况下：

1.  对`>>=`的调用，解引用左 IVar 并添加一个回调，

1.  对`>>=`左参数的回调调用，将一个回调添加到`f x`的结果中，

1.  对`f x`的结果（从上述回调中）进行回调调用，填充在（3）中分配的原始 IVar，

1.  由`tick`调度的线程的回调调用，用于填充其调度的空 IVar。

现在我们可以追踪代码`loop = tick >>= loop`中由`>>=`分配的 IVar 的生命周期。

1.  由`>>=`分配的 IVar。生成两个引用：一个在附加到`tick`的回调中，一个返回的引用中。

1.  调度程序运行填充来自`tick`的 IVar 的线程，运行其回调。IVar 可通过新分配给`f x`的回调访问。请注意，此处的`f`是`\() -> loop`，因此此时发生递归调用。

1.  调度程序运行填充来自`f x`的 IVar 的线程，运行其回调。IVar 已填充，并且回调链中对其的引用现在已经失效。IVar 的生命周期仅依赖于我们向客户端返回的引用。

请注意，在第一轮和第二轮调度器中，绑定分配的 IVar 通过非返回给客户端的引用保持活跃。在第一种情况下，它通过对 tick 的回调保持活跃（进而通过其在执行计划中的位置保持活跃）；在第二种情况下，它通过对`f x`的回调保持活跃。如果我们能够进入第三种情况，所有内容都将设法被 GC 回收，但这是一个大*if*：在我们的无限循环中，`f x`永远不会被填充。

即使最终被填充，我们也会积累递归长度的`IVar`，而如果我们有某种“尾递归优化”，我们可以立即丢弃这些`IVars`。

<!--yml

category: 未分类

date: 2024-07-01 18:18:13

-->

# 管道和延续：ezyang 的博客

> 来源：[`blog.ezyang.com/2010/07/pipelines-and-continuation/`](http://blog.ezyang.com/2010/07/pipelines-and-continuation/)

*注意保守提醒。* 函数管道提供了一种直观的方法来思考延续：延续传递风格仅仅*实现*了管道。如果你了解延续，这篇文章可能不会给你太多新东西；否则，我希望这是一个有趣的新视角。为什么你要关心延续？它们通常是实现算法的极快方法，因为它们本质上是纯粹的（管道）流控制。

在 [Real World Haskell](http://book.realworldhaskell.org/read/io-case-study-a-library-for-searching-the-filesystem.html) 中，一种有趣的模式在使用函数组合 `(.)` 的函数式程序中反复出现，称为：管道。它有几种形式：Lisper 可能将其知为“我需要多少个闭括号？”综合症：

```
(cons 2 (cdr (cdr (car (car x)))))

```

Haskeller 可以看到它以多种形式出现：带括号的形式：

```
sum (map (+2) (toList (transform inputMap)))

```

或者是 `$` 符号的行军：

```
sum $ map (+2) $ toList $ transform inputMap

```

或者更高阶的组合操作符（正如几位 `#haskell` 的居民建议的良好风格）：

```
sum . map (+2) . toList . transform $ inputMap

```

这种最终形式在词法上有一些有趣之处：`$`符号将其分为两个标记，一个是函数，一个是输入参数。我可以轻松地复制左侧并将其插入到另一个管道中（与括号相比，插入后我必须手动插入缺失的右括号）。这个函数也是一流的值，我可以以点无关的风格编写它并将其赋给一个变量。

当然，如果我想要移动它，我必须剪切和粘贴它。如果我想把它分成几个小部分，我必须用键盘拉开点。如果我想在一个情况中使用一个管道，在另一个情况中使用另一个管道，我必须决定在编写程序时处于哪种情况下。如果一个程序能在运行时为我做这件事，那岂不是很好？*眨眼*。

考虑一个类似 Lisp 的语言中的以下管道：

```
(h (g (f expr)))

```

当我们提到`expr`的“延续”时，通常会尝试将整个管道可视化，移除`expr`后，其位置留下一个空洞。这就是延续的概念：

```
(h (g (f ____)))

```

就视觉效果而言，它可能更糟。因为延续实际上是一个函数，为了真正准确，我们应该写一些极端无教育意义的东西，如下所示：

```
(lambda (x) (h (g (f x))))

```

但这是好的：它准确地捕捉了延续的概念，并且适合更简洁的形式。也就是说，这可以在 Haskell 中以点无关的形式写成：

```
h . g . f

```

所以延续就是表达式左侧的管道！

*稍微详细一点，涉及更多的管道。* 在大多数延续的处理中有两个混合因素：

+   它们并不是用纯语言编写的，一系列连续的操作并不立即适合进行管道化（尽管通过 monad 的力量，我们可以这样做），而且

+   我所给出的例子仍然涉及复制粘贴：通过复制粘贴，我已经忽略了一些细节。程序如何知道当前 continuation 是`h . g . f`？在 callCC 中，它如何知道当前 continuation 何时被调用？

供参考，这里是`Cont`单子的一个实现：

```
newtype Cont r a = Cont { runCont :: (a -> r) -> r }
instance Monad (Cont r) where
  return x = Cont (\k -> k x)
  (Cont c) >>= f = Cont (\k -> c (\r -> runCont (f r) k))

```

我的好管道去哪儿了？我看到了很多 lambda 函数...也许`Functor`实例会提供更多线索：

```
instance Functor (Cont r) where
  fmap f = \c -> Cont (\k -> runCont c (k . f))

```

那个小的组合操作符应该显眼：它阐述了这个 Functor 定义的本质。其余的只是管道工作。也就是说，当我们将一些常规函数（或管道）提升到 continuation 单子中时，我们增加了将任意函数*组合到其左端*的能力。也就是说，`k . g . f`，其中`k`是我添加的函数（continuation）。更详细地说，从：

```
g . f

```

到：

```
\k -> k . (g . f)

```

或者，用点：

```
\x k -> (k . g . f $ x)

```

现在有一个谜题：假设我有一个函数`h`。如果我不在 continuation land 中，我可以将它与`g . f`组合为`h . g . f`。但如果两者都在 continuation land 中：`\k1 -> k1 . (g . f)`和`\k2 -> k2 . h`，现在我如何组合它们呢？

`k1`处于我通常会放置 h 的位置，所以第一步是将第一个提升的函数应用于第二个提升的函数作为它的参数：

```
\k1 -> k1 . (g . f) $ \k2 -> k2 . h
(\k2 -> k2 . h) . (g . f)

```

那不太对；lambda 函数太早地关闭了它的括号。我们想要的是：

```
\k2 -> k2 . h . (g . f)

```

通过稍微多想一下（留给读者作为练习），我们找到了正确的形式：

```
\k -> (\k1 -> k1 . (g . f)) (\r -> (\k2 -> k2 . h) k r)
      \-- 1st lifted fn --/         \-- 2nd fn --/

```

这是 continuation passing style 的基本扭曲思维风格，读者会注意到，我们必须引入两个新的 lambda 函数来使整个过程运行（类似于我们的 Monad 实例）。这是 Continuation 单子的丑陋/优雅内部。此后，还有 newtype 包装和解包的重要问题，以及这实现了 Kleisli 箭头组合（`(a -> m b) -> (b -> m c) -> a -> m c`，而不是绑定`m a -> (a -> m b) -> m b`）。一切留给读者作为练习！（你觉得幸运吗。）

我们的最后一个话题是 callCC，生成有趣 continuation 实例的传统方法。在`Cont`单子中普通旧函数的基本特征是它们“不知道自己将去何处”。请注意，在我们所有的例子中，我们假设能够在左侧组合一个函数`k`，但实际上并没有指定那个函数是什么：它只是我们 lambda 中的一个参数。这引出了默认隐含 continuation 的概念：如果你不知道自己将去何处，这里有一个地方可以去。你可能会在`Cont`单子中编写的 monadic 代码，都在确定这些隐含 continuation 中发挥作用，当你运行 continuation 单子以获得结果时，你必须告诉它在最后要去何处。

`callCC`提供了一个“辣”的函数（当前延续），它*知道它要去哪里*。我们仍然向它传递一个值作为`k`（隐式延续），以防它是一个普通的旧函数，但当前延续会忽略它。延续单子中的函数不再必须遵循严谨的`\k -> k . f`公式。`callCC`的定义如下：

```
callCC f = Cont (\k -> runCont (f (\x -> Cont (\_ -> k a))) k)

```

这个“辣”的函数是`\x -> Cont (\_ -> k x)`（去掉封装后是`\x _ -> k x`），正如我们所见，它忽略了局部当前延续（对应于调用此函数的位置），而是使用了外部上下文中的`k`。`k`是在`callCC`调用时的当前延续。

与管道类似（尽管不完美）：考虑一个管道，其中我希望管道中的最后一个函数在成功时是一种类型的函数，在失败时是另一种类型的函数：

```
\succ fail -> either fail succ . h . g . f

```

这个管道有两种结果，成功：

```
\succ _ -> succ . fromRight . h . g . f

```

或者失败：

```
\_ fail -> fail . fromLeft . h . g . f

```

在每种情况下，另一种延续被忽略。对于`callCC`来说，关键在于，虽然显而易见如何忽略显式延续，但需要一点思考才能弄清如何忽略*隐式*延续。但是`callCC`生成的延续正是做到了这一点，并且可以在延续单子中的任何地方使用（你只需想出如何将它们放在那里：从`callCC`返回它或在带有状态的单子上使用`ContT`变换器都是可行的方式）。

*注意*。逻辑单子[使用成功（SK）和失败（FK）延续](http://hackage.haskell.org/packages/archive/logict/0.2.3/doc/html/src/Control-Monad-Logic.html)，而不使用`Cont`单子来实现回溯搜索，这表明延续传递风格可以在没有`Cont`单子的情况下存在，并且如果从默认隐式延续中不获益，则通常更清晰。`Cont`和`callCC`特别适合逃逸操作，这并非巧合。

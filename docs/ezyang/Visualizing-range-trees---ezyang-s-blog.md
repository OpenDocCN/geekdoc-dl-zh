<!--yml

category: 未分类

date: 2024-07-01 18:17:37

-->

# 可视化范围树：ezyang's 博客

> 来源：[`blog.ezyang.com/2012/02/visualizing-range-trees/`](http://blog.ezyang.com/2012/02/visualizing-range-trees/)

**范围树**是一种数据结构，可以让您有效地查询一组点，并找出在某个边界框内的点。它通过维护嵌套树来实现：第一级按 x 坐标排序，第二级按 y 坐标排序，依此类推。不幸的是，由于它们的分形性质，范围树有点难以可视化。（在更高维度的情况下，这绝对是一个“Yo dawg，我听说你喜欢树，所以我把一棵树放在你的树里...”）但是无论如何，我们打算通过利用一个*排序列表*基本上与平衡二叉搜索树相同的事实来可视化它们。（出于理智的考虑，我们还将限制自己到二维情况。）我还将描述一种用于构建范围树的好算法。

假设我们有一组点 ![(x_1, y_1), (x_2, y_2), \cdots (x_n, y_n)](img/9f27f271c1f48733661330c69079571f.png "(x_1, y_1), (x_2, y_2), \cdots (x_n, y_n)")。我们如何构建范围树？我们首先为 x 坐标建立一个平衡二叉搜索树（用蓝色标出）。我们可以通过使用您喜欢的排序算法对列表进行排序，然后从中构建 BBST 来完成此操作；但是，我们可以直接使用具有中位数查找的快速排序来直接构建树，如下图所示左侧。

一旦我们按照 x 坐标排序完毕，我们现在需要重新按照每个 x 子树的 y 坐标（用红色标出）进行排序，排序结果将存储在我们将在 x 子树内部存储的另一棵树中。现在，我们可以从头开始对每个列表进行排序，但是由于对于任何节点，我们正在计算其子节点的 y 排序树，我们可以像归并排序那样将它们合并在一起，如上图所示的右侧。（这就是 ![n\lg^{d-1} n](img/lg^{d-1} n") 中的 -1 来源！）

所以，当我们创建范围树时，我们首先对 x 坐标进行**快速排序**，然后对 y 坐标进行**归并排序**（保存中间结果）。如下图所示：

我们可以将这个图解释为一个范围树：顶层树是 x 坐标的平衡二叉搜索树（BBST），当我们到达叶子节点时，所有点都按照 x 坐标排序。然而，存储在中间节点内部的点代表 y 坐标的 BBST；每个列表都按 y 坐标排序，并隐式地表示另一个 BBST。我还在底部添加了一个显示这个范围树中保存的点的渲染图。

让我们以这个作为我们的工作示例。如果我们想要找到 x 坐标在 1 到 4 之间的点，我们搜索包含 1 的叶子节点，包含 4 的叶子节点，并获取这之间的所有子树。

如果我们想要在 y 坐标为 2 和 4 之间（包括）找到点，而不对 x 进行过滤，我们可以简单地查看存储在根节点中的 BBST 并执行范围查询。

当我们实际上想要执行边界框（例如 (1,2) x (4,4) 包括）时，事情就变得更有趣了：首先，我们定位 x-BBST 中的所有子树；然后，在每个 y-BBST 中进行范围查询。

这里有另一个例子 (4,4) x (7,7) 包括。这一次我们很幸运，只需要检查一个 y-BBST，因为 X 范围直接对应于一个子树。然而，一般情况下，我们只需要检查 ![O(\lg n)](img/lg n)") 个子树。

查询时间为 ![O(\lg² n)](img/lg² n)")，这是很容易理解的（因为我们可能需要在 ![O(\lg n)](img/lg n)") 棵树上执行一维范围查询，每次查询花费 ![O(\lg n)](img/lg n)") 的时间）。或许不太明显的是，这种方案只占用 ![O(n\lg n)](img/lg n)") 的空间。此外，我们实际上可以通过一种称为*分数级联*的技巧将查询时间降低到 ![O(\lg n)](img/lg n)")。但这是另一篇[博文！](http://blog.ezyang.com/2012/03/you-could-have-invented-fractional-cascading/)

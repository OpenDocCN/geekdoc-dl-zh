<!--yml

类别：未分类

日期：2024-07-01 18:17:47

-->

# Thunk 泄漏的解剖：ezyang 的博客

> 来源：[`blog.ezyang.com/2011/05/anatomy-of-a-thunk-leak/`](http://blog.ezyang.com/2011/05/anatomy-of-a-thunk-leak/)

在本文中，我们讨论了 thunk 泄漏的特征，这种泄漏已经成为“推理空间使用难题”在 Haskell 中的象征。我将考虑几个此类泄漏的例子，并认为这些泄漏实际上是*微不足道*的修复。相反，困难在于当一个 thunk 泄漏被混淆与其他类型的泄漏时（我们将在后续文章中讨论）。

### 描述

我将以两种方式描述各种泄漏：首先我将使用我在 Haskell 堆系列中开发的隐喻给出一个非正式的具体描述，然后我将在最后给出更直接、临床的处理。如果你无法忍受一种形式的解释或另一种形式的解释，请随意跳过。

当太多包裹好的礼物（thunk）同时存在时，就会发生 thunk 泄漏。

创造 thunk 并不一定是一件坏事：事实上，大多数 Haskell 程序生成大量的 thunk。有时候堆上存在 thunk 是不可避免的。问题是当它们没有及时评估：就像懒惰的大学生房间里的袜子一样，它们开始堆积起来。

有一个明确的意义，即 thunk “堆积”起来，这可以通过观察幽灵关心的礼物来观察到。

每个幽灵都关心堆叠中的下一个礼物（这样格林奇就不能将它们带走），而我们（用户）关心的是堆叠最底部的礼物。因此，当我们打开那份礼物时，整个礼物链就会倾覆下来（假设没有其他引用指向堆积）。

Thunk 的链条可以是任何你想要的形状，虽然线性是通常情况。

解决问题的方式是什么？显然不是等到礼物堆积起来然后一次清理（就像我们的大学生可能会做的那样）：伤害（大内存使用）已经造成了！

相反，我们应该更加渴望并在收到礼物时立即打开它们。

然而，这种策略可能会失败。如果打开礼物导致比起始状态更大的东西，或者如果我们可能不需要打开所有礼物，我们最好还是懒得去做。

此外，还有一个问题，即这些礼物最初是从哪里来的。也许我们最初对于得到这些礼物太急切了...

总之，Thunk 泄漏是指当一个 Haskell 程序积累大量的 thunk 时，如果评估的话，将会导致更小的内存使用。这要求这些 thunk 具有几个属性：

1.  它们不得有外部引用（因为 thunk 被评估时，它们的结果可以被垃圾回收），

1.  它们必须执行某种减少，而不是创建一个更大的数据结构，而

1.  它们应该是必需的。

如果（1）失败，这些未求值表达式很可能是合法的，并且只会产生很小的开销（真正困难的是算法问题）。如果（2）失败，评估所有未求值表达式可能会加剧内存情况。如果（3）失败，您可能正在看到流失败，因为未求值表达式正在急切地创建但懒惰地评估（它们应该也是懒惰地创建）。

### 举例

我提炼了一些例子来帮助说明所讨论的现象，并直接提供源码级的所有可能修复泄漏的方法。我还将提供一些未泄漏但因为 GHC 足够聪明（为优化欢呼！）而没有泄漏的示例。可运行的代码可以在[GitHub 仓库](https://github.com/ezyang/hsleak)找到，我会尽量保持更新。

首先我们来看看来自简单迭代代码的经典空间泄漏：

```
main = evaluate (f [1..4000000] (0 :: Int))

f []     c = c
f (x:xs) c = f xs (c + 1)

```

显而易见的是谁在累积未求值表达式：是 `c + 1`。不那么明显的是，当您使用优化编译 GHC 时，此代码实际上并*不*泄漏。为什么会这样？快速查看 Core 将告诉我们为什么：

```
Main.$wf =
  \ (w_s1OX :: [GHC.Integer.Type.Integer])
    (ww_s1P0 :: GHC.Prim.Int#) ->
    case w_s1OX of _ {
      [] -> ww_s1P0;
      : _ xs_a1MR -> Main.$wf xs_a1MR (GHC.Prim.+# ww_s1P0 1)
    }

```

请注意，`c` 的类型（重命名为 `ww_s1P0`）是 `GHC.Prim.Int#`，而不是 `Int`。由于这是一个原始类型，它是 *非懒惰的*：无法创建这种类型的未求值表达式。因此，GHC 通过根本不创建它们来避免未求值表达式。修复未优化的情况就像使 `c` 严格化一样简单，因为整数的加法是一个严格函数。

GHC 通常无法执行此类拆箱优化，因为这可能违反代码的语义。我们的下一段代码正是在研究这样的情况：

```
main = do
    evaluate (f [1..4000000] (0 :: Int, 1 :: Int))

f []     c = c
f (x:xs) c = f xs (tick x c)

tick x (c0, c1) | even x    = (c0, c1 + 1)
                | otherwise = (c0 + 1, c1)

```

这个空间泄漏在有优化和无优化的情况下都会发生。它也会导致栈溢出。

GHC 无法通过优化此代码以使得元组的元素被急切地求值，而不改变函数 `f` 的语义。为什么会这样？我们考虑对 `f` 的另一种调用：`f [1..4000000] (0, undefined)`。函数当前的语义要求结果是 `(2000000, undefined)`（因为对 `undefined` 添加任何东西仍然是 `undefined`），这意味着在强制内部元组之前我们无法进行任何求值。如果我们只在需要的时候对元组进行弱标准形式的求值（如 `evaluate` 调用所做的），或者如果我们只使用第一个结果，那么不应抛出任何异常。如果我们用 `undefined` 替换 `1 :: Int` 并运行程序，这确实是情况。

好吧，这就够理论的了，我们如何修复这个错误呢？我可以直接给出一个答案，但如果我们考虑一系列可能的修复方法并分析它们对程序的影响，这可能会更有信息性。希望这将使空间泄漏不再像符文预测那样难以捉摸，而更加有方法论。

*在 `f` 函数中为 `c` 添加一个严格模式*。这个方法行不通：

```
f []     !c = c
f (x:xs) !c = f xs (tick x c)

```

我们   这个洞见在于我们并没有改变函数的语义：`f l (undefined, undefined)` 仍然应该返回 `(undefined, undefined)`，因为 `seq` 并不会“查看元组内部”。然而，添加这个叹号模式可能有助于构建其他解决方案，如果评估元组本身有其他副作用（如我们可能会说，那只鬼会为我们打开一些礼物）。

*使元组在 tick 中不可反驳*。这只是混乱的：

```
tick x ~(c0, c1) | even x    = (c0, c1 + 1)
                 | otherwise = (c0 + 1, c1)

```

不可反驳模式增加了 *惰性*，而不是严格性，因此问题变得更糟并不令人惊讶（注意内存使用量现在达到了 80M，而不是 40M）。

*使 tick 严格*。注意 `x` 已经通过 `even x` 立即被强制，所以无需在这里添加叹号模式。我们只是在 `c0` 和 `c1` 上添加叹号模式：

```
tick x (!c0, !c1) | even x    = (c0, c1 + 1)
                  | otherwise = (c0 + 1, c1)

```

这些看起来像是一个糟糕的图，但看看比例。1.2 *千字节*。一般来说，如果在你修改 Haskell 程序后，开始再次看到很多带状数据，说明你已经修复了泄漏。所以我们已经修复了它！

好吧，不完全是。未经优化的代码仍然有内存泄漏：

通过启用一个 GHC 优化，我们修复了内存泄漏，类似于修复原始内存泄漏的方式。再一次，Core 让这一点变得清楚：

```
Main.$wf :: [GHC.Integer.Type.Integer]
            -> GHC.Types.Int
            -> GHC.Types.Int
            -> (# GHC.Types.Int, GHC.Types.Int #)

```

GHC 已经将元组优化为一个无框返回，并内联了对 `tick` 的调用，因此我们没有任何元组惰性求值浮动在四周。我们本可以手动进行这个优化，但让编译器为我们做更好（并保持代码整洁）。

*严格化 tick 和 f*。与第一个例子类比，现在 `tick` 是严格的，如果我们将两个地方都严格化，未经优化的代码也会没问题。果然，没问题。

对于优化后的情况，这并没有太大帮助！（堆内存剖面基本上没有变化。）

*使对偶严格*。使用严格对偶而不是默认的惰性对偶，相当于在我们对元组进行模式匹配时插入叹号模式。因此，它相当于将 `tick` 严格化，如果你这样做，在未经优化的情况下你仍然需要一些额外的工作才能让它正常工作。当你控制进入循环的数据结构时，这通常更有效，因为你不需要更改所有的数据声明。

*深度 seq c.* 如果对 c 的简单叹号模式不起作用，深度叹号模式会起作用：

```
f []     c = c
f (x:xs) c@(!_,!_) = f xs (tick x c)

```

或者，你可以使用深度 seq 包中的 `rnf`。虽然这确实有效，但我个人认为最好还是使用严格的数据类型，如果你要随便地使用 `rnf`，那么最好保持所有东西始终被完全评估。

我还有另一个例子，但今天时间不够了！作为告别的话，注意到元组并不是唯一的提升类型：从记录到单数据构造器（`data I a = I a`）再到可变引用，都具有额外的语义，可能带来额外的空间成本。但识别和修复这个特定问题非常容易：堆配置文件非常独特，修复方法简单且非侵入性，甚至可以使用指称语义来帮助分析代码！你所需的只是一点额外的知识。

*附言.* 对于图表轴线和颜色的变化很抱歉。尽量关注形状和标签。我仍在努力使用`hp2pretty`生成正确类型的堆配置文件，并需要更一致的缩放机制和更一致的着色方案。这些实验是在 GHC 6.12.3 上进行的。

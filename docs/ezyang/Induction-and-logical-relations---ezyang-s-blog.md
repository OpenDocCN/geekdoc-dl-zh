<!--yml

类别：未分类

日期：2024-07-01 18:17:18

-->

# 归纳和逻辑关系：ezyang 的博客

> 来源：[`blog.ezyang.com/2013/09/induction-and-logical-relations/`](http://blog.ezyang.com/2013/09/induction-and-logical-relations/)

逻辑关系是一种证明技术，允许您证明归一化（*所有程序终止*）和程序等价性（*这两个程序在所有程序上下文下观察上等价*）。如果你以前从未遇到过这些内容，我强烈推荐 Amal Ahmed 在 OPLSS 讲座中的内容；您可以从这里找到我的视频和笔记。 （您还可以访问她以前年份的讲座。）本文是讨论我在 OPLSS 期间和之后几周内在 Agda 上进行的两个逻辑关系证明的形式化的借口。我不打算逐行解释代码，但我确实想扩展关于逻辑关系的两个观点：

1.  当简单归纳无法工作时它们会起作用，

1.  逻辑关系不是一个归纳定义。

全部的发展在[Github 上的 lr-agda 仓库](https://github.com/ezyang/lr-agda/)中。非常感谢 Dan Licata 为他的 OPLSS Agda 课程提供了初始发展和为解决关于 lambda 演算的证明而努力的替换引理。

* * *

如果你不知道更好的办法，你可能会尝试通过归纳来证明归一化，如下所示：

> 为了显示所有程序都归一化到一个值，让我们按照类型推导进行归纳。例如，在应用案例中，我们需要展示`e1 e2`归一化到某个值`v`，假设`e1`归一化到`v1`，`e2`归一化到`v2`。好吧，`v1`的类型是`t1 -> t2`，这意味着`v1 = λx. e'`。哎呀：这应该步进到`e'[v2/x]`，但我对这个表达式一无所知（`e'`可以是任何东西）。卡住了！

逻辑关系提供了额外的*威力*，使您能够证明通常无法证明的东西。让我们考虑一下我们的第二个证明草图：问题在于我们对`e'`一无所知。如果我们对它有额外的了解，比如说，“嗯，对于一些合适的 v，e'[v/x]将会归一化”，那么我们就能够完成证明。因此，如果这个`WN`的定义是我们旧的证明目标：

```
WN : (τ : Tp) → [] ⊢ τ → Set
WN τ e = e ⇓

```

然后我们想要做的是扩展这个定义来包括那些“额外的东西”：

```
WN : (τ : Tp) → [] ⊢ τ → Set
WN τ e = e ⇓ × WN' τ e

```

> 在这一点上，现在应该好好讨论一下如何阅读这里的 Agda 代码。WN 是*类型族*，即 `WN τ e` 是表达式 `e` 的类型 `τ` 的一元逻辑关系。类型的类型是 `Tp`，这是一个简单的归纳定义；术语的类型是更复杂的 `[] ⊢ τ`（利用 Agda 的混合操作符；如果没有它们，你可能会写成 `Expr [] τ`），它不仅告诉我们 `e` 是一个表达式，而且是*良类型*，在空上下文 `[]` 下具有类型 `τ`。（这是一个一般模式的实例，其中归纳定义与良形性推导相一致，在这种情况下是类型推导。）`e ⇓` 是另一个混合操作符，它被定义为传统的规范化（存在某个值 `v`，使得 `e` 缩减到 `v`，例如 `Σ (λ v → value v × e ↦* v)`）。

但是这额外的内容是什么呢？在简单类型的情况下，例如布尔类型，我们实际上不需要任何额外的东西，因为我们永远不会尝试像函数一样应用它们：

```
WN' : (τ : Tp) → [] ⊢ τ → Set
WN' bool e = Unit

```

对于函数类型，我们可以说一个函数是 WN 的（即在逻辑关系中），如果给定一个 WN 参数，它产生一个 WN 结果。（因为我们涉及 WN，这实际上是一个相互递归的定义。）这个陈述实际上是关键的证明思路！

```
WN' (τ1 ⇒ τ2) e = (e1 : [] ⊢ τ1) → WN τ1 e1 → WN τ2 (app e e1)

```

还有一些细节，但基本上，当你重做证明时，证明 WN 而不是普通的规范化时，你不会再卡在应用案例上。太棒了！然而，反过来，λ案例的证明不再是微不足道的；你需要做一些工作来展示额外的内容（WN' 的成立）。有人将这描述为"气球"原理。

气球的两侧是"归纳假设的使用"和"证明义务"。当你有一个较弱的归纳假设时，它并没有提供很多信息，但你也不必费太多力气来证明它。当你加强归纳假设时，你可以用它证明更多的东西；然而，相应地，你的证明义务也会增加。在规范化证明的背景下，"归纳假设的使用"出现在应用案例中，而"证明义务"则出现在λ案例中。当你尝试直接的归纳证明时，λ案例是微不足道的，但归纳假设非常薄弱，所以应用案例是不可能的。在逻辑关系证明中，应用案例很容易从归纳假设中得出，但在λ案例中，你需要做更多的工作。

* * *

现在让我们稍微退一步，谈谈我们如何定义 WN' 类型族的方式，以便讨论为什么 WN' 不是一个*归纳定义*。在 Agda 中，通常有两种定义类型族的方式：可以作为递归函数进行定义，也可以作为归纳定义进行定义。一个简单的例子是长度索引列表的定义。标准的归纳定义如下：

```
data Vec : Set → Nat → Set where
  vnil : {A : Set} → Vec A 0
  vcons : {A : Set} → A → Vec A n → Vec A (S n)

```

但我也可以用普通的产品建立列表，使用索引上的递归函数：

```
Vec : Set → Nat → Set
Vec A 0 = Unit
Vec A (S n) = A × Vec A n

```

这两种不同的编码各有优缺点：使用递归函数通常意味着某些相等性是定义性的（而你必须使用归纳定义证明引理），但归纳定义允许你对不同可能性进行案例分析。

有时，简单地无法使用归纳定义，逻辑关系就是这种情况。这加强了归纳假设的负担：

```
data WN' : τ → [] ⊢ τ → Set where
  WN/bool : {e : [] ⊢ bool} → WN' bool e
  WN/⇒ : {e1 : [] ⊢ τ1} → (WN τ1 e1 → WN τ2 (app e e1)) → WN' (τ1 ⇒ τ2) e

```

Agda 对归纳-递归定义并不抱怨（尽管应注意：它们在元理论上并不是太好地基础），但它会对这个定义抱怨。问题是[一个熟悉的问题](http://blog.ezyang.com/2012/09/y-combinator-and-strict-positivity/)：WN 不出现在严格正位置；特别是，它作为 WN/⇒构造子的参数出现。因此我们不能使用它！

事实证明，无法归纳地定义逻辑关系对于规范化并不是什么大问题。然而，对于更复杂的逻辑关系证明，例如程序等价性，它会带来更多头痛。在考虑程序等价性时，你需要一个二元关系来关联值与值，表明两个值何时相等。这可以非常自然地用归纳方式表述：

```
data V'⟦_⟧ : (τ : Tp) → [] ⊢ τ → [] ⊢ τ → Set where
   V/bool-#t : V'⟦ bool ⟧ #t #t
   V/bool-#f : V'⟦ bool ⟧ #f #f
   V/⇒ : {τ₁ τ₂ : Tp} {e₁ e₂ : [] ,, τ₁ ⊢ τ₂}
     → ((v₁ v₂ : [] ⊢ τ₁) → V'⟦ τ₁ ⟧ v₁ v₂ → E⟦ τ₂ ⟧ (subst1 v₁ e₁) (subst1 v₂ e₂))
     → V'⟦ τ₁ ⇒ τ₂ ⟧ (lam e₁) (lam e₂)

```

我们通过类型定义关系。如果一个值是布尔值，那么我们说`#t`（真）与其自身相关联，`#f`与其自身相关联。如果该值是一个函数，那么我们说一个 lambda 项与另一个 lambda 项相关联，如果应用于两个相关联的值，则结果也是相关联的。这个“函数”与我们为规范化证明添加的额外内容直接类似。 （如果你愿意，你可以在心理上用“相等”替换“相关”，但这是误导的，因为它并不捕捉到函数情况中发生的情况）。但这不通过严格正性检查，因此我们必须递归地定义它：

```
V⟦_⟧ : (τ : Tp) → [] ⊢ τ → [] ⊢ τ → Set
V⟦ bool ⟧    #t #t = Unit
V⟦ bool ⟧    #f #f = Unit
V⟦ bool ⟧ _ _  = Void
V⟦ τ₁ ⇒ τ₂ ⟧ (lam e) (lam e') = (v v' : [] ⊢ τ₁) → V⟦ τ₁ ⟧ v v' → E⟦ τ₂ ⟧ (subst1 v e) (subst1 v' e')
V⟦ τ₁ ⇒ τ₂ ⟧ _ _ = Void

```

注意，这里的定义远不如归纳定义那么美好：我们需要两个穿越情况，当两个东西不可能相等时断言矛盾，例如`#t`不可能等于`#f`。此外，假设我们在进行证明时将 V 作为一个假设给出，我们不能再仅仅在其上分情况以找出我们所拥有的信息；我们必须费力地首先对类型和表达式进行情况分割，此时函数会减少。为了让你感受到这有多糟糕，考虑一下这个函数，它将从归纳定义转换为递归定义：

```
pV : {τ : Tp} → {e e' : [] ⊢ τ} → V⟦ τ ⟧ e e' → V'⟦ τ ⟧ e e'
pV {bool} {#t} {#t} V = V/bool-#t
pV {bool} {#t} {#f} ()
pV {bool} {#t} {if _ then _ else _} ()
pV {bool} {#t} {var _} ()
pV {bool} {#t} {app _ _} ()
pV {bool} {#f} {#t} ()
pV {bool} {#f} {#f} V = V/bool-#f
pV {bool} {#f} {if _ then _ else _} ()
pV {bool} {#f} {var _} ()
pV {bool} {#f} {app _ _} ()
pV {bool} {if _ then _ else _} ()
pV {bool} {var _} ()
pV {bool} {app _ _} ()
pV {_ ⇒ _} {if _ then _ else _} ()
pV {_ ⇒ _} {var _} ()
pV {_ ⇒ _} {lam _} {if _ then _ else _} ()
pV {_ ⇒ _} {lam _} {var _} ()
pV {_ ⇒ _} {lam _} {lam _} f = V/⇒ (\ v v' V → pE (f v v' V))
pV {_ ⇒ _} {lam _} {app _ _} ()
pV {_ ⇒ _} {app _ _} ()

```

天哪！也许通过改进 Agda 处理模式匹配中的通配符的方式可以改善这种情况，但目前来看，所有这些都是必需的。

“但等等，爱德华！”你可能会说，“你不是刚刚说你不能归纳定义它吗？”确实，这个函数不是基于我之前提出的归纳定义运行的，而是稍微修改了一个，通过用 V 替换非严格正出现的情况，这是递归定义：

```
V/⇒ : {τ₁ τ₂ : Tp} {e e' : [] ,, τ₁ ⊢ τ₂}
  → (V : (v v' : [] ⊢ τ₁) → V⟦ τ₁ ⟧ v v' {- the critical position! -} → E'⟦ τ₂ ⟧ (subst1 v e) (subst1 v' e'))
  → V'⟦ τ₁ ⇒ τ₂ ⟧ (lam e) (lam e')

```

这个转换函数非常有帮助，因为在像这样的情况中，agda-mode 与归纳定义（`C-c C-c`有效！）的互动要比与递归定义更加顺畅。

* * *

为什么在 Agda 中使用逻辑关系？（或者任何证明助手，无论如何？）使用逻辑关系的证明通常遵循以下模式：为你的问题定义一个适当的逻辑关系，然后进行大量的簿记以实际推动关系通过证明。计算机在做簿记方面非常出色，我认为通过证明助手逐步进行逻辑关系证明是极具信息价值的。一个有趣的挑战将是将这个框架扩展到非终止语言（在关系中添加步骤索引：簿记的顶峰）或将 lambda 演算扩展为多态（这需要一些其他有趣的逻辑关系技术）。

<!--yml

category: 未分类

date: 2024-07-01 18:18:23

-->

# xUnit 的问题：ezyang 的博客

> 来源：[`blog.ezyang.com/2010/04/the-problem-with-xunit/`](http://blog.ezyang.com/2010/04/the-problem-with-xunit/)

标语：*断言被认为不理想*。

我认为自动化测试非常棒。我在[HTML Purifier](http://htmlpurifier.org)中广泛使用了两种特定的测试类型，单元测试和集成测试，这些测试是我能够在修改我在高中时编写的代码时感到放心的唯一原因。自动化测试让我可以轻松进行编码，并通过按下一个按钮来找出我是否破坏了任何东西，而不是手动输入几个输入然后查看它们是否“看起来正常”。它们也是我最初编写代码时“我想让代码做什么”的非正式规范的例子。

单元测试和集成测试都是建立在[SimpleTest](http://simpletest.org/)“单元测试”库之上。我将“单元测试”用引号括起来，因为虽然 SimpleTest 非常适合单元测试（测试单个组件），但它也可以用于集成测试（测试多个组件一起）和系统测试（整个系统，对于 Web 应用程序，通常涉及编写脚本来浏览网站）；事实上，它已经提供了便利设施来更轻松地执行后两者！

或许对于 SimpleTest 的更准确描述是，它作为 xUnit 测试框架的后代。你知道，那种“编写一个设置一些东西的测试函数，运行一些代码并进行一些断言”的测试风格。断言的概念是至关重要的；没有异常处理，这是你了解测试代码是失败还是成功的唯一途径。

前些天我在 JUnit 中写了一些测试，这让我有点想起为什么虽然自动化测试很棒，我还是有些不情愿去首先推广它们。它们太冗长了！每个测试方法我都必须实例化我想要的任何类，做任何我需要的初始化，创建我的输入数据（如果我直接用`new`来构建，这可能需要几行），运行函数，然后测试输出数据是否符合预期（无论是通过耐心地查看各个字段和方法，还是如果我有远见去实现相等性，构造预期输出结果并比较它们）。"等等，"你说，"这正是`setUp`和`tearDown`的用途！"然后你将这些代码块移动到那些方法中，但用于创建输入和验证结果的大量样板代码仍然存在，并且你害怕将它们抽象化，因为增加更多代码意味着你的测试可能出错的机会增加了！

但没有好的方法摆脱这一困境，因为对单元测试的单元测试调用列表真正是你的测试套件的“输入”，然后传递给断言的表达式列表真正是你的测试套件的“输出”。你选择使用的特定断言是你的测试套件的“预期值”。那么为什么感觉像是模板呢？

或许是因为 setUp 和 tearDown 方法以及测试方法和断言的模型对许多类型的代码来说都是错误的：正确的模型是输入值、输出值和预期值模型！对于纯净的代码来说，实际上比“代码清单”和“运行代码清单后应用程序的全局状态”有更精细的输入和输出的概念；也许它真的只是“两个整数”和“一个整数”。然后，你编写的测试代码应该*真正反映出这一点！*

那么，我们如何实现这一点呢？你需要一个 DSL。有些语言足够强大，可以使用一种嵌入式 DSL。但许多语言使这一过程变得太繁琐，因此它们会发明自己的测试格式，并编写必要的模板代码来解析和操纵它。显然，需要有足够多的这种形式的测试，以使编写所有这些基础设施都值得，因此当这不成立时，人们就会回到快速而肮脏的 xUnit 风格测试中。但通过这样做，你已经模糊了你的测试形状，并且由于“快速而肮脏”从未意味着“短暂”，你的测试套件会越来越大，你永远也不会切换到正确的方式。永远。

此刻，是时候进行一点 Haskell 的倡导了。你如何让你的测试从一开始就不那么繁琐呢？使用一种鼓励构建小型 DSL 的语言。*Haskell 拥有灵活的语法和类型设施，使这一切成为可能，请查看。* 使用一种鼓励你仔细思考函数的语言，函数具有清晰的输入和输出，而不是类和方法以及可变状态。*Haskell 是一种函数式编程语言，请查看。* 使用一种抽象成本低廉、炉火纯青的语言。*Haskell，请查看。* 使用一种语言，一旦你厌倦了一遍又一遍地编写输入和输出值，而不是整个 xUnit 测试用例的模板，它可以给你绳子来自动化这个过程！*QuickCheck 和 Haskell，请查看。*

现在是小小的号召行动的时候了：不要将单元/验收/系统测试层次结构与 xUnit 框架/模板混为一谈。有 xUnit 测试，还有完全随机生成输入的 QuickCheck，但在这两个不同的抽象层次之间仍然有足够的空间供人们和测试居住。当然，当代码清单确实是输入表示的正确范式时，xUnit 风格的测试也是有用的。

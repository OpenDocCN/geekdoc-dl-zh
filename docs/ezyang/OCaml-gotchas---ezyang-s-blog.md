<!--yml

category: 未分类

date: 2024-07-01 18:17:59

-->

# OCaml 的陷阱：ezyang 的博客

> 来源：[`blog.ezyang.com/2011/02/ocaml-gotchas/`](http://blog.ezyang.com/2011/02/ocaml-gotchas/)

## OCaml 的陷阱

我花了一些时间完善了我的 [count min sketch](https://github.com/ezyang/ocaml-cminsketch) 在 OCaml 中的实现（将成为另一篇博客文章的主题），在此过程中，我注意到了 OCaml 语言的一些怪异之处（从 Haskell 的视角来看）。

+   不像 Haskell 的 `Int`，它可以是 32 位或 64 位，内置的 OCaml `int` 类型只能是 31 位或 63 位。位操作者要小心！（有一个 `nativeint` 类型可以提供完整的机器精度，但效率比 `int` 类型低。）

+   分号与 Haskell do 块的“可编程分号”有很大不同的优先级。特别是：

    ```
    let rec repeat n thunk =
        if n == 0 then ()
        else thunk (); repeat (n-1) thunk

    ```

    不像 Haskell 中类似表达的预期，OCaml 并不会做出相同的事情。（听说我应该使用 `begin` 和 `end`。）

+   甚至在 64 位平台上，从 Random 模块获取的随机数只能获得 30 位（使用 Random.bits 获得正整数），因此您必须手动将多次调用生成器拼接在一起。

+   我不喜欢缩进的“军队阶梯”，所以我把我的`in`放在它们的语句之后 —— 但是，当它们放在那里时，它们很容易被忘记（因为在 Haskell 中，do 块中的 let 语句不需要 in）。

+   关键字参数非常有用，但它们会使类型系统有些混乱，并且在高阶上下文中使关键字函数和非关键字函数的互操作变得更加困难。 （特别是当您仅出于文档目的使用关键字参数时，而不是因为函数接受两个整数并且您确实需要消除歧义。）

关于纯度和随机性的一个观察：我认为在 Haskell 中经常让人感到烦恼的一件事是，随机性涉及状态的变化，因此必须包装在单子中。这使得构建概率数据结构有些笨拙，因为您不能再公开纯接口。OCaml 不是纯的，因此您可以随时查询随机数生成器。

不过，在某些情况下，我认为 Haskell 可能会在最后一笑。特别是，如果您使用随机数生成器为代码生成随机测试案例，您需要能够再现特定的随机测试集。通常，通过提供一个种子来完成此操作，然后将其提供给测试脚本，以实现确定性行为。但是因为 OCaml 的随机数生成器操作全局状态，很容易在请求与其他不相关的内容的随机数时意外地破坏确定性。您可以通过手动括起全局状态来解决此问题，但显式处理随机状态意味着提供确定性更加自然。

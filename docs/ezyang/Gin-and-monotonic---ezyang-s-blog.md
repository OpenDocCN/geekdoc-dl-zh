<!--yml

category: 未分类

date: 2024-07-01 18:18:01

-->

# Gin and monotonic : ezyang’s blog

> 来源：[`blog.ezyang.com/2010/12/gin-and-monotonic/`](http://blog.ezyang.com/2010/12/gin-and-monotonic/)

*Gin, because you’ll need it by the time you’re done reading this.*

[上次](http://blog.ezyang.com/2010/12/hussling-haskell-types-into-hasse-diagrams/)我们看了数据类型值的部分顺序。有两件事情我想补充：一个是星下标底部如何扩展，一个是不使用星下标底部符号的列表图解。

这是三个星下标底部扩展的三重体现，形成了熟悉的 Hasse 图，通过包含关系排序的三个元素集的幂集：

下面是列表的部分顺序，在其全指数荣耀中（为了适应所有，灰色脊柱的部分顺序在向右增加时增加）。

* * *

现在，谈谈今天的主题，函数！到目前为止，我们只讨论了数据类型。在本篇文章中，我们将更仔细地研究*函数*具有的偏序关系。我们将介绍*单调性*的概念。并且会有很多图片。

* * *

让我们从一个简单的例子开始：从单元到单元的函数，`() -> ()`。在你看图之前，你认为我们可以写多少不同的这种函数实现呢？

结果，一共有三种。一种无论我们传递什么都返回底部，一种是恒等函数（如果传递单元则返回单元，如果传递底部则返回底部），还有一种是`const ()`，即无论传递什么都返回单元。注意这些不同函数与其参数的严格和惰性评估之间的直接对应关系。（你可以称底部函数为部分的，因为它对于任何参数都未定义，尽管没有直接编写此内容的方法，如果仅使用 undefined GHC 不会发出部分函数警告。）

在我提出的图中，我展示了关于偏序的三种等效思考方式。第一种只是λ演算中的术语：如果你更喜欢 Haskell 的表示法，你可以将λx.x 翻译为`\x -> x`。第二种是将输入值映射到输出值，明确处理了底部（这种表示法有助于明确看到底部，但不太适合确定哪些值是合法的——即可计算的）。第三种仅仅是函数的定义域：你可以看到这些定义域逐渐变得越来越大，从空到整个输入类型。

在这一点上，一点正式性是有用的。我们可以定义一个函数的偏序如下：f ≤ g 当且仅当 dom(f)（f 的定义域，例如所有不会导致 f 返回底部的值）⊆ dom(g)，对于所有 x ∈ dom(f)，f(x) ≤ g(x)。你应该验证上面的图表是否一致（第二个条件非常容易，因为函数的唯一可能值是`()`）。

一个敏锐的读者可能已经注意到，我忽略了一些可能的函数。特别是，第三个图表并不包含域的所有可能排列：只有底部的集合如何？事实证明，这样的函数是不可计算的（如果我们有一个函数 `() -> ()`，如果其第一个参数是底部则返回 `()`，如果其第一个参数是 `()` 则返回底部，那么如何解决停机问题）。我们稍后再回到这个问题。

由于 `() -> ()` 有三种可能的取值，一个问题是是否存在一个更简单的函数类型，其取值更少？如果我们接受空类型，也可以写为 ⊥，我们可以看到 `a -> ⊥` 只有一种可能的取值：⊥。

* * *

类型为 `⊥ -> a` 的函数也具有一些有趣的属性：它们与类型 `a` 的普通值是同构的。

在没有公共子表达式消除的情况下，这可以是防止惰性计算结果共享的有效方式。然而，写 `f undefined` 是很麻烦的，因此人们可能会看到 `() -> a`，它的语义并不完全相同，但类似。

* * *

到目前为止，我们只考虑了以 `⊥` 或 `()` 作为参数的函数，这些函数并不是很有趣。因此，我们可以考虑下一个可能最简单的函数：`Bool -> ()`。尽管这种类型看起来很简单，实际上有五种不同的可能函数具有这种类型。

要看为什么可能是这种情况，我们可以看看函数对其三个可能参数的行为：

或者每个函数的定义域是什么：

尽管看起来域中元素可能有其他可能的排列，但这些偏序是完备的。再次强调，这是因为我们排除了不可计算的函数。接下来我们会看看这一点。

* * *

考虑下面的函数 `halts`。如果传递给它的计算最终终止，则返回 `True`，如果不终止，则返回 `False`。正如我们通过 `fix id` 所见，我们可以将底部视为一个不终止的计算。我们可以通过绘制输入和输出类型的哈斯图，并绘制箭头将一个图表中的值映射到另一个图表中来绘制此图表。我还用灰色背景着色了不映射到底部的值。

众所周知，停机问题是不可计算的。那么这个看起来完全合理的图表有什么问题？

答案是我们的排序没有被函数保留。在第一个定义域中，`⊥ ≤ ()`。然而，结果值却没有这种不等式：`False ≰ True`。我们可以总结这种情况为*单调性*，即，当 x ≤ y 时，若 f(x) ≤ f(y)，则 f 是单调的。

这里值得注意的两种退化情况：

+   在 f(⊥) = ⊥ 的情况下，即函数是严格的，你永远不必担心 ⊥ 不小于任何其他值，因为根据定义 ⊥ 小于所有值。从这个意义上说，使函数严格是“安全的做法”。

+   当 f(x) = c（即常数函数）对所有 x 都成立时，您同样是安全的，因为任何在原始域中存在的排序在新域中也是存在的，因为 c ≤ c。因此，常数函数是向 f(⊥)分配非底值的简单方法。这也清楚地表明单调性推论只是单向的。

更有趣（并且有些不明显）的是，我们可以编写计算函数，它们不是常量，但在传递`⊥`时却提供了非⊥值！但在我们进入这种乐趣之前，让我们首先考虑一些可计算函数，并验证单调性是否保持。

* * *

最简单的所有函数是恒等函数：

它几乎什么都不做，但是您应该验证自己是否能理解这种表示法。

更不那么琐碎的是`fst`函数，它返回一对中的第一个元素。

查看并验证函数保留了所有偏序关系：因为只有一个非底输出值，所以我们只需要验证灰色是否“位于”其他所有值之上。还要注意，我们的函数不关心对偶中的`snd`值是否为底。

图表指出，`fst`仅仅是一个未柯里化的`const`，所以让我们接着看这个。

我们希望考虑`const`的意义是`a -> (b -> a)`，一个接受一个值并返回一个函数的函数。为了读者的利益，我们还绘制了导致这些函数的哈斯图。如果我们固定了`a`或`b`的类型，那么我们的偏序关系中将会有更多的函数，但在没有这些限制的情况下，通过参数性质，我们的函数能做的事情很少。

考虑到`const`与`seq`的对比是有用的，`seq`是一种有点恶劣的函数，尽管它可以很好地使用我们的表示法来绘制。

这个函数之所以如此难缠，是因为它适用于任何类型（它将是一个完全合法且自动推导的类型类）：它能够查看任何类型`a`，并看到它是底部还是其构造函数之一。

让我们看看一些列表上的函数，它们与底部可能有非平凡的交互方式。`null`有一个非常简单的对应关系，因为它真正询问的是“这是`cons`构造函数还是`null`构造函数？”

`head`看起来有点有趣。

有多个灰色区域，但单调性从未被违反：尽管脊椎朝上无限扩展，每个叶子都包含偏序的最大值。

`length`有类似的模式，但叶子的排列略有不同：

虽然`head`只关心列表的第一个值不是底部，`length`却关心`cons`单元的`cdr`是否为空。

* * *

我们还可以使用此符号来查看数据构造函数和新类型。

考虑下面的函数`caseSplit`，它作用在一个具有唯一字段的未知数据类型上。

我们有非严格构造函数：

严格构造函数：

最后是新类型：

* * *

现在我们准备进行一个力作示例，研究从 `Bool -> Bool` 函数的偏序，并考虑布尔函数 `||`。为了刷新您的记忆，`||` 通常以这种方式实现：

从这张图表中不太明显的一点（我们希望很快能够明显），是这个运算符是从左到右的：`True || ⊥ = True`，但 `⊥ || True = ⊥`（在命令式措辞中，它会短路）。我们将开发一个偏序，让我们能够解释这个左或及其表亲右或和更奇特的平行或之间的差异。

* * *

记住 `||` 是柯里化的：它的类型是 `Bool -> (Bool -> Bool)`。我们之前已经画出了 `Bool` 的偏序，那么 `Bool -> Bool` 的完全偏序是什么？一个非常有趣的结构！

我违反了我之前声明的约定，即更明确定义的类型位于其他类型之上，以展示这个偏序的对称性。我还缩写了 True 为 T，False 为 F。（作为补偿，我已经明确画出了所有的箭头。在未引起兴趣的未来图表中，我将省略它们。）

这些明确的 lambda 表达式有些模糊了每个函数的实际作用，因此这里是一个简写表示：

每个球或 bottom 的三重表示说明了函数对 True、False 和 bottom 的反应。

注意顶部/底部和左侧/右侧之间的轻微不对称性：如果我们的函数能够区分 True 和 False，那么就没有非严格可计算的函数。练习：画出哈斯图并说服自己这一事实。

从现在开始我们将使用这种简写表示法；如果你感到困惑，请参考原始图表。

* * *

首要任务（咳嗽）是重新绘制带有完全偏序的左或哈斯到哈斯图的图。

使用传递性验证，我们可以恢复简化的偏序的部分图。红色箭头表示原始布尔顺序中保留的排序。

百万美元的问题是：我们能写一个不同的映射来保持顺序（即单调吗）？正如你可能已经猜到的那样，答案是肯定的！作为一个练习，画出严格或的图表，它在其两个参数中都是严格的。

这是右或的图表：

注意一个非常有趣的事情发生了：bottom 不再映射到 bottom，但我们仍然成功地保留了顺序。这是因为目标域具有足够丰富的结构，可以让我们做到这一点！如果这对你来说有点神奇，请考虑我们如何在 Haskell 中编写一个右或：

```
rightOr x = \y -> if y then True else x

```

在我们查看 x 之前，我们先看 y；在我们的图中，如果 y 为 False，看起来 x 就被插入到结果中。

还有一件事情我们可以做（你现在可能已经想到了），使我们在面对 bottom 时能够给出最大能力的答案，平行或：

真的这是我们能走的最远：我们不能把我们的函数进一步推入定义链的底部，也不能移动我们的底部而不改变函数的严格语义。在 Haskell 中如何实现这一点也不明显：似乎我们真的需要能够模式匹配第一个参数，以决定是否返回`const True`。但这个函数肯定是可计算的，因为单调性没有被违反。

这个名字极具暗示正确的策略：并行评估两个参数，并在任何一个返回 True 时返回 True。这种方式，哈斯图相当具有误导性：我们实际上从未返回三个不同的函数。然而，我真的不确定如何正确地说明这种并行方法。

这整个练习与卡诺图和电路中的亚稳态有很明显的并行。在电气工程中，你不仅要担心一条线是 1 还是 0，还要担心它是否从一个状态过渡到另一个状态。根据电路的构造方式，这种过渡可能导致危险，即使开始和结束状态相同（严格函数），或者无论第二行的操作如何都保持稳定（惰性函数）。我鼓励电气工程师评论一下在晶体管级别上严格或、左或、右或和并行或（我认为通常实现的方式）看起来像什么。这些类比让我觉得我花在学习电气工程上的时间并不浪费。:-)

* * *

今天就到这里。下次，我们将扩展我们对函数的理解，并看一下连续性和不动点。([点击此处查看原文](http://blog.ezyang.com/2010/12/getting-a-fix-on-fixpoints/))

**附言。** 有一些[本文的勘误。](http://blog.ezyang.com/2010/12/errata-for-gin-and-monotonic/)

# 生产中的弹性测试:部署时测试

> 原文：<https://www.algolia.com/blog/engineering/tech-startup-dilemmas-resilient-deployment-vs-exhaustive-tests/>

作为一家 SaaS 公司，我们的软件和基础设施必须在竞争中保持领先。它必须可靠:服务器和 API 的可用性与创新同样重要。换句话说，虽然我们需要尽可能快、尽可能频繁地发布产品更新和新功能，但我们也需要通过测试一切来构建有弹性的软件——这占用了创新的时间。

经验告诉我们如何平衡这些相互竞争的需求:**生产测试**。

## [](#why-do-resilient-testing-in-production)为什么要在生产中做弹性测试？

生产中的弹性测试是在生产中部署新代码的过程，并直接使用生产流量“测试”它，而不是运行详尽的测试套件。这有风险。您通常希望避免这种情况，但是随着应用程序的增长，测试所有内容变得不可能。

在 Algolia 引擎中，我们目前有二十多个[查询参数](https://www.algolia.com/doc/api-reference/search-api-parameters/)。如果它们都是布尔标志，测试所有情况将需要一百万次测试:二十个参数，每个参数有两个可能的值，这就是 2^20 可能性。

当谈到测试所需的时间时，有三件事需要考虑:

*   是时候**编写测试了**
*   到**维护测试的时间**
*   是时候**运行测试了**

编写一百万个测试已经是一个漫长的过程，但是一旦它们出现，这些测试就成为了项目的一部分。因此，它们像其余的源代码一样需要维护，所以现在每个软件迭代都需要更多的工作。

现在让我们假设你的团队足够大，可以编写和维护那些测试，**你仍然需要运行它们**。如果每个测试只需要 10 毫秒，那么总共需要运行 2h45m。代码中的任何更新现在都需要 2h45m 来验证。

我们的客户购买我们的产品不仅是为了现有的功能，也是为了即将推出的服务。他们希望我们定期发布新功能，这样我们就可以帮助他们成长，变得有创新性和弹性。因此，我们需要有效率。

当我们实现一个新特性时，**我们只编写测试来验证实现并检测明显的极限情况**。为了彻底验证功能，我们决定建立一个部署设置，允许我们在生产中进行测试，在出现错误时对客户的影响最小。这样，我们可以按时交付新的特性。

## [](#real-life-example)真实例子

让我们举一个具体的例子:我们最近重写了 Algolia 的突出显示功能。如果我们想彻底地测试它，这意味着将所有参数所需的一百万次测试与所有可能的 Unicode 字符(超过一百万)结合起来。这加起来超过十亿次测试。如果每个测试只需要一毫秒运行，**这个测试套件本身将需要 11 天来完成**。

我们必须找到更好的解决方案。因此，我们决定**在生产**中测试，而不是维持数十亿次测试并显著减慢我们的发布过程。

我们主要关心的是避免影响客户，因此我们定义了实施这种设置所需的条件:

*   一个**渐进部署流程**
*   一种在健康基础设施上重试的**方法**
*   **主动问题检测**

任何从我们的网站[订阅 Algolia 的人都可以访问一个三节点集群。每个节点拥有 100%的数据，可以独立提供查询，这提供了一个弹性设置。当您考虑裸机服务器的平均可用性为 95%时，**该设置允许我们提供 99.987%的可用性**。为了让您的 Algolia 服务完全停机，每台服务器都需要停机。因此，潜在停机时间的概率是 5%的 5%或 0.0125%。](https://www.algolia.com/)

现在，即使采用这种设置，软件错误也可能导致服务中断。为此，我们制定了一个跨越三天的搜索引擎渐进部署流程。这种部分部署为我们提供了足够的时间来检测问题。

如果在新版本中有一个 bug，我们的 API 客户端会接管他们的重试策略。如果它们的目标是一个损坏的节点，它们会透明地用另一个节点重试，直到得到成功的响应。**从最终用户的角度来看，这个问题是看不见的。**

当我们部署重写高亮特性时，我们发现了一个规范化问题。目标是将文本转换成规范形式，以简化不同输入之间的比较。规范化的表单通常比原始表单更短或更长，这正是突出显示代码所期望的。但是，有一些字符的规范化形式更长:将*的*(德国夏普 S)规范化为*的 ss* 。在重写过程中，我们添加了运行时前置条件检查，以确保规范化的大小更短或相等，并且代码的行为符合预期。**这就是揭露 bug 的原因。**

当我们在第一个节点上部署新版本时，它立即停止响应生成更长规范化表单的查询。然而，由于我们的 API 客户端的重试策略，**没有一个客户注意到它**。在我们这边，我们的监控系统触发了警报，我们很快恢复了变化以稳定引擎。它留给我们所有必要的时间来正确理解这个问题，编写适当的修复程序，以及相应的测试。

## [](#a-suitable-setup)一个合适的设置

当您想要在生产中进行测试时，您需要三个关键要素:

*   一个**复制的基础设施**
*   **一款弹性软件**
*   一个**安全部署策略**

### [](#replicated-infrastructure)复制基础设施

如今，配置复制的基础架构非常简单:所有云提供商都在多个虚拟机前提供负载平衡器。在我们的例子中，我们在集群级别处理搜索引擎数据的复制，每个节点拥有 100%的数据。这样，节点可以独立地回复查询。

### [](#resilient-software)弹性软件

这部分高度依赖于你正在构建的软件。在 Algolia 引擎中，我们在代码中有大量的健康检查来验证函数的先决条件和预期状态。当我们进入意外状态时，**引擎停止处理以避免返回损坏的数据**。它强制 API 客户端透明地在不同的节点上重试。

### [](#safe-deployment-strategy)安全部署策略

最后，同样重要的是，部署过程的主要目标是发布新版本，同时逐步控制风险。

在 Algolia，我们将基础设施分为四个环境:*测试*、*试运行*、*生产*和*安全*。每个环境都有不同的 SLA:

*   测试包含我们内部使用的集群。违反它只会影响公司。
*   Staging 包含由 Algolians 维护的面向公众的项目的搜索集群。
*   生产包含我们的客户群。
*   Safe 包含我们的高级 SLA 客户群。

在我们的部署策略中，我们利用这些不同的环境来降低风险。这意味着我们首先部署在对客户影响最小的环境中。

除了不同的环境之外，我们还利用复制因子 3，创建了一个包含 12 个步骤的部署流程:

1.  我们部署在测试集群的所有三个节点上。
2.  我们部署在*暂存*集群的第一个节点上，然后部署在*生产*集群的第一个节点上，然后部署在*安全*集群的第一个节点上。
3.  我们等一天。
4.  我们部署在*暂存*集群的第二个节点上，然后部署在*生产*集群的第二个节点上，然后部署在*安全*集群的第二个节点上。
5.  我们等一天。
6.  我们部署在*暂存*集群的第三个节点上，然后部署在*生产*集群的第三个节点上，然后部署在*安全*集群的第三个节点上。

第一步允许我们检测处理分布式系统和集群中节点间交互的代码中的问题。

然后，在每个节点上逐一部署让我们可以评估一个集群是否可以同时支持两个不同的版本，以及代码是否稳定。

在部署到下一个环境之前等待一整天的理由是，它留下了足够的时间来检测性能问题、数据损坏或基于时间的问题。一旦我们到达这一步，我们就已经检测到了大多数问题。渐进部署的其余部分在这里帮助我们识别未捕获的突发变更。

每当我们检测到一个 bug，我们会立即恢复新版本。通过这种方式，我们可以将服务设置回稳定状态，这给了我们足够的时间来修复问题并正确地添加相应的测试。

使用这种方法，我们的测试套件由客户使用驱动。这使得它特别高效，并且**允许我们每周发布一个新版本的引擎，以满足我们客户的需求**，即使有如此大的代码库。

## [](#good-is-better-than-perfect)好胜过完美

创业生态系统充满挑战。**小团队需要找到高效的策略，才能创造出比大团队大公司更好的产品。**

定期发布新功能与拥有一个稳定的产品一样重要，该产品具有满足客户需求的出色用户体验。这种对效率的需求就是为什么我们必须在编写足够多的测试以获得良好的特性覆盖和能够经常发布之间找到一个中间地带的原因。

您应该始终小心添加更多的测试，因为它们很耗时:编写、维护和运行它们需要时间。那么，您如何知道何时编写测试呢？90 法则是适用的:测试一个特性的 90%通常很简单，最后的 10%也要花同样多的时间。这就是为什么根据客户使用情况处理剩余的 10%是至关重要的，而不是推动详尽的覆盖范围。

为了降低风险，**确保你花时间设计一个软件和一个支持生产测试的基础设施**，尽可能减少对客户的影响。
# 重新设计我们的文档——第 4 部分——构建可扩展的 CSS 架构—

> 原文：<https://www.algolia.com/blog/engineering/redesigning-our-docs-part-4-building-a-scalable-css-architecture/>

> *这是由七部分组成的[系列博客](https://www.algolia.com/blog/engineering/redesigning-our-docs-part-1-why/)的第四篇文章，描述了我们对文档架构和内容的最新变更。我们在这里关注 CSS 架构和改进我们处理资产的方式。*

当在一个文档网站上工作时，很容易只关注内容，而把其他的放在一边。对于 Algolia docs 来说尤其如此:多年来，它经历了一些戏剧性的变化。随着每一个新特性、API 客户端和产品的出现，网站必须快速扩展和转型以满足新的需求。

跟上 Algolia 的发展也意味着经历许多重新设计，通常是由许多不同的人进行的。它促成了**前端代码库变得越来越难以维护**。因此，当我们决定在 2018 年底重新设计网站时，我们认为这是一个认真审视我们 CSS 状态的好时机。在不破坏其他东西的情况下改变一些东西变得越来越困难。一个简单的变化可能会变成一个小时的保持副本更新和应对媒体询问。我们不再受控制，每一次编辑都像是在一堆创可贴上加了一个创可贴。

因此，我们决定，我们的文档重新设计是一个绝佳的机会，让我们把石板擦干净，重新开始。毕竟，我们得到了一个全新的设计，所以重写我们的整个 CSS 代码库是有意义的，并且**定义一个明确而健壮的方法，可以跟上我们未来几年的发展**。

## [](#pinpointing-pain-points)**针对痛点**

众所周知，CSS 很难扩展。它提供了强有力的工具，但是犯了错误是不容易原谅的。全球范围和特殊性是很好的例子:当有目的地掌握和使用时，它可以创造奇迹。当被动使用时，问题开始堆积，很难选择不去解决。

在我们的 CSS 中，我们曾经有很多反应特异性。我们没有用它来控制，而是用它来解决问题。

```
main.content-container p:not(.report-link):not(.edit-link):not(.copy-link) {
  margin-top: 17px;
}

main.content-container td p:not(.report-link):not(.edit-link):not(.copy-link):first-child {
  margin-top: 0;
}
```

上面的代码片段是一个典型的例子，说明了由于希望在全球范围内应用规则，然后寻找例外而引发的特殊性之争。这种具有许多后代的过度限定规则的问题是，它不仅脆弱且难以手动维护，而且在性能方面也会变得更加昂贵，因为浏览器需要更长的时间来匹配。

编写反应式 CSS 的另一个潜在问题是你的代码库在不断增长。随着您添加看起来与现有组件略有不同的新组件，或者不断修补问题以修复早期的错误决策，资产变得越来越沉重。

当我们审计我们的 CSS 时，结论是无可争议的；我们问题的原因是我们**没有可见的 CSS 架构**。确切地说，我们混合使用了几种 CSS 方法。这些年来，连续的贡献者已经散布了一些全球应用的风格，一些面向组件的 CSS (OOCSS)，一些实用优先的 CSS，以及大量的黑客攻击和覆盖。尽管所有的贡献者都有最好的意图，但不幸的是，没有明确的指导方针和指定的前端所有者，他们的贡献很快导致了混乱的 CSS，重复和未使用的类，难以跟踪的副作用，以及每次我们添加新东西时都会增长的代码库。

是时候建立一个合适的架构，执行惯例，并且**开始把 CSS 作为一等公民对待了**。

## [](#a-composable-approach)**一种可组合的方法**

在评估了几种流行的方法(包括纯的、类似 Bootstrap 的 OOCSS、BEM 等)之后。)，我们决定使用**实用优先的 CSS** ，这是一种通过使用原子类来鼓励组合的方法，并允许您在必要时抽象成组件。我们将它集成在一个松散版本的 [ITCSS](https://www.xfive.co/blog/itcss-scalable-maintainable-css-architecture/) 架构中。

在诱惑实用至上的事物中，我们喜欢它与品牌指导方针的完美结合。“实用优先”旨在直接映射到风格规则上，而不是让您在没有任何框架的情况下徒手编写规则集。

### [](#a-strong-foundation)**基础雄厚**

我们没有手动维护原子样式的原始样式表，而是决定使用 [Tailwind CSS](https://github.com/tailwindcss/tailwindcss) ，这是一个实用程序优先的框架，它从 JavaScript 清单文件生成 CSS 类。Tailwind 有[很棒的文档](https://tailwindcss.com/)，一个[活跃的社区](https://discordapp.com/invite/7NF8GNe)，并且是压缩友好的(稍后会详细介绍)。

计算 CSS 而不是手动维护它的一个优点是**它在设计系统中创造奇迹**。我们可以充分利用 JavaScript 的能力，根据预先确定的规则逻辑地生成样式。这种方法比手动维护规则集更易于管理，也更省时。需要更多的间距工具？不需要一个一个手动编写。只需增加计数器。

```
const spacingUnit = 8
const variations = 120
const generatedSizes = {}

for (let i = 1; i <= variations; i++) {
  const size = i * spacingUnit
  generatedSizes[size] = `${size}px`
}
```

我们还获得了一个配置文件，可以在项目间共享。这非常有用，因为文档范围包括几个独立的项目(如[交互式教程](https://www.algolia.com/doc/onboarding/)或[小部件展示](https://www.algolia.com/doc/guides/building-search-ui/widgets/showcase/js/))。使用 JavaScript 配置文件比使用一堆分散的 CSS 文件更容易重用规则和挑选我们需要的内容。

### [](#controlled-file-size)**受控文件大小**

在线文档应该可以快速加载。在构建某个东西时，开发人员经常来回查阅文档以获取少量信息。那个参数叫什么来着？以及这个方法的返回类型？这些是他们需要快速回答的问题，而不需要走出他们的领域。

浏览在线文档应该是一种无缝的体验。在 Algolia，我们已经为速度建立了文档(静态生成的页面，基于 Algolia 的搜索),但有一个领域我们迄今为止忽略了:资产规模。

#### **稳定规模**

实用优先是保持你的 CSS 稳定小的好方法。因为我们只是重用原子类，而不是创建新的规则，**我们不引入可能增加资产的新 CSS 代码**。即使我们引入不同布局和新组件的页面，只要它遵循我们现有的 UI 系统，CSS 就不会增长。

#### **更小的浏览器内存占用**

实用优先的另一个好处是**浏览器不需要做太多的工作来解析样式**。实用程序优先的 CSS 强制只使用类(标签名不匹配)并保持低特异性(大多数时候，实用程序类是一个级别的深度)。它减少了(如果不是消除的话)样式覆盖，这减少了为给定 DOM 元素确定最终样式的开销。

#### **自动清洗**

在我们的例子中，我们使用 TailwindCSS 来生成原子类。这些是基于我们的品牌颜色，我们选择的网格大小，我们需要的变化数量等。您可以猜到，这可以生成许多类，其中大部分是我们不需要的。

出于这个原因，我们已经设置了 [Purgecss](https://www.purgecss.com/) 来自动删除任何我们在生产中不需要的类。这个工具允许我们在开发模式下访问可用类的完整目录，但是从产品构建中过滤掉所有不需要的部分。

#### **HTML 膨胀怎么办？**

保持 CSS 小很好，但是 HTML 呢？我们不就是把臃肿从 CSS 转移到 HTML 文件吗？这是我在提倡实用至上的 CSS 时经常听到的主要担忧。

重要的是要记住 CSS 和 HTML 是不同的。像 Gzip 和 Brotli 这样的压缩算法很好地处理了重复的类名，因为它们本身是基于专门设计来压缩重复字符串的算法。无论您使用几个还是多个类，HTML 文档的最终文件大小都没有什么区别。

## [](#content-friendly-css)**内容友好的 CSS**

原子类很棒，但是用户生成的内容呢？我们不能要求我们的技术作者，也不能要求其他团队的贡献者在他们写的内容中加入实用类。它既不用户友好，也不可维护，而且在代码审查期间还会严重损害内容的可读性。

对于这个特定的用例，我们需要在不产生新问题的情况下放弃实用优先，也不允许脱离我们已经部署好的系统。

### [](#preventing-style-leaks)**防止作风泄密**

技术作家和内容贡献者在 Markdown 中写作，然后编译成普通的 HTML。因此，我们需要有直接应用于 HTML 标签的样式，**，而不会泄露到网站的其他区域。**

由于 CSS 适用于全球，我们确定规则范围的唯一方法是使用特殊性作为命名所有 CSS 规则内容的方法。在我们的 Haml 模板中，我们在 Markdown 文件输出周围的容器中添加了一个特定的 CSS 类，并在 CSS 中使用该类来包含规则集，否则这些规则集将会应用得非常广泛。

下面是降价内容文件的样子:

```
## Some title

Some content
```

以及我们如何在 Haml 布局中渲染它:

```
.content
  = yield
```

这些编译成以下 HTML 代码:

```
<div class="content">
  <h2>Some title</h2>
  <p>Some content</p>
</div>
```

然后，我们可以安全地设计内容的样式(这里是 Sass):

```
.content {
  h2, h3, h4, h5, h6 {
    // ...
  }
}
```

这种技术效果很好，但是有一个缺点。由于它依赖于特殊性，每个规则集的得分都高于任何一级深度实用程序类。在上面的例子中，一个生成的规则集`.content h2`的特异性得分为`0,0,1,1`，而一个实用程序类`.margin-0`的得分为`0,0,1,0`。如果我们想用一个实用程序类来覆盖一个特定的`h2`元素的边界，特殊性会妨碍我们。

Tailwind 通过允许你创建所有的工具类[，让你避开这个问题！重要](https://tailwindcss.com/docs/configuration/#important)。然而，请记住，这是一个激进的选择，您需要以最大的谨慎来操作。

将来，我们可能会研究这部分的 [CSS 模块](https://github.com/css-modules/css-modules)，这样我们就可以直接命名类名，而不依赖于特殊性。走这条路将涉及到在 Haml/ERB 的环境下使其与 Markdown 一起工作，以及使他们与 TailwindCSS 一起玩得很好。

### [](#single-source-of-truth)**单一来源的真理**

当手动编写作用域 CSS 规则时，很容易偏离实用程序类强加的框架，并复制代码。幸运的是，这正是最好的顺风特性派上用场的地方。

Tailwind 提供了一个`@apply`指令，与 Sass 中的`@extend`、mixins 或占位符相反，它将 CSS 声明从引用类复制到一个新的规则集中。如果你熟悉 [Less](https://lesscss.org/) , `@apply`的工作方式类似于 Less mixins:它使用你可以直接应用的实际类，并将它们所有的声明复制到一个目标规则集中。

参加以下课程:

```
.text-nebula-blue {
  color: #5468ff;
}
```

我们使用`@apply`来重用它，而不是将其内容复制到新的规则集中:

```
.content {
  a {
    @apply text-nebula-blue;
  }
}
```

这编译成:

```
.content a {
  color: #5468ff;
}
```

每当我们需要编写自定义 CSS 时，我们通过`@apply`重用实用程序类，而不是编写新的规则。它迫使我们不要脱离我们的设计系统，以不一致和奇异的风格结束。

## [](#utility-first-second-to-none)**效用——第一，首屈一指**

在 Algolia 文档中，我们在实用优先方面取得了巨大的成功，将我们的 CSS 从超过 125 KB(并且持续增长)减少到不到 50 KB (9 KB GZipped，7kb Brotli compression)，这表示大小减少了 60%!从用户的角度来看，这是以极低的开销实现闪电般快速加载的保证。

从项目的角度来看，我们新的 CSS 方法让我们在设计事物的方式上更加一致。它还让我们保持自己的风格与 Algolia 品牌指南和 UI 规则保持一致，这些规则是我们的[产品设计师](https://www.algolia.com/blog/ux/redesigning-our-docs-part-3-the-ux-ui-phase/)为我们制定的。

在 Algolia，我们认为文档本身是一种成熟的产品，而不仅仅是我们的 API、客户端和库的副产品。出于这个原因，我们努力确保我们不会忽视网站的任何方面。这个新的 CSS 架构符合我们的目标:**持续改进开发者体验(DX)** 和**构建可扩展的、可持续的系统**。

新的 CSS 架构并不是我们文档前端发生的唯一事情。我们的下一篇文章将深入探讨我们为记录即时搜索而构建的新的[交互展示平台](https://www.algolia.com/doc/guides/building-search-ui/widgets/showcase/js/)的制作。
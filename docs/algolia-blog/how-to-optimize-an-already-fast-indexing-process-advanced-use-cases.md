# 如何优化已经很快的实时索引过程

> 原文：<https://www.algolia.com/blog/engineering/how-to-optimize-an-already-fast-indexing-process-advanced-use-cases/>

*快速* 索引确保搜索结果以最及时的方式包含最新的信息。“及时”的含义取决于每个公司特定的业务活动。但是正如我们在上一篇关于 [索引最佳实践](https://www.algolia.com/blog/engineering/search-indexing-best-practices-for-top-performance-with-code-samples/) 的文章中提到的那样，快速索引是现成的——也就是说，您 *不需要* 来优化索引过程，对于大多数用例来说，它已经足够快了。

*优化* 一个已经很快的索引过程可能看起来没有必要。但是在某些情况下，优化会提高标准索引过程的速度。我们在一些高级用例中看到了这一点，在这些用例中，数据需要比平时更新得更快，有时甚至是实时更新。

我们将讨论以下高级用例:

*   高频数据变化
*   危机
*   黑色星期五或其他高活动事件
*   实时索引，场景 1:预订酒店，预订&租赁可用性
*   实时指数，场景 2:投标和股票市场

**只是对* *标引* *的一个大概说明。对于所有用例，无论是标准用例还是高级用例，您总是希望执行一个"**"批量索引过程，以增量方式更新、*[](https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/how-to/incremental-updates/)、 *和* [*中的数据*](https://www.algolia.com/doc/guides/sending-and-managing-data/send-and-update-your-data/in-depth/the-different-synchronization-strategies/#partial-record-updates)

## [](#high-frequency-data-changes)高频数据变化

在这种情况下，关键是你如何优先考虑一些变化。我们称之为“选择性更新”。例如，您决定现在发送一些更新(如价格)，稍后发送其他更新(如描述)。这降低了每批中的变化次数，缩短了批处理过程的频率(例如，从每 5 分钟到每 1 分钟)。

另一种技术是使用“非删除索引”，即在记录上设置一个“不可用”属性，而不是删除它。就性能而言，删除记录比仅仅更新属性花费更多。但这是一种权衡。虽然更改属性值更快，但通过删除来减小索引的大小总是更好，这样可以更快地建立索引。因此，最佳实践是将这些技术结合起来:每 5 分钟修改一次属性，每 30 分钟删除一次记录。

## [](#crisis)危机

当工厂无法交付货物时，就会发生危机。或者一艘船被困在苏伊士运河，阻断了世界的货物供应。在这些情况下，在线企业必须立即从其网站上删除不可用的商品，并用另一组产品替换它们。他们也可能不得不重新考虑他们的促销活动。

实际上没有理由做任何不同于标准索引过程的事情。然而，如果危机持续的时间太长，或者需要在短时间内进行大量的更改，避免索引过载是很重要的。那么最好的方法就是对变更进行分类:

*   **立即清除缺货商品** 。这里有两种选择:从索引中删除商品，或者使用“脱销”布尔值，过滤掉“脱销”属性为假的记录。如前一节所述，最好的方法是每 5 分钟更改一次属性，每 30 分钟删除一次标记的记录。
*   **在新项目到达时更新**，与其他两个类别分开批量更新。
*   **在批量更新中分别更改促销活动**、，与其他两个类别分开。

 **## [](#black-friday-or-other-high-activity-events)黑色星期五或其他高活动事件

黑色星期五结合了高频率变化和“危机”的场景，所以你会想要遵循那些场景的建议。这里的区别在于，在黑色星期五，高活动期可能比危机持续的时间更长，或者产生突然的活动高峰——但至少你可以提前为活动做好计划，这样更容易管理。

## [](#real-time-indexing-scenario-1-booking-a-hotel-reservations-rental-availability)实时索引，场景 1:预订酒店，预订&租赁房源

用户期望搜索结果能够提供最新、最准确的信息。从技术上讲，这意味着他们希望看到后台的变化立即出现在他们的搜索结果中。企业也希望如此:过时的信息会对利润和客户信任产生负面影响。

举例:预订酒店。如果一家酒店出现在搜索结果中，用户希望当他们点击查看更多细节时，它具有相同的状态和价格。但是如果酒店在查询和点击之间被预订了呢？你可以用一个友好的前端 UX 优雅地管理它(见下文)。但是，您也可以使用额外的索引策略来缓解这个问题，这种策略通常用在实时系统级编程中，它依赖于第二个更小的索引。

你在收集更新的 Algolia 服务器 上创建一个微型索引 *，最多 1000 条记录。前端代码 *会在每次搜索时将这个微小的索引与您的主索引合并，删除结果(如缺货商品)或动态更新信息(如价格)。算法如下:**

*   主指数包含所有产品数据，正常。
*   微小的索引随着每次发生的变化而更新，还不是主要的索引。这个微小的索引应该包含不超过 1000 条记录。
*   对于每个查询，前端合并两个索引。有两种可能:
    *   微型索引包含每个记录的一个属性，即对象 id。如果记录存在于结果中(在对象 id 上匹配)，它将从结果中删除。
    *   微小索引包含 2 个属性(对象 id、价格)。对象 id 用于匹配结果中的记录，价格属性用于覆盖结果中的价格信息。
*   同时，在后端，主索引会定期用小索引中的数据进行更新(遵循前面描述的标准批量更新技术)。微小的索引然后被清零，准备接收新的更新。

备注:

*   客户端合并应该不会影响性能，因为客户端合并简单、快速，并且只包含少量记录。
*   分页:删除结果会影响分页，因为删除的项目会在结果列表中产生空隙。因此，一些搜索结果页面会比其他页面有更少的条目。要解决这个问题，可以在空白处放一个横幅或一个促销广告。但是，如果您需要经常删除项目，最好的解决方案是使用无限滚动或“加载更多”逻辑。

## [](#real-time-indexing-scenario-2-bidding-and-stock-markets)实时指数化，场景二:竞价和股市

在这里，用户期望和业务需求更加严格:这个用例 *要求* 后台的变化在搜索结果中立即显示。我们在股票市场交易或投标应用程序中看到这种情况，价格每秒甚至毫秒都会发生变化。如果您遇到了这种情况，[请联系 Algolia](https://support.algolia.com/hc/en-us) ，讨论您可以在应用程序、引擎和数据上调整的不同高级设置，以最大限度地提高索引性能。虽然很少进行引擎级的更改，但在特殊情况下，它们可以缩短索引时间。

## [](#other-considerations)其他注意事项

### [](#perceived-performance-%e2%80%93-front-end-uiux-solutions%c2%a0%c2%a0)感知性能–F前端 UI/UX 解决方案

表现的一个重要方面是 [*感知表现*](https://simonhearne.com/2021/optimistic-ui-patterns/) 。我们不会在这里讨论 [UI/UX 最佳实践](https://www.algolia.com/blog/product/the-ultimate-guide-to-site-search/)，但是我们想承认构建一个前端的重要性，这个前端给人高性能的感觉。这不是要制造一个错误的印象，而是要告诉用户有一个(合理的)等待时间。友好的进度条 就是一个例子:它友好地要求用户等待，如果时间不太长，人们会接受。有许多同样有效的方法来管理 UI 的性能。

### [](#out-of-the-box-performance)开箱即用的性能

正如我所承诺的，我想说一下我们所说的“开箱即用的高性能”是什么意思。我们的索引采用了以下技术:

*   使用高级索引技术的搜索引擎
*   高性能 [裸机服务器](https://www.algolia.com/doc/guides/scaling/servers-clusters/) 为性能而配置
*   全球可用的基于集群的云基础设施，具有低延迟和服务器冗余(即，无服务器停机)
*   一个带有重试方法的 API，确保(合同上) [99.99%的可用性](https://www.algolia.com/policies/sla/)

## [](#next-readings)下次阅读

我们的第一篇关于索引的文章[](https://www.algolia.com/blog/product/an-exploration-of-search-and-indexing-real-time-indexing-scenarios/)高度概括了标准和高级索引用例。我们的下一篇文章将带您了解 [索引最佳实践](https://www.algolia.com/blog/engineering/search-indexing-best-practices-for-top-performance-with-code-samples/) 以及标准索引过程的实现细节。本文讨论了如何在高级用例中优化索引。

现在是时候帮你构建解决方案了。我们剩余的文章将为我们讨论的一些高级索引用例提供前端&后端代码，从实时定价开始。

要开始索引，您可以 [免费上传您的数据，](https://www.algolia.com/users/sign_up) 或从我们的搜索专家那里获得一个 [定制演示](https://www.algolia.com/demorequest/) 。**
- en: 26  Exploring the Discrete Fourier Transform (DFT)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 26  探索离散傅里叶变换（DFT）
- en: 原文：[https://skeydan.github.io/Deep-Learning-and-Scientific-Computing-with-R-torch/fourier_transform_dft.html](https://skeydan.github.io/Deep-Learning-and-Scientific-Computing-with-R-torch/fourier_transform_dft.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://skeydan.github.io/Deep-Learning-and-Scientific-Computing-with-R-torch/fourier_transform_dft.html](https://skeydan.github.io/Deep-Learning-and-Scientific-Computing-with-R-torch/fourier_transform_dft.html)
- en: This is the first chapter dedicated to the Fourier Transform, but it’s not the
    first time we’re encountering it. In the convolution chapter I mentioned, in passing,
    that the desired outcome is often more economically achieved in the Fourier domain,
    with convolution turning into multiplication. What’s more, we actually *made*
    *use* of the DFT in the chapter on audio classification. There, a call to `torchaudio`’s
    `transform_spectrogram()` triggered the computation of a whole bunch of Fourier
    Transforms, on a set of overlapping time windows constructed from the original
    input sequence.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一本专门介绍傅里叶变换的章节，但并不是我们第一次遇到它。在卷积章节中，我顺便提到了，通常在傅里叶域中更经济地实现期望的结果，卷积变成了乘法。更重要的是，我们在音频分类章节中实际上*使用*了DFT。在那里，对`torchaudio`的`transform_spectrogram()`的调用触发了对原始输入序列构建的一组重叠时间窗口上的大量傅里叶变换的计算。
- en: In this chapter, we won’t content ourselves with purely calling the `torch`-provided
    functions. Instead, we’d like to get a feeling for what’s actually going on. To
    that purpose, we explore the ideas underlying Fourier analysis, and – in a straightforward,
    literal way – translate them into `torch`. In the subsequent chapter, building
    on the understanding we’ll have gained, we will then improve on performance by
    implementing one of the algorithms subsumed under the family of *Fast Fourier
    Transforms* (FFTs).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不会仅仅满足于调用`torch`提供的函数。相反，我们希望了解实际发生的情况。为此，我们探讨了傅里叶分析背后的思想，并以直接、字面的方式将它们翻译成`torch`。在下一章中，基于我们已经获得的理解，我们将通过实现快速傅里叶变换（FFTs）家族下的一个算法来提高性能。
- en: 26.1 Understanding the output of `torch_fft_fft()`
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 26.1 理解`torch_fft_fft()`的输出
- en: 'Our explorations take off hands-on: We call the main function associated with
    the (forward) Fourier Transform, `torch_fft_fft()` [¹](#fn1), and see if we can
    make sense of its output.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的探索从实际操作开始：我们调用与（正向）傅里叶变换相关的主要函数，`torch_fft_fft()` [¹](#fn1)，并看看我们是否能理解其输出。
- en: As we care about actual *understanding*, we start from the simplest possible
    example signal, a pure cosine that performs one revolution over the complete sampling
    period.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们关注的是真正的*理解*，所以我们从最简单的可能示例信号开始，即在整个采样周期内完成一次旋转的纯余弦波。
- en: '26.1.1 Starting point: A cosine of frequency 1'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.1.1 起始点：频率为1的余弦波
- en: 'The way we set things up, there will be sixty-four samples; the sampling period
    thus equals `N = 64`. The content of `frequency()`, the below helper function
    used to construct the signal, reflects how we represent the cosine. Namely:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们的设置，将有64个样本；因此采样周期等于`N = 64`。`frequency()`的内容，以下用于构建信号的辅助函数，反映了我们如何表示余弦波。具体来说：
- en: \[ f(x) = cos(\frac{2 \pi}{N} \ k \ x) \]
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: \[ f(x) = cos(\frac{2 \pi}{N} \ k \ x) \]
- en: Here \(x\) values progress over time (or space), and \(k\) is the *frequency
    index.* A cosine is periodic with period \(2 \pi\); so if we want it to first
    return to its starting state after sixty-four samples, and \(x\) runs between
    zero and sixty-three, we’ll want \(k\) to be equal to \(1\). Like that, we’ll
    reach the initial state again at position \(x = \frac{2 \pi}{64} * 1 * 64\).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，\(x\)值随时间（或空间）变化，\(k\)是*频率索引*。余弦波是周期性的，周期为\(2 \pi\)；因此，如果我们希望它在64个样本后首先返回到其初始状态，并且\(x\)在零到63之间运行，我们将希望\(k\)等于1。这样，我们将在位置\(x
    = \frac{2 \pi}{64} * 1 * 64\)再次达到初始状态。
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Let’s quickly confirm this did what it was supposed to ([fig. 26.1](#fig-dft-cos-1-rev)):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*让我们快速确认这是否如预期的那样做了（[图26.1](#fig-dft-cos-1-rev)）：'
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*![A cosine function, starting with y=1 at x=0, and arriving at y=1 again at
    x=63.](../Images/285997d2b23324293dab1fb941e5519a.png)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*![一个余弦函数，从x=0处的y=1开始，并在x=63处再次到达y=1](../Images/285997d2b23324293dab1fb941e5519a.png)'
- en: 'Figure 26.1: Pure cosine that accomplishes one revolution over the complete
    sample period (64 samples).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图26.1：在整个采样周期（64个样本）内完成一次完整旋转的纯余弦波。
- en: 'Now that we have the input signal, `torch_fft_fft()` computes for us the Fourier
    coefficients, that is, the importance of the various frequencies present in the
    signal. The number of frequencies considered will equal the number of sampling
    points: So \(X\) will be of length sixty-four as well.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了输入信号，`torch_fft_fft()` 为我们计算傅里叶系数，即信号中各种频率的重要性。考虑的频率数量将等于采样点的数量：因此 \(X\)
    的长度也将是六十四。
- en: (In our example, you’ll notice that the second half of coefficients will equal
    the first in magnitude.[²](#fn2) This is the case for every real-valued signal.
    In such cases, you could call `torch_fft_rfft()` instead, which yields “nicer”
    (in the sense of shorter) vectors to work with. Here though, I want to explain
    the general case, since that’s what you’ll find done in most expositions on the
    topic.)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: （在我们的例子中，你会注意到系数的后半部分在幅度上将与前半部分相等。[²](#fn2) 对于每个实值信号，情况都是如此。在这种情况下，你可以使用 `torch_fft_rfft()`，它会产生“更简洁”的（在意义上是更短的）向量来处理。然而，在这里，我想解释一般情况，因为这是你在大多数关于这个主题的阐述中会发现的情况。）
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Even with the signal being real, the Fourier coefficients are complex numbers.
    There are four ways to inspect them. The first is to extract the real part:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*即使信号是实数，傅里叶系数也是复数。有四种方法可以检查它们。第一种是提取实部：'
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE4]'
- en: Only a single coefficient is non-zero, the one at position 1\. (We start counting
    from zero, and may discard the second half, as explained above.)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个系数是非零的，即位置 1 处的系数。（我们从零开始计数，并且可以丢弃上面解释的第二半部分。）
- en: 'Now looking at the imaginary part, we find it is zero throughout:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看虚部，我们发现它始终为零：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE6]'
- en: 'At this point we know that there is just a single frequency present in the
    signal, namely, that at \(k = 1\). This matches (and it better had to) the way
    we constructed the signal: namely, as accomplishing a single revolution over the
    complete sampling period.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们知道信号中只存在一个频率，即 \(k = 1\) 处的频率。这与（它必须如此）我们构建信号的方式相匹配：即在整个采样周期内完成一次完整的旋转。
- en: 'Since, in theory, every coefficient could have non-zero real and imaginary
    parts, often what you’d report is the magnitude (the square root of the sum of
    squared real and imaginary parts):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于理论上每个系数都可能具有非零的实部和虚部，通常你会报告的是幅度（实部和虚部平方和的平方根）：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE8]'
- en: Unsurprisingly, these values exactly reflect the respective real parts.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值正好反映了相应的实部。
- en: Finally, there’s the phase, indicating a possible shift of the signal (a pure
    cosine is unshifted). In `torch`, we have `torch_angle()` complementing `torch_abs()`,
    but we need to take into account roundoff error here. We know that in each but
    a single case, the real and imaginary parts are both exactly zero; but due to
    finite precision in how numbers are presented in a computer, the actual values
    will often not be zero. Instead, they’ll be very small. If we take one of these
    “fake non-zeroes” and divide it by another, as happens in the angle calculation,
    big values can result. To prevent this from happening, our custom implementation
    rounds both inputs before triggering the division.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是相位，表示信号可能发生的偏移（纯余弦波没有偏移）。在 `torch` 中，我们有 `torch_angle()` 补充 `torch_abs()`，但在这里我们需要考虑舍入误差。我们知道，在除了一个情况之外的所有情况下，实部和虚部都是精确为零的；但由于计算机中数字表示的有限精度，实际值通常不会是零。相反，它们会非常小。如果我们取这些“假非零”中的一个，并将其除以另一个，就像在角度计算中发生的那样，结果可能会很大。为了避免这种情况发生，我们的自定义实现会在触发除法之前对两个输入进行四舍五入。
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*[PRE10]'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE10]'
- en: As expected, there is no phase shift in the signal.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，信号中没有相位偏移。
- en: Let’s visualize what we found ([fig. 26.2](#fig-dft-cos-1-rev-dft)).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们可视化我们所发现的内容 ([图 26.2](#fig-dft-cos-1-rev-dft))。
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*![Top row: Left: Real part. y=32 at x=1 and x=63\. Right: Imaginary part.
    All y=0\. Bottom row: Left: Magnitude. y=32 at x=1 and x=63\. Right: Phase. All
    y=0.](../Images/7214580ae517ad3c55ddbbfe50399916.png)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*![顶层：左：实部。y=32 在 x=1 和 x=63 处。右：虚部。所有 y=0。底层：左：幅度。y=32 在 x=1 和 x=63 处。右：相位。所有
    y=0。](../Images/7214580ae517ad3c55ddbbfe50399916.png)'
- en: 'Figure 26.2: Real parts, imaginary parts, magnitudes and phases of the Fourier
    coefficients, obtained on a pure cosine that performs a single revolution over
    the sampling period. Imaginary parts as well as phases are all zero.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 26.2：纯余弦波在采样周期内完成一次完整旋转时获得的傅里叶系数的实部、虚部、幅度和相位。虚部和相位都是零。
- en: It’s fair to say that we have no reason to doubt what `torch_fft_fft()` has
    done. But with a pure sinusoid like this, we can understand exactly what’s going
    on by computing the DFT ourselves, by hand. Doing this now will significantly
    help us later, when we’re writing the code.********  ***### 26.1.2 Reconstructing
    the magic
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 诚实地讲，我们没有理由怀疑`torch_fft_fft()`函数所做的工作。但是，对于这样一个纯正弦波，我们可以通过自己手动计算DFT来确切地了解正在发生什么。现在这样做将大大有助于我们以后编写代码。********  ***###
    26.1.2 重建魔法
- en: 'One caveat about this section. With a topic as rich as the Fourier Transform,
    and an audience who I imagine to vary widely on a dimension of math and sciences
    education, my chances to meet *your* expectations, dear reader, must be very close
    to zero. Still, I want to take the risk. If you’re an expert on these things,
    you’ll anyway be just scanning the text, looking out for pieces of `torch` code.
    If you’re moderately familiar with the DFT, you may still like being reminded
    of its inner workings. And – most importantly – if you’re rather new, or even
    completely new, to this topic, you’ll hopefully take away (at least) one thing:
    that what seems like one of the greatest wonders of the universe (assuming there
    is a reality somehow corresponding to what goes on in our minds) may well be a
    *wonder*, but neither “magic” nor a thing reserved to the initiated.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本节有一个注意事项。对于一个像傅里叶变换这样丰富的主题，以及一个我设想在数学和科学教育维度上差异很大的受众，我满足您期望的机会几乎为零。尽管如此，我还是想冒险一试。如果您是这些领域的专家，您无论如何也只是在扫描文本，寻找`torch`代码的片段。如果您对DFT比较熟悉，您可能仍然喜欢回顾其内部工作原理。最重要的是——如果您对这个主题相对较新，甚至完全陌生——您可能会得到（至少）一点收获：看似宇宙中最大的奇迹之一（假设我们的现实与我们的思维活动以某种方式相对应）可能确实是一个**奇迹**，但既不是“魔法”也不是只有内行人才能理解的东西。
- en: 'In a nutshell, the Fourier Transform is a *basis transformation*. In the case
    of the DFT – the Discrete Fourier Transform, where time and frequency representations
    both are finite vectors, not functions – the new basis looks like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，傅里叶变换是一种**基变换**。在离散傅里叶变换（DFT）的情况下——时间域和频率域都表示为有限向量，而不是函数——新的基看起来是这样的：
- en: \[ \begin{aligned} &\mathbf{w}^{0n}_N = e^{i\frac{2 \pi}{N}* 0 * n} = 1\\ &\mathbf{w}^{1n}_N
    = e^{i\frac{2 \pi}{N}* 1 * n} = e^{i\frac{2 \pi}{N} n}\\ &\mathbf{w}^{2n}_N =
    e^{i\frac{2 \pi}{N}* 2 * n} = e^{i\frac{2 \pi}{N}2n}\\& ... \\ &\mathbf{w}^{(N-1)n}_N
    = e^{i\frac{2 \pi}{N}* (N-1) * n} = e^{i\frac{2 \pi}{N}(N-1)n}\\ \end{aligned}
    \]
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{aligned} &\mathbf{w}^{0n}_N = e^{i\frac{2 \pi}{N}* 0 * n} = 1\\ &\mathbf{w}^{1n}_N
    = e^{i\frac{2 \pi}{N}* 1 * n} = e^{i\frac{2 \pi}{N} n}\\ &\mathbf{w}^{2n}_N =
    e^{i\frac{2 \pi}{N}* 2 * n} = e^{i\frac{2 \pi}{N}2n}\\& ... \\ &\mathbf{w}^{(N-1)n}_N
    = e^{i\frac{2 \pi}{N}* (N-1) * n} = e^{i\frac{2 \pi}{N}(N-1)n}\\ \end{aligned}
    \]
- en: 'Here \(N\), as before, is the number of samples (64, in our case); thus, there
    are \(N\) basis vectors. With \(k\) running through the basis vectors, they can
    be written:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里\(N\)，像之前一样，是样本数（在我们的例子中是64）；因此，有\(N\)个基向量。随着\(k\)遍历基向量，它们可以写成：
- en: \[ \mathbf{w}^{kn}_N = e^{i\frac{2 \pi}{N}k n} \tag{26.1}\]
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \mathbf{w}^{kn}_N = e^{i\frac{2 \pi}{N}k n} \tag{26.1}\]
- en: 'Like \(k\), \(n\) runs from \(0\) to \(N-1\). To understand what these basis
    vectors are doing, it is helpful to temporarily switch to a shorter sampling period,
    \(N = 4\), say. If we do so, we have four basis vectors: \(\mathbf{w}^{0n}_N\),
    \(\mathbf{w}^{1n}_N\), \(\mathbf{w}^{2n}_N\), and \(\mathbf{w}^{3n}_N\). The first
    one looks like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与\(k\)一样，\(n\)从\(0\)运行到\(N-1\)。为了理解这些基向量在做什么，暂时切换到一个较短的采样周期，比如\(N = 4\)，是有帮助的。如果我们这样做，我们就有四个基向量：\(\mathbf{w}^{0n}_N\)、\(\mathbf{w}^{1n}_N\)、\(\mathbf{w}^{2n}_N\)和\(\mathbf{w}^{3n}_N\)。第一个看起来是这样的：
- en: \[ \mathbf{w}^{0n}_N = \begin{bmatrix} e^{i\frac{2 \pi}{4}* 0 * 0}\\ e^{i\frac{2
    \pi}{4}* 0 * 1}\\ e^{i\frac{2 \pi}{4}* 0 * 2}\\ e^{i\frac{2 \pi}{4}* 0 * 3} \end{bmatrix}
    = \begin{bmatrix} 1\\ 1\\ 1\\ 1\\ \end{bmatrix} \]
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \mathbf{w}^{0n}_N = \begin{bmatrix} e^{i\frac{2 \pi}{4}* 0 * 0}\\ e^{i\frac{2
    \pi}{4}* 0 * 1}\\ e^{i\frac{2 \pi}{4}* 0 * 2}\\ e^{i\frac{2 \pi}{4}* 0 * 3} \end{bmatrix}
    = \begin{bmatrix} 1\\ 1\\ 1\\ 1\\ \end{bmatrix} \]
- en: 'The second, like so:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个，如下所示：
- en: \[ \mathbf{w}^{1n}_N = \begin{bmatrix} e^{i\frac{2 \pi}{4}* 1 * 0}\\ e^{i\frac{2
    \pi}{4}* 1 * 1}\\ e^{i\frac{2 \pi}{4}* 1 * 2}\\ e^{i\frac{2 \pi}{4}* 1 * 3} \end{bmatrix}
    = \begin{bmatrix} 1\\ e^{i\frac{\pi}{2}}\\ e^{i \pi}\\ e^{i\frac{3 \pi}{4}} \end{bmatrix}
    = \begin{bmatrix} 1\\ i\\ -1\\ -i\\ \end{bmatrix} \]
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \mathbf{w}^{1n}_N = \begin{bmatrix} e^{i\frac{2 \pi}{4}* 1 * 0}\\ e^{i\frac{2
    \pi}{4}* 1 * 1}\\ e^{i\frac{2 \pi}{4}* 1 * 2}\\ e^{i\frac{2 \pi}{4}* 1 * 3} \end{bmatrix}
    = \begin{bmatrix} 1\\ e^{i\frac{\pi}{2}}\\ e^{i \pi}\\ e^{i\frac{3 \pi}{4}} \end{bmatrix}
    = \begin{bmatrix} 1\\ i\\ -1\\ -i\\ \end{bmatrix} \]
- en: 'This is the third:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第三个：
- en: \[ \mathbf{w}^{2n}_N = \begin{bmatrix} e^{i\frac{2 \pi}{4}* 2 * 0}\\ e^{i\frac{2
    \pi}{4}* 2 * 1}\\ e^{i\frac{2 \pi}{4}* 2 * 2}\\ e^{i\frac{2 \pi}{4}* 2 * 3} \end{bmatrix}
    = \begin{bmatrix} 1\\ e^{i\pi}\\ e^{i 2 \pi}\\ e^{i\frac{3 \pi}{2}} \end{bmatrix}
    = \begin{bmatrix} 1\\ -1\\ 1\\ -1\\ \end{bmatrix} \]
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \mathbf{w}^{2n}_N = \begin{bmatrix} e^{i\frac{2 \pi}{4}* 2 * 0}\\ e^{i\frac{2
    \pi}{4}* 2 * 1}\\ e^{i\frac{2 \pi}{4}* 2 * 2}\\ e^{i\frac{2 \pi}{4}* 2 * 3} \end{bmatrix}
    = \begin{bmatrix} 1\\ e^{i\pi}\\ e^{i 2 \pi}\\ e^{i\frac{3 \pi}{2}} \end{bmatrix}
    = \begin{bmatrix} 1\\ -1\\ 1\\ -1\\ \end{bmatrix} \]
- en: 'And finally, the fourth:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第四个：
- en: \[ \mathbf{w}^{3n}_N = \begin{bmatrix} e^{i\frac{2 \pi}{4}* 3 * 0}\\ e^{i\frac{2
    \pi}{4}* 3 * 1}\\ e^{i\frac{2 \pi}{4}* 3 * 2}\\ e^{i\frac{2 \pi}{4}* 3 * 3} \end{bmatrix}
    = \begin{bmatrix} 1\\ e^{i\frac{3 \pi}{2}}\\ e^{i 3 \pi}\\ e^{i\frac{9 \pi}{2}}
    \end{bmatrix} = \begin{bmatrix} 1\\ -i\\ -1\\ i\\ \end{bmatrix} \]
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \mathbf{w}^{3n}_N = \begin{bmatrix} e^{i\frac{2 \pi}{4}* 3 * 0}\\ e^{i\frac{2
    \pi}{4}* 3 * 1}\\ e^{i\frac{2 \pi}{4}* 3 * 2}\\ e^{i\frac{2 \pi}{4}* 3 * 3} \end{bmatrix}
    = \begin{bmatrix} 1\\ e^{i\frac{3 \pi}{2}}\\ e^{i 3 \pi}\\ e^{i\frac{9 \pi}{2}}
    \end{bmatrix} = \begin{bmatrix} 1\\ -i\\ -1\\ i\\ \end{bmatrix} \]
- en: 'We can characterize these four basis vectors in terms of their “speed”: how
    fast they move around the unit circle. To do this, we simply look at the rightmost
    column vectors, where the final calculation results appear. The values in that
    column correspond to positions pointed to by the revolving basis vector at different
    points in time. This means that looking at a single “update of position”, we can
    see how fast the vector is moving in a single time step.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用它们的“速度”来描述这四个基向量：它们围绕单位圆移动的速度有多快。要做到这一点，我们只需看看最右边的列向量，那里最终的计算结果出现。该列中的值对应于旋转基向量在不同时间点的指向。这意味着，通过观察单个“位置更新”，我们可以看到向量在单个时间步长内移动的速度。
- en: Looking first at \(\mathbf{w}^{0n}_N\), we see that it does not move at all.
    \(\mathbf{w}^{1n}_N\) goes from \(1\) to \(i\) to \(-1\) to \(-i\); one more step,
    and it would be back where it started. That’s one revolution in four steps, or
    a step size of \(\frac{\pi}{2}\). Then \(\mathbf{w}^{2n}_N\) goes at double that
    pace, moving a distance of \(\pi\) along the circle. That way, it ends up completing
    two revolutions overall. Finally, \(\mathbf{w}^{3n}_N\) achieves three complete
    loops, for a step size of \(\frac{3 \pi}{2}\).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先看看 \(\mathbf{w}^{0n}_N\)，我们看到它根本不动。\(\mathbf{w}^{1n}_N\) 从 \(1\) 到 \(i\) 到
    \(-1\) 到 \(-i\)；再走一步，它就会回到起点。这是四步完成一次旋转，或者步长为 \(\frac{\pi}{2}\)。然后 \(\mathbf{w}^{2n}_N\)
    以两倍的速度移动，沿着圆周移动的距离为 \(\pi\)。这样，它总共完成了两次旋转。最后，\(\mathbf{w}^{3n}_N\) 完成了三个完整的循环，步长为
    \(\frac{3 \pi}{2}\)。
- en: 'The thing that makes these basis vectors so useful is that they are mutually
    orthogonal. That is, their dot product is zero:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基向量之所以如此有用，是因为它们是相互正交的。也就是说，它们的点积为零：
- en: \[ \langle \mathbf{w}^{kn}_N, \mathbf{w}^{ln}_N \rangle \ = \ \sum_{n=0}^{N-1}
    ({e^{i\frac{2 \pi}{N}k n}})^* e^{i\frac{2 \pi}{N}l n} = \ \sum_{n=0}^{N-1} ({e^{-i\frac{2
    \pi}{N}k n}})e^{i\frac{2 \pi}{N}l n} = 0 \tag{26.2}\]
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \langle \mathbf{w}^{kn}_N, \mathbf{w}^{ln}_N \rangle \ = \ \sum_{n=0}^{N-1}
    ({e^{i\frac{2 \pi}{N}k n}})^* e^{i\frac{2 \pi}{N}l n} = \ \sum_{n=0}^{N-1} ({e^{-i\frac{2
    \pi}{N}k n}})e^{i\frac{2 \pi}{N}l n} = 0 \tag{26.2}\]
- en: Let’s take, for example, \(\mathbf{w}^{2n}_N\) and \(\mathbf{w}^{3n}_N\). Indeed,
    their dot product evaluates to zero.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以 \(\mathbf{w}^{2n}_N\) 和 \(\mathbf{w}^{3n}_N\) 为例。确实，它们的点积等于零。
- en: \[ \begin{bmatrix} 1 & -1 & 1 & -1\\ \end{bmatrix} \begin{bmatrix} 1\\ -i\\
    -1\\ i\\ \end{bmatrix} = 1 + i + (-1) + (-i) = 0 \]
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{bmatrix} 1 & -1 & 1 & -1\\ \end{bmatrix} \begin{bmatrix} 1\\ -i\\
    -1\\ i\\ \end{bmatrix} = 1 + i + (-1) + (-i) = 0 \]
- en: 'Now, we’re about to see how the orthogonality of the Fourier basis substantially
    simplifies the calculation of the DFT. Did you notice the similarity between these
    basis vectors and the way we wrote the example signal? Here it is again:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到傅里叶基的正交性如何大大简化 DFT 的计算。你注意到这些基向量与我们写示例信号的方式之间的相似性了吗？这里再次展示：
- en: \[ f(x) = cos(\frac{2 \pi}{N} k x) \]
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: \[ f(x) = cos(\frac{2 \pi}{N} k x) \]
- en: If we manage to represent this function in terms of the basis vectors \(\mathbf{w}^{kn}_N
    = e^{i\frac{2 \pi}{N}k n}\), the inner product between the function and each basis
    vector will be either zero (the “default”) or a multiple of one (in case the function
    has a component matching the basis vector in question). Luckily, sines and cosines
    can easily be converted into complex exponentials. In our example, this is how
    that goes:[³](#fn3)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够用基向量 \(\mathbf{w}^{kn}_N = e^{i\frac{2 \pi}{N}k n}\) 来表示这个函数，那么该函数与每个基向量的内积将是零（“默认值”）或一的一个倍数（如果函数有一个与所讨论的基向量匹配的分量）。幸运的是，正弦和余弦可以很容易地转换为复指数。在我们的例子中，就是这样进行的：[³](#fn3)
- en: \[ \begin{aligned} \mathbf{x}_n &= cos(\frac{2 \pi}{64} n) \\ &= \frac{1}{2}
    (e^{i\frac{2 \pi}{64} n} + e^{-i\frac{2 \pi}{64} n}) \\ &= \frac{1}{2} (e^{i\frac{2
    \pi}{64} n} + e^{i\frac{2 \pi}{64} 63n}) \\ &= \frac{1}{2} (\mathbf{w}^{1n}_N
    + \mathbf{w}^{63n}_N) \end{aligned} \]
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{aligned} \mathbf{x}_n &= cos(\frac{2 \pi}{64} n) \\ &= \frac{1}{2}
    (e^{i\frac{2 \pi}{64} n} + e^{-i\frac{2 \pi}{64} n}) \\ &= \frac{1}{2} (e^{i\frac{2
    \pi}{64} n} + e^{i\frac{2 \pi}{64} 63n}) \\ &= \frac{1}{2} (\mathbf{w}^{1n}_N
    + \mathbf{w}^{63n}_N) \end{aligned} \]
- en: Here the first step directly results from Euler’s formula[⁴](#fn4), and the
    second reflects the fact that the Fourier coefficients are periodic, with frequency
    -1 being the same as 63, -2 equaling 62, and so on.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里第一步直接来自欧拉公式[⁴](#fn4)，第二步反映了傅里叶系数的周期性，频率 -1 与 63 相同，-2 等于 62，依此类推。
- en: Now, the \(k\)th Fourier coefficient is obtained by projecting the signal onto
    basis vector \(k\).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，第 \(k\) 个傅里叶系数是通过将信号投影到基向量 \(k\) 上获得的。
- en: 'Due to the orthogonality of the basis vectors, only two coefficients will not
    be zero: those for \(\mathbf{w}^{1n}_N\) and \(\mathbf{w}^{63n}_N\). They are
    obtained by computing the inner product between the function and the basis vector
    in question, that is, by summing over \(n\). For each \(n\) ranging between \(0\)
    and \(N-1\), we have a contribution of \(\frac{1}{2}\), leaving us with a final
    sum of \(32\) for both coefficients. For example, for \(\mathbf{w}^{1n}_N\):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于基向量正交，只有两个系数不会为零：分别是 \(\mathbf{w}^{1n}_N\) 和 \(\mathbf{w}^{63n}_N\) 的系数。它们是通过计算函数与相关基向量的内积获得的，即通过求和
    \(n\) 得到的。对于 \(0\) 到 \(N-1\) 之间的每个 \(n\)，我们有一个 \(\frac{1}{2}\) 的贡献，使得两个系数的最终和为
    \(32\)。例如，对于 \(\mathbf{w}^{1n}_N\)：
- en: \[ \begin{aligned} X_1 &= \langle \mathbf{w}^{1n}_N, \mathbf{x}_n \rangle \\
    &= \langle \mathbf{w}^{1n}_N, \frac{1}{2} (\mathbf{w}^{1n}_N + \mathbf{w}^{63n}_N)
    \rangle \\ &= \frac{1}{2} * 64 \\ &= 32 \end{aligned} \]
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{aligned} X_1 &= \langle \mathbf{w}^{1n}_N, \mathbf{x}_n \rangle \\
    &= \langle \mathbf{w}^{1n}_N, \frac{1}{2} (\mathbf{w}^{1n}_N + \mathbf{w}^{63n}_N)
    \rangle \\ &= \frac{1}{2} * 64 \\ &= 32 \end{aligned} \]
- en: And analogously for \(X_{63}\).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 \(X_{63}\) 也是类似的。
- en: Now, looking back at what `torch_fft_fft()` gave us, we see we were able to
    arrive at the same result. And we’ve learned something along the way.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回顾一下 `torch_fft_fft()` 给我们的结果，我们看到我们能够得到相同的结果。而且我们在过程中学到了一些东西。
- en: 'As long as we stay with signals composed of one or more basis vectors, we can
    compute the DFT in this way. At the end of the chapter, we’ll develop code that
    will work for all signals, but first, let’s see if we can dive even deeper into
    the workings of the DFT. Three things we’ll want to explore:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们处理由一个或多个基向量组成的信号，我们就可以用这种方法计算 DFT。在本章的结尾，我们将开发适用于所有信号的代码，但首先，让我们看看我们是否可以更深入地了解
    DFT 的工作原理。我们将探索三个问题：
- en: What would happen if frequencies changed – say, a melody were sung at a higher
    pitch?
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果频率发生变化会怎样呢——比如说，旋律以更高的音调演唱？
- en: What about amplitude changes – say, the music were played twice as loud?
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那么，关于振幅变化呢——比如说，音乐被播放得声音大了一倍？
- en: What about phase – e.g., there were an offset before the piece started?
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那么，关于相位——例如，在作品开始之前有一个偏移量？
- en: In all cases, we’ll call `torch_fft_fft()` only once we’ve determined the result
    ourselves.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，我们只有在自己确定结果后才会调用 `torch_fft_fft()`。
- en: And finally, we’ll see how complex sinusoids, made up of different components,
    can still be analyzed in this way, provided they can be expressed in terms of
    the frequencies that make up the basis.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看到由不同成分组成的复正弦波，只要它们可以用构成基的频率来表示，仍然可以用这种方法进行分析。
- en: 26.1.3 Varying frequency
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 26.1.3 频率变化
- en: 'Assume we quadrupled the frequency, giving us a signal that looked like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将频率增加到四倍，得到一个看起来像这样的信号：
- en: \[ \mathbf{x}_n = cos(\frac{2 \pi}{N}*4*n) \]
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \mathbf{x}_n = cos(\frac{2 \pi}{N}*4*n) \]
- en: 'Following the same logic as above, we can express it like so:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 按照上述相同的逻辑，我们可以这样表示：
- en: \[ \mathbf{x}_n = \frac{1}{2} (\mathbf{w}^{4n}_N + \mathbf{w}^{60n}_N) \]
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \mathbf{x}_n = \frac{1}{2} (\mathbf{w}^{4n}_N + \mathbf{w}^{60n}_N) \]
- en: We already see that non-zero coefficients will be obtained only for frequency
    indices \(4\) and \(60\). Picking the former, we obtain
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，只有频率索引 \(4\) 和 \(60\) 才会得到非零系数。选择前者，我们得到
- en: \[ \begin{aligned} X_4 &= \langle \mathbf{w}^{4n}_N, \mathbf{x}_n \rangle \\
    &= \langle \mathbf{w}^{4n}_N, \frac{1}{2} (\mathbf{w}^{4n}_N + \mathbf{w}^{60n}_N)
    \rangle \\ &= 32 \end{aligned} \]
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{aligned} X_4 &= \langle \mathbf{w}^{4n}_N, \mathbf{x}_n \rangle \\
    &= \langle \mathbf{w}^{4n}_N, \frac{1}{2} (\mathbf{w}^{4n}_N + \mathbf{w}^{60n}_N)
    \rangle \\ &= 32 \end{aligned} \]
- en: For the latter, we’d arrive at the same result.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于后者，我们会得到相同的结果。
- en: Now, let’s make sure our analysis is correct. The following code snippet contains
    nothing new; it generates the signal, calculates the DFT, and plots them both
    ([fig. 26.3](#fig-dft-cos-4-rev)).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们确保我们的分析是正确的。以下代码片段没有任何新内容；它生成信号，计算DFT，并绘制它们（[图26.3](#fig-dft-cos-4-rev)）。
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*![Top row: A cosine function, going through y=1 four times. Middle row: Left:
    Real part. y=32 at x=4 and x=60\. Right: Imaginary part. All y=0\. Bottom row:
    Left: Magnitude. y=32 at x=4 and x=60\. Right: Phase. All y=0.](../Images/c94460afa30f7e0a33d862cbbe590b9b.png)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*![顶部行：一个余弦函数，通过y=1四次。中间行：左：实部。y=32在x=4和x=60处。右：虚部。所有y=0。底部行：左：幅度。y=32在x=4和x=60处。右：相位。所有y=0。](../Images/c94460afa30f7e0a33d862cbbe590b9b.png)'
- en: 'Figure 26.3: A pure cosine that performs four revolutions over the sampling
    period, and its DFT. Imaginary parts and phases are still are zero.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图26.3：在采样周期内完成四次旋转的纯余弦波及其DFT。虚部和相位仍然为零。
- en: This does indeed confirm our calculations.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实证实了我们的计算。
- en: 'A special case arises when signal frequency rises to the highest one “allowed”,
    in the sense of being detectable without aliasing. That will be the case at one
    half of the number of sampling points. Then, the signal will look like so:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当信号频率达到“允许”的最高频率时，即在没有混叠的情况下可检测的频率，会出现一个特殊情况。这将在采样点数的一半处发生。那么，信号将看起来是这样的：
- en: \[ \mathbf{x}_n = \frac{1}{2} (\mathbf{w}^{32n}_N + \mathbf{w}^{32n}_N) \]
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \mathbf{x}_n = \frac{1}{2} (\mathbf{w}^{32n}_N + \mathbf{w}^{32n}_N) \]
- en: 'Consequently, we end up with a single coefficient, corresponding to a frequency
    of 32 revolutions per sample period, of double the magnitude (64, thus). Here
    are the signal and its DFT ([fig. 26.4](#fig-dft-cos-32-rev.png)):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们最终得到一个系数，对应于每样本周期的32次旋转频率，其幅度是原来的两倍（64，因此）。以下是信号及其DFT（[图26.4](#fig-dft-cos-32-rev.png)）：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*![Top row: A cosine function, going through y=1 32 times. Middle row: Left:
    Real part. y=64 at x=32\. Right: Imaginary part. All y=0\. Bottom row: Left: Magnitude.
    y=64 at x=32\. Right: Phase. All y=0.](../Images/bf9b43de4b303ca7000370cc6b476b47.png)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*![顶部行：一个余弦函数，通过y=1 32次。中间行：左：实部。y=64在x=32处。右：虚部。所有y=0。底部行：左：幅度。y=64在x=32处。右：相位。所有y=0。](../Images/bf9b43de4b303ca7000370cc6b476b47.png)'
- en: 'Figure 26.4: A pure cosine that performs thirty-two revolutions over the sampling
    period, and its DFT. This is the highest frequency where, given sixty-four sample
    points, no aliasing will occur. Imaginary parts and phases still zero.**  **###
    26.1.4 Varying amplitude'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图26.4：在采样周期内完成32次旋转的纯余弦波及其DFT。这是在给定64个样本点的情况下，不会发生混叠的最高频率。虚部和相位仍然为零。**  **###
    26.1.4 改变幅度
- en: Now, let’s think about what happens when we vary amplitude. For example, say
    the signal gets twice as loud. Now, there will be a multiplier of 2 that can be
    taken outside the inner product. In consequence, the only thing that changes is
    the magnitude of the coefficients.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们思考一下当我们改变幅度时会发生什么。例如，假设信号变得响亮了两倍。现在，将有一个2的乘数可以移出内积。因此，唯一改变的是系数的幅度。
- en: 'Let’s verify this. The modification is based on the example we had before the
    very last one, with four revolutions over the sampling period ([fig. 26.5](#fig-dft-cos-mult-amplitude)):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证这一点。这次修改基于我们之前最后一个例子，即在采样周期内完成四次旋转的例子（[图26.5](#fig-dft-cos-mult-amplitude)）。
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*![Top row: A cosine function, going through y=1 four times. Middle row: Left:
    Real part. y=64 at x=4 and x=60\. Right: Imaginary part. All y=0\. Bottom row:
    Left: Magnitude. y=64 at x=4 and x=60\. Right: Phase. All y=0.](../Images/8ab5b34f1243ef27cfaa5b35f7b2e451.png)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*![顶部行：一个余弦函数，通过y=1四次。中间行：左：实部。y=64在x=4和x=60处。右：虚部。所有y=0。底部行：左：幅度。y=64在x=4和x=60处。右：相位。所有y=0。](../Images/8ab5b34f1243ef27cfaa5b35f7b2e451.png)'
- en: 'Figure 26.5: Pure cosine with four revolutions over the sampling period, and
    doubled amplitude. Imaginary parts and phases still zero.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图26.5：在采样周期内完成四次旋转的纯余弦波，幅度加倍。虚部和相位仍然为零。
- en: So far, we have not once seen a coefficient with non-zero imaginary part. To
    change this, we add in *phase*.*  *### 26.1.5 Adding phase
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一次也没有看到虚部非零的系数。为了改变这一点，我们添加了*相位*。*  *### 26.1.5 添加相位
- en: Changing the phase of a signal means shifting it in time. Our example signal
    is a cosine, a function whose value is 1 at \(t=0\). (That also was the – arbitrarily
    chosen – starting point of the signal.)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 改变信号的相位意味着在时间上移动它。我们的示例信号是一个余弦波，其值在\(t=0\)时为1。（这也是信号——任意选择的——起始点。）
- en: 'Now assume we shift the signal forward by \(\frac{\pi}{2}\). Then the peak
    we were seeing at zero moves over to \(\frac{\pi}{2}\); and if we still start
    “recording” at zero, we must find a value of zero there. An equation describing
    this is the following. For convenience, we assume a sampling period of \(2 \pi\)
    and \(k=1\), so that the example is a simple cosine:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们将信号向前平移 \(\frac{\pi}{2}\)。那么我们之前在零处看到的峰值将移动到 \(\frac{\pi}{2}\)；如果我们仍然从零开始“记录”，我们必须在那里找到一个值为零。描述这一点的方程如下。为了方便起见，我们假设采样周期为
    \(2 \pi\) 和 \(k=1\)，这样示例就是一个简单的余弦波：
- en: \[ f(x) = cos(x - \phi) \]
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: \[ f(x) = cos(x - \phi) \]
- en: 'The minus sign may look unintuitive at first. But it does make sense: We now
    want to obtain a value of 1 at \(x=\frac{\pi}{2}\), so \(x - \phi\) should evaluate
    to zero. (Or to any multiple of \(\pi\).) Summing up, a *delay* in time will appear
    as a *negative phase shift*.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 负号一开始可能看起来不太直观。但它确实是有意义的：我们现在希望在 \(x=\frac{\pi}{2}\) 处获得值为 1，因此 \(x - \phi\)
    应该评估为零。（或者任何 \(\pi\) 的倍数。）总结来说，时间上的延迟将表现为负相移。
- en: Now, we’re going to calculate the DFT for a shifted version of our example signal.
    But if you like, take a peek at the phase-shifted version of the time-domain picture
    now already. You’ll see that a cosine, delayed by \(\frac{\pi}{2}\), is nothing
    else than a sine starting at 0.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将计算我们示例信号的平移版本的正交快速傅里叶变换（DFT）。但如果你愿意，现在可以先看看时域图象的相移版本。你会发现，延迟 \(\frac{\pi}{2}\)
    的余弦波实际上是从 0 开始的正弦波。
- en: 'To compute the DFT, we follow our familiar-by-now strategy. The signal now
    looks like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算 DFT，我们遵循现在熟悉的策略。信号现在看起来是这样的：
- en: \[ \mathbf{x}_n = cos(\frac{2 \pi}{N}*4*x - \frac{\pi}{2}) \]
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \mathbf{x}_n = cos(\frac{2 \pi}{N}*4*x - \frac{\pi}{2}) \]
- en: 'First, we express it in terms of basis vectors:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们用基向量表示它：
- en: \[ \begin{aligned} \mathbf{x}_n &= cos(\frac{2 \pi}{64} 4 n - \frac{\pi}{2})
    \\ &= \frac{1}{2} (e^{i\frac{2 \pi}{64} 4n - \frac{pi}{2}} + e^{i\frac{2 \pi}{64}
    60n - \frac{pi}{2}}) \\ &= \frac{1}{2} (e^{i\frac{2 \pi}{64} 4n} e^{-i \frac{\pi}{2}}
    + e^{i\frac{2 \pi}{64} 60n} e^{i\frac{pi}{2}}) \\ &= \frac{1}{2} (e^{-i \frac{\pi}{2}}
    \mathbf{w}^{4n}_N + e^{i \frac{\pi}{2}} \mathbf{w}^{60n}_N) \end{aligned} \]
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{aligned} \mathbf{x}_n &= cos(\frac{2 \pi}{64} 4 n - \frac{\pi}{2})
    \\ &= \frac{1}{2} (e^{i\frac{2 \pi}{64} 4n - \frac{pi}{2}} + e^{i\frac{2 \pi}{64}
    60n - \frac{pi}{2}}) \\ &= \frac{1}{2} (e^{i\frac{2 \pi}{64} 4n} e^{-i \frac{\pi}{2}}
    + e^{i\frac{2 \pi}{64} 60n} e^{i\frac{pi}{2}}) \\ &= \frac{1}{2} (e^{-i \frac{\pi}{2}}
    \mathbf{w}^{4n}_N + e^{i \frac{\pi}{2}} \mathbf{w}^{60n}_N) \end{aligned} \]
- en: 'Again, we have non-zero coefficients only for frequencies \(4\) and \(60\).
    But they are complex now, and both coefficients are no longer identical. Instead,
    one is the complex conjugate of the other. First, \(X_4\):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '再次，我们只有对于频率 \(4\) 和 \(60\) 有非零系数。但现在它们是复数，并且两个系数不再相同。相反，一个是另一个的复共轭。首先，\(X_4\):'
- en: \[ \begin{aligned} X_4 &= \langle \mathbf{w}^{4n}_N, \mathbf{x}_n \rangle \\
    &=\langle \mathbf{w}^{4n}_N, \frac{1}{2} (e^{-i \frac{\pi}{2}} \mathbf{w}^{4n}_N
    + e^{i \frac{\pi}{2}} \mathbf{w}^{60n}_N) \rangle\\ &= 32 *e^{-i \frac{\pi}{2}}
    \\ &= -32i \end{aligned} \]
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{aligned} X_4 &= \langle \mathbf{w}^{4n}_N, \mathbf{x}_n \rangle \\
    &=\langle \mathbf{w}^{4n}_N, \frac{1}{2} (e^{-i \frac{\pi}{2}} \mathbf{w}^{4n}_N
    + e^{i \frac{\pi}{2}} \mathbf{w}^{60n}_N) \rangle\\ &= 32 *e^{-i \frac{\pi}{2}}
    \\ &= -32i \end{aligned} \]
- en: 'And here, \(X_{60}\):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '这里是 \(X_{60}\):'
- en: \[ \begin{aligned} X_{60} &= \langle \mathbf{w}^{60n}_N, \mathbf{x}_N \rangle
    \\ &= 32 *e^{i \frac{\pi}{2}} \\ &= 32i \end{aligned} \]
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{aligned} X_{60} &= \langle \mathbf{w}^{60n}_N, \mathbf{x}_N \rangle
    \\ &= 32 *e^{i \frac{\pi}{2}} \\ &= 32i \end{aligned} \]
- en: As usual, we check our calculation using `torch_fft_fft()` ([fig. 26.6](#fig-dft-cos-phase-pi12)).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们使用 `torch_fft_fft()` 函数（[图 26.6](#fig-dft-cos-phase-pi12)）来检查我们的计算。
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*![Top row: A sine function, going through y=1 four times. Middle row: Left:
    Real part. All y=0\. Right: Imaginary part. y=-32 at x=4, y=32 at x=60\. Bottom
    row: Left: Magnitude. y=32 at x=4\. Right: Phase. y=pi/2 at x=4 and x=60.](../Images/de6e76a53ea243729c0f0d872e58904a.png)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*![顶部行：一个正弦函数，通过 y=1 四次。中间行：左：实部。所有 y=0。右：虚部。y=-32 在 x=4，y=32 在 x=60。底部行：左：幅度。y=32
    在 x=4。右：相位。y=pi/2 在 x=4 和 x=60。](../Images/de6e76a53ea243729c0f0d872e58904a.png)'
- en: 'Figure 26.6: Delaying a pure cosine wave by \(\pi/2\) yields a pure sine wave.
    Now the real parts of all coefficients are zero; instead, non-zero imaginary values
    are appearing. The phase shift at those positions is \(\pi/2\).'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 26.6：将纯余弦波延迟 \(\pi/2\) 得到纯正弦波。现在所有系数的实部都是零；相反，出现非零的虚数值。在这些位置上的相移是 \(\pi/2\)。
- en: For a pure sine wave, the non-zero Fourier coefficients are imaginary. The phase
    shift in the coefficients, reported as \(\frac{\pi}{2}\), reflects the time delay
    we applied to the signal.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个纯正弦波，非零傅里叶系数是虚数。系数中的相移，报告为 \(\frac{\pi}{2}\)，反映了我们对信号应用的时间延迟。
- en: Finally – before we write some code – let’s put it all together, and look at
    a wave that has more than a single sinusoidal component.*  *### 26.1.6 Superposition
    of sinusoids
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后——在我们编写代码之前——让我们将所有内容整合起来，看看一个具有多个正弦分量的波形。*  *### 26.1.6 正弦波的叠加
- en: 'The signal we construct may still be expressed in terms of the basis vectors,
    but it is no longer a pure sinusoid. Instead, it is a linear combination of such:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建的信号仍然可以用基向量表示，但它不再是纯正弦波。相反，它是由这样的线性组合：
- en: \[ \begin{aligned} \mathbf{x}_n &= 3 sin(\frac{2 \pi}{64} 4n) + 6 cos(\frac{2
    \pi}{64} 2n) +2cos(\frac{2 \pi}{64} 8n) \end{aligned} \]
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \begin{aligned} \mathbf{x}_n &= 3 \sin\left(\frac{2 \pi}{64} \cdot 4n\right)
    + 6 \cos\left(\frac{2 \pi}{64} \cdot 2n\right) + 2 \cos\left(\frac{2 \pi}{64}
    \cdot 8n\right) \end{aligned} \]
- en: 'I won’t go through the calculation in detail, but it is no different from the
    previous ones. You compute the DFT for each of the three components, and assemble
    the results. Without any calculation, however, there’s quite a few things we can
    say:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会详细讲解计算过程，但它与之前的计算没有区别。您为每个三个分量计算DFT，并将结果组装起来。然而，不进行任何计算，我们也可以说很多：
- en: Since the signal consists of two pure cosines and one pure sine, there will
    be four coefficients with non-zero real parts, and two with non-zero imaginary
    parts. The latter will be complex conjugates of each other.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于信号由两个纯余弦和一个纯正弦组成，将会有四个非零实部系数，以及两个非零虚部系数。后者将是彼此的复共轭。
- en: 'From the way the signal is written, it is easy to locate the respective frequencies,
    as well: The all-real coefficients will correspond to frequency indices 2, 8,
    56, and 62; the all-imaginary ones to indices 4 and 60.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从信号写法来看，很容易找到相应的频率：所有实系数将对应于频率索引2、8、56和62；所有虚系数将对应于索引4和60。
- en: Finally, amplitudes will result from multiplying with \(\frac{64}{2}\) the scaling
    factors obtained for the individual sinusoids.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，幅度将通过将单个正弦波获得的缩放因子乘以 \(\frac{64}{2}\) 来得到。
- en: 'Let’s check ([fig. 26.7](#fig-dft-mix-of-sinuisoids)):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 ([图26.7](#fig-dft-mix-of-sinuisoids))：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*![Top row: A function that is a composition of sinusoids. Middle row: Left:
    Real part. Non-zero at 2, 8, 56, and 62\. Right: Imaginary part. Non-zero at 4
    and 60\. Bottom row: Left: Magnitude. Non-zero at 2, 4, 8, 56, 60, and 62\. Right:
    Phase. Non-zero at 4 and 60.](../Images/0b0b19165c539963ff91cd71e3987af9.png)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*![顶部行：由正弦波组成的函数。中间行：左：实部。在2、8、56和62处非零。右：虚部。在4和60处非零。底部行：左：幅度。在2、4、8、56、60和62处非零。右：相位。在4和60处非零。](../Images/0b0b19165c539963ff91cd71e3987af9.png)'
- en: 'Figure 26.7: Superposition of pure sinusoids, and its DFT.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图26.7：纯正弦波的叠加及其DFT。
- en: Now, how do we calculate the DFT for less convenient signals?********  ***##
    26.2 Coding the DFT
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们如何计算不便于处理的信号的DFT？********  ***## 26.2 编码DFT
- en: 'Fortunately, we already know what has to be done. We want to project the signal
    onto each of the basis vectors. In other words, we’ll be computing a bunch of
    inner products. Logic-wise, nothing changes: The only difference is that in general,
    it will not be possible to represent the signal in terms of just a few basis vectors,
    like we did before. Thus, all projections will actually have to be calculated.
    But isn’t automation of tedious tasks one thing we have computers for?'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们已经知道该做什么。我们想要将信号投影到每个基向量上。换句话说，我们将计算一系列内积。从逻辑上讲，没有什么变化：唯一的区别是，通常，我们无法像之前那样只用几个基向量来表示信号。因此，实际上必须计算所有投影。但自动化繁琐的任务不是我们使用计算机的原因之一吗？
- en: 'Let’s start by stating input, output, and central logic of the algorithm to
    be implemented. As throughout this chapter, we stay in a single dimension. The
    input, thus, is a one-dimensional tensor, encoding a signal. The output is a one-dimensional
    vector of Fourier coefficients, of the same length as the input, each holding
    information about a frequency. The central idea is: To obtain a coefficient, project
    the signal onto the corresponding basis vector.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先说明要实现的算法的输入、输出和核心逻辑。正如本章所述，我们保持在一个维度内。因此，输入是一个一维张量，编码一个信号。输出是一个与输入长度相同的一维傅里叶系数向量，每个系数都包含有关一个频率的信息。核心思想是：为了获得一个系数，将信号投影到相应的基向量上。
- en: 'To implement that idea, we need to create the basis vectors, and for each one,
    compute its inner product with the signal. This can be done in a loop. Surprisingly
    little code is required to accomplish the goal:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个想法，我们需要创建基向量，并对每个基向量计算其与信号的点积。这可以通过循环完成。令人惊讶的是，完成这个目标所需的代码非常少：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*To test the implementation, we can take the last signal we analysed, and compare
    with the output of `torch_fft_fft()`.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了测试实现，我们可以取我们最后分析的信号，并与 `torch_fft_fft()` 的输出进行比较。'
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE19]'
- en: Reassuringly – if you look back – the results are the same.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 令人放心的是——如果你回顾一下——结果是一样的。
- en: 'Above, did I say “little code”? In fact, a loop is not even needed. Instead
    of working with the basis vectors one-by-one, we can stack them in a matrix. Then
    each row will hold the conjugate of a basis vector, and there will be \(N\) of
    them. The columns correspond to positions \(0\) to \(N-1\); there will be \(N\)
    of them as well. For example, this is how the matrix would look for \(N=4\):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 上文，我说“少量代码”吗？事实上，甚至不需要循环。我们不是逐个处理基向量，而是可以将它们堆叠成一个矩阵。然后每一行将持有基向量的共轭，将有 \(N\)
    个。列对应于位置 \(0\) 到 \(N-1\)；也会有 \(N\) 个。例如，这是 \(N=4\) 时矩阵的形状：
- en: \[ \mathbf{W}_4 = \begin{bmatrix} e^{-i\frac{2 \pi}{4}* 0 * 0} & e^{-i\frac{2
    \pi}{4}* 0 * 1} & e^{-i\frac{2 \pi}{4}* 0 * 2} & e^{-i\frac{2 \pi}{4}* 0 * 3}\\
    e^{-i\frac{2 \pi}{4}* 1 * 0} & e^{-i\frac{2 \pi}{4}* 1 * 1} & e^{-i\frac{2 \pi}{4}*
    1 * 2} & e^{-i\frac{2 \pi}{4}* 1 * 3}\\ e^{-i\frac{2 \pi}{4}* 2 * 0} & e^{-i\frac{2
    \pi}{4}* 2 * 1} & e^{-i\frac{2 \pi}{4}* 2 * 2} & e^{-i\frac{2 \pi}{4}* 2 * 3}\\
    e^{-i\frac{2 \pi}{4}* 3 * 0} & e^{-i\frac{2 \pi}{4}* 3 * 1} & e^{-i\frac{2 \pi}{4}*
    3 * 2} & e^{-i\frac{2 \pi}{4}* 3 * 3}\\ \end{bmatrix} \tag{26.3}\]
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \mathbf{W}_4 = \begin{bmatrix} e^{-i\frac{2 \pi}{4}* 0 * 0} & e^{-i\frac{2
    \pi}{4}* 0 * 1} & e^{-i\frac{2 \pi}{4}* 0 * 2} & e^{-i\frac{2 \pi}{4}* 0 * 3}\\
    e^{-i\frac{2 \pi}{4}* 1 * 0} & e^{-i\frac{2 \pi}{4}* 1 * 1} & e^{-i\frac{2 \pi}{4}*
    1 * 2} & e^{-i\frac{2 \pi}{4}* 1 * 3}\\ e^{-i\frac{2 \pi}{4}* 2 * 0} & e^{-i\frac{2
    \pi}{4}* 2 * 1} & e^{-i\frac{2 \pi}{4}* 2 * 2} & e^{-i\frac{2 \pi}{4}* 2 * 3}\\
    e^{-i\frac{2 \pi}{4}* 3 * 0} & e^{-i\frac{2 \pi}{4}* 3 * 1} & e^{-i\frac{2 \pi}{4}*
    3 * 2} & e^{-i\frac{2 \pi}{4}* 3 * 3}\\ \end{bmatrix} \tag{26.3}\]
- en: 'Or, evaluating the expressions:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，评估表达式：
- en: \[ \mathbf{W}_4 = \begin{bmatrix} 1 & 1 & 1 & 1\\ 1 & -i & -1 & i\\ 1 & -1 &
    1 & -1\\ 1 & i & -1 & -i\\ \end{bmatrix} \]
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: \[ \mathbf{W}_4 = \begin{bmatrix} 1 & 1 & 1 & 1\\ 1 & -i & -1 & i\\ 1 & -1 &
    1 & -1\\ 1 & i & -1 & -i\\ \end{bmatrix} \]
- en: 'With that modification, the code looks a lot more elegant:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 经过那样的修改，代码看起来要优雅得多：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*As you can easily verify, the result is the same.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*正如你很容易验证的那样，结果是相同的。'
- en: Before we move on to the next chapter – and the Fast Fourier Transform – we
    should test our implementation on something more complex.***  ***## 26.3 Fun with
    `sox`
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一章——快速傅里叶变换——之前，我们应该在更复杂的东西上测试我们的实现。***
- en: '[`sox`](http://sox.sourceforge.net/) is a command line tool for processing
    audio, most often (I guess) used to quickly play some sound file, for resampling,
    or to convert between different file formats. However, it can *generate* sound,
    as well! (Admittedly, the syntax is not the most intuitive.) Here is the command
    I used in generating the test sound analysed below:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sox`](http://sox.sourceforge.net/) 是一个用于处理音频的命令行工具，通常（我想）用于快速播放某些声音文件、重采样或在不同文件格式之间转换。然而，它也可以**生成**声音！（诚然，语法不是最直观的。）以下是我在生成下面分析的测试声音时使用的命令：'
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*The result is a concatenation of three distinct sound events, of duration
    `0.2` seconds, separated by slightly shorter periods of silence (`pad 0.15 0.15`).
    Each sound event is a superposition of three components: two sine waves of different
    frequency, and pink noise. The frequency combinations used are not accidental:
    They represent the encoding of the numbers 0, 8, and 9 in the [Dual-tone multi-frequency
    signaling (DTMF)](https://en.wikipedia.org/wiki/Dual-tone_multi-frequency_signaling)
    system, respectively.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*结果是三个不同的声音事件的拼接，持续时间为 `0.2` 秒，由稍微短一点的静默期（`pad 0.15 0.15`）分隔。每个声音事件是三个成分的叠加：两个不同频率的正弦波和粉红噪声。使用的频率组合并非偶然：它们分别代表了
    [双音多频信号（DTMF）](https://en.wikipedia.org/wiki/Dual-tone_multi-frequency_signaling)
    系统中数字 0、8 和 9 的编码。'
- en: For this signal, what would we expect to see in a spectrogram? We expect to
    see three distinct phases, clearly separated by “nothing”, that each show two
    dominant frequencies. The first and the second should have one frequency in common;
    the same holds for phases two and three. In addition, for all three phases, we
    should see contributions from all other frequencies, with lower frequencies having
    stronger impact than higher ones. (That’s what defines pink noise.)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个信号，我们在频谱图中期望看到什么？我们期望看到三个明显区分的相位，每个相位都由“无”清晰分隔，并且每个相位都显示两个主要频率。第一和第二个相位应该有一个共同的频率；第二和第三个相位也是如此。此外，对于所有三个相位，我们都应该看到来自所有其他频率的贡献，低频比高频有更强的冲击。（这就是粉红噪声的定义。）
- en: 'At this point, allow me to call `sox` one last time. If you’ve been using that
    program before, did you know that it can create spectrograms? This one-liner uses
    all the default settings; yet the result has all the information we want ([fig. 26.8](#fig-dft-spectrogram)):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，让我再次调用`sox`。如果你之前使用过这个程序，你知道它可以创建声谱图吗？这个单行命令使用了所有默认设置；然而，结果包含了我们想要的所有信息（[图26.8](#fig-dft-spectrogram)）：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*![Spectrogram. There are three distinct phases. In each phase, two Fourier
    coefficients clearly dominate.](../Images/f8957255996ddd0bb4880581113f055e.png)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*![声谱图。有三个不同的阶段。在每个阶段，两个傅里叶系数明显占主导地位。](../Images/f8957255996ddd0bb4880581113f055e.png)'
- en: 'Figure 26.8: Spectrogram, created by `sox resources/dial.wav -n spectrogram
    -m -l -w kaiser -o dial-spectrogram.png`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图26.8：使用`sox resources/dial.wav -n spectrogram -m -l -w kaiser -o dial-spectrogram.png`创建的声谱图。
- en: Now, let’s load this file into R, making use of `torchaudio`, a package we already
    know from the audio classification chapter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们利用`torchaudio`这个包将文件加载到R中，我们在音频分类章节中已经了解过这个包。
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE24]'
- en: From all the information stored in `tuneR`’s `WaveMC` object, we need just the
    sampling rate and the data itself.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从`tuneR`的`WaveMC`对象存储的所有信息中，我们只需要采样率和数据本身。
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE26]'
- en: 'As expected, a plot of amplitude over time does not reveal too much ([fig. 26.9](#fig-dft-dial-waveform)):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，幅度随时间变化的图表并没有揭示太多（[图26.9](#fig-dft-dial-waveform)）：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*![Three sound waves, clearly separated.](../Images/429c0d8898dcd23eec17140b7041e01c.png)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*![三个清晰分离的声音波。](../Images/429c0d8898dcd23eec17140b7041e01c.png)'
- en: 'Figure 26.9: Three consecutive ringtones, time domain representation.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图26.9：三个连续的铃声，时域表示。
- en: Now, we will compute the Fourier Transform – twice. First, with `torch_fft_fft()`,
    so we know the “truth”. Then, using our own `dft()`. For both, we will display
    the magnitudes of the lower half of the spectrum, that is, all frequencies up
    to the Nyquist rate. Finally, with help of `torch_fft_ifft()`, we will make sure
    we can regenerate the time domain representation from what `dft()` gave us.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将计算傅里叶变换——两次。首先，使用`torch_fft_fft()`，这样我们知道“真相”。然后，使用我们自己的`dft()`函数。对于两者，我们将显示频谱下半部分的幅度，即所有频率直到奈奎斯特率。最后，借助`torch_fft_ifft()`，我们将确保可以从`dft()`给出的结果中重新生成时域表示。
- en: 'In order to create a meaningful plot, there’s one additional step to be taken.
    So far, the magnitudes displayed in the frequency-domain plots have simply been
    ordered by \(k\), the index of the basis vector in question. In fact, there was
    no concept of a *real-world frequency*. But now, we want to see frequencies treated
    the way we conceptualize them: as number of cycles per second, measured in Hertz.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个有意义的图表，还需要进行一个额外的步骤。到目前为止，在频域图表中显示的幅度只是简单地按\(k\)排序，即相关基向量索引。实际上，没有“实际频率”的概念。但现在，我们希望看到频率以我们概念化的方式处理：每秒周期数，以赫兹为单位。
- en: 'To be able to do the conversion, we need the sampling rate, which we already
    saw is 4000 Hertz. We then map the lower-half sample indices (`bins_below_nyquist`)
    to real-world frequencies, multiplying by the ratio of sampling rate to overall
    number of samples:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行转换，我们需要采样率，这我们已经看到是4000赫兹。然后，我们将下半部分的样本索引（`bins_below_nyquist`）映射到实际频率，乘以采样率与总样本数的比率：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Here, then, is the magnitude plot for `torch_fft_fft()` ([fig. 26.10](#fig-dft-dial-fft)):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*这里，然后，是`torch_fft_fft()`函数的幅度图（[图26.10](#fig-dft-dial-fft)）：'
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*![Magnitudes of Fourier coefficients. No magnitude is zero. There are four
    peaks, all centers of bell-shaped curves.](../Images/ece3b008ec257e571547752920e22607.png)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*![傅里叶系数的幅度。没有幅度为零。有四个峰值，都是钟形曲线的中心。](../Images/ece3b008ec257e571547752920e22607.png)'
- en: 'Figure 26.10: DFT of the ringtone signal, computed by means of `torch_fft_fft()`
    . Displayed are the magnitudes of frequencies below the Nyquist rate.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图26.10：使用`torch_fft_fft()`计算的铃声信号的DFT。显示的是低于奈奎斯特率的频率幅度。
- en: The spectrum reflects the noise component in the signal, but the four peaks
    (which we know to be located at 852, 941, 1336, and 1477 Hertz) are clearly visible.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 频谱反映了信号中的噪声成分，但四个峰值（我们知道它们位于852、941、1336和1477赫兹）清晰可见。
- en: Now, does our hand-written code yield the same result ([fig. 26.11](#fig-dft-dial-dft))?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们手写的代码是否得到相同的结果（[图26.11](#fig-dft-dial-dft)）？
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*![Magnitudes of Fourier coefficients. No magnitude is zero. There are four
    peaks, all centers of bell-shaped curves.](../Images/e6fe22ecc3e87be545db89e5c5971a32.png)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*![傅里叶系数的幅度。没有幅度为零。有四个峰值，都是钟形曲线的中心。](../Images/e6fe22ecc3e87be545db89e5c5971a32.png)'
- en: 'Figure 26.11: DFT of the ringtone signal, using our hand-written code. Displayed
    are the magnitudes of frequencies below the Nyquist rate.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图26.11：使用我们编写的代码对铃声信号进行DFT。显示的是低于奈奎斯特频率的频率幅度。
- en: It does. Finally, let’s use the Inverse DFT to recreate the signal ([fig. 26.12](#fig-dft-dial-ifft)).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 确实如此。最后，让我们使用逆DFT来重建信号（[图26.12](#fig-dft-dial-ifft)）。
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*![Three sound waves, clearly separated.](../Images/e4a29e3cfc0af8ff174f9c121f608ff6.png)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*![三个清晰分离的声波](../Images/e4a29e3cfc0af8ff174f9c121f608ff6.png)'
- en: 'Figure 26.12: Reconstruction of the time domain signal from the output of `dft()`.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图26.12：从 `dft()` 输出重建时域信号。
- en: And there we are. We’ve implemented the DFT ourselves, and learned quite a bit
    on our way. For the Fast Fourier Transform, the topic of the next chapter, the
    plan is exactly the same.*********  **** * *
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们已经自己实现了DFT，并且在过程中学到了很多。对于下一章的主题快速傅里叶变换（FFT），计划完全相同。*********  **** * *
- en: Its counterpart – that takes the Fourier representation and yields a time-domain
    signal – is called `torch_fft_ifft()` (with `ifft` standing for *Inverse Fourier
    Transform*).[↩︎](#fnref1)
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它的对应函数——它将傅里叶表示转换为时域信号——被称为 `torch_fft_ifft()`（其中 `ifft` 代表 *逆傅里叶变换*）。[↩︎](#fnref1)
- en: 'Expanding on this a bit: For real-valued signals, the magnitudes as well as
    the real parts of corresponding coefficients are equal, while the phases and the
    imaginary parts are conjugated. In other words, the coefficients are complex conjugates
    of each other. We’ll see this in later examples.[↩︎](#fnref2)'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此基础上进一步说明：对于实值信号，对应系数的幅度以及实部是相等的，而相位和虚部是共轭的。换句话说，系数是彼此的复共轭。我们将在后面的例子中看到这一点。[↩︎](#fnref2)
- en: I’ll be writing \(\mathbf{x}_n\) instead of \(f(x)\) from now on to indicate
    that we’re working with discrete samples, not the continuous function itself.[↩︎](#fnref3)
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从现在起，我将用 \(\mathbf{x}_n\) 代替 \(f(x)\) 来表示我们正在处理离散样本，而不是连续函数本身。[↩︎](#fnref3)
- en: Euler’s formula relates complex exponentials to sines and cosines, stating that
    \(e^{i \theta} = cos \theta + i sin \theta\).[↩︎](#fnref4)*********
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 欧拉公式将复指数与正弦和余弦函数联系起来，表明 \(e^{i \theta} = cos \theta + i sin \theta\。[↩︎](#fnref4)*********

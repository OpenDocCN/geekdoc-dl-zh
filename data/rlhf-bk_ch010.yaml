- en: Rejection Sampling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ‹’ç»é‡‡æ ·
- en: Rejection Sampling (RS) is a popular and simple baseline for performing preference
    fine-tuning. This makes it one of a handful of methods that are used after a first
    round of instruction tuning in order to further refine the model to human preferences.
    Rejection sampling operates by curating new candidate completions, filtering them
    based on a trained reward model, and then instruction finetuning the original
    model only on the top completions (same loss function as when doing a dedicated
    training stage for learning to follow instructions).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: æ‹’ç»é‡‡æ · (RS) æ˜¯è¿›è¡Œåå¥½å¾®è°ƒçš„ä¸€ä¸ªæµè¡Œä¸”ç®€å•çš„åŸºç¡€çº¿ã€‚è¿™ä½¿å¾—å®ƒæˆä¸ºåœ¨ç¬¬ä¸€è½®æŒ‡ä»¤å¾®è°ƒä¹‹åç”¨äºè¿›ä¸€æ­¥ç»†åŒ–æ¨¡å‹ä»¥ç¬¦åˆäººç±»åå¥½çš„å°‘æ•°å‡ ç§æ–¹æ³•ä¹‹ä¸€ã€‚æ‹’ç»é‡‡æ ·é€šè¿‡ç²¾å¿ƒæŒ‘é€‰æ–°çš„å€™é€‰å®Œæˆï¼Œæ ¹æ®è®­ç»ƒå¥½çš„å¥–åŠ±æ¨¡å‹è¿›è¡Œè¿‡æ»¤ï¼Œç„¶åä»…åœ¨é¡¶éƒ¨å®Œæˆä¸Šè¿›è¡ŒæŒ‡ä»¤å¾®è°ƒï¼ˆä¸ä¸ºå­¦ä¹ éµå¾ªæŒ‡ä»¤è€Œè¿›è¡Œçš„ä¸“ç”¨è®­ç»ƒé˜¶æ®µç›¸åŒçš„æŸå¤±å‡½æ•°ï¼‰ã€‚
- en: The name originates from computational statistics [[175]](ch021.xhtml#ref-gilks1992adaptive),
    where one wishes to sample from a complex distribution, but does not have a direct
    method to do so. To alleviate this, one samples from a simpler distribution to
    model and uses a heuristic to check if the sample is permissible. With language
    models, the target distribution is high-quality completions to prompts, the filter
    is a reward model, and the sampling distribution is the current model.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªåå­—èµ·æºäºè®¡ç®—ç»Ÿè®¡å­¦ [[175]](ch021.xhtml#ref-gilks1992adaptive)ï¼Œåœ¨é‚£é‡Œï¼Œäººä»¬å¸Œæœ›ä»ä¸€ä¸ªå¤æ‚çš„åˆ†å¸ƒä¸­è¿›è¡Œé‡‡æ ·ï¼Œä½†æ²¡æœ‰ç›´æ¥çš„æ–¹æ³•æ¥åšè¿™ä»¶äº‹ã€‚ä¸ºäº†ç¼“è§£è¿™ä¸ªé—®é¢˜ï¼Œäººä»¬ä»æ›´ç®€å•çš„åˆ†å¸ƒä¸­è¿›è¡Œé‡‡æ ·æ¥å»ºæ¨¡ï¼Œå¹¶ä½¿ç”¨å¯å‘å¼æ–¹æ³•æ¥æ£€æŸ¥æ ·æœ¬æ˜¯å¦å¯æ¥å—ã€‚åœ¨è¯­è¨€æ¨¡å‹ä¸­ï¼Œç›®æ ‡åˆ†å¸ƒæ˜¯å¯¹æç¤ºçš„é«˜è´¨é‡å®Œæˆï¼Œè¿‡æ»¤å™¨æ˜¯ä¸€ä¸ªå¥–åŠ±æ¨¡å‹ï¼Œé‡‡æ ·åˆ†å¸ƒæ˜¯å½“å‰æ¨¡å‹ã€‚
- en: Many prominent RLHF and preference fine-tuning papers have used rejection sampling
    as a baseline, but a canonical implementation and documentation does not exist.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: è®¸å¤šè‘—åçš„RLHFå’Œåå¥½å¾®è°ƒè®ºæ–‡éƒ½ä½¿ç”¨äº†æ‹’ç»é‡‡æ ·ä½œä¸ºåŸºçº¿ï¼Œä½†å¹¶æ²¡æœ‰ä¸€ä¸ªæ ‡å‡†çš„å®ç°å’Œæ–‡æ¡£ã€‚
- en: WebGPT [[4]](ch021.xhtml#ref-nakano2021webgpt), Anthropicâ€™s Helpful and Harmless
    agent [[5]](ch021.xhtml#ref-bai2022training), OpenAIâ€™s popular paper on process
    reward models [[45]](ch021.xhtml#ref-lightman2023let), Llama 2 Chat models [[44]](ch021.xhtml#ref-touvron2023llama),
    and other seminal works all use this baseline; more recent work has formalized
    it directly (e.g., RAFT [[176]](ch021.xhtml#ref-dong2023raft) for applying it
    to alignment in multiple modalities and Statistical Rejection Sampling Optimization
    (RSO) [[177]](ch021.xhtml#ref-liu2023statistical) that gives a principled overview
    on how rejection sampling relates to other preference learning objectives).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: WebGPT [[4]](ch021.xhtml#ref-nakano2021webgpt)ï¼ŒAnthropicçš„æœ‰ç›Šæ— å®³ä»£ç† [[5]](ch021.xhtml#ref-bai2022training)ï¼ŒOpenAIå…³äºè¿‡ç¨‹å¥–åŠ±æ¨¡å‹çš„æµè¡Œè®ºæ–‡
    [[45]](ch021.xhtml#ref-lightman2023let)ï¼ŒLlama 2 Chatæ¨¡å‹ [[44]](ch021.xhtml#ref-touvron2023llama)ï¼Œä»¥åŠå…¶ä»–å¼€åˆ›æ€§å·¥ä½œéƒ½ä½¿ç”¨äº†è¿™ä¸ªåŸºçº¿ï¼›æ›´è¿‘æœŸçš„ä½œå“ç›´æ¥å¯¹å…¶è¿›è¡Œäº†å½¢å¼åŒ–ï¼ˆä¾‹å¦‚ï¼ŒRAFT
    [[176]](ch021.xhtml#ref-dong2023raft) ç”¨äºå°†å…¶åº”ç”¨äºå¤šæ¨¡æ€çš„å¯¹é½ï¼Œä»¥åŠç»Ÿè®¡æ‹’ç»é‡‡æ ·ä¼˜åŒ– (RSO) [[177]](ch021.xhtml#ref-liu2023statistical)ï¼Œå®ƒæä¾›äº†ä¸€ä¸ªå…³äºæ‹’ç»é‡‡æ ·å¦‚ä½•ä¸å…¶ä»–åå¥½å­¦ä¹ ç›®æ ‡ç›¸å…³è”çš„åŸç†æ€§æ¦‚è¿°ï¼‰ã€‚
- en: '*Throughout this chapter, we use <semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics>
    to denote prompts and <semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics>
    to denote completions. This notation is common in the language model literature,
    where methods operate on full prompt-completion pairs rather than individual tokens.*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*åœ¨æœ¬ç« ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨ <semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics>
    æ¥è¡¨ç¤ºæç¤ºï¼Œä½¿ç”¨ <semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics>
    æ¥è¡¨ç¤ºå®Œæˆã€‚è¿™ç§ç¬¦å·åœ¨è¯­è¨€æ¨¡å‹æ–‡çŒ®ä¸­å¾ˆå¸¸è§ï¼Œå…¶ä¸­æ–¹æ³•æ“ä½œçš„æ˜¯å®Œæ•´çš„æç¤º-å®Œæˆå¯¹ï¼Œè€Œä¸æ˜¯å•ä¸ªæ ‡è®°ã€‚*'
- en: Training Process
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è®­ç»ƒè¿‡ç¨‹
- en: Rejection sampling overall follows a few stages.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: æ‹’ç»é‡‡æ ·æ€»ä½“ä¸Šéµå¾ªå‡ ä¸ªé˜¶æ®µã€‚
- en: '**Prompt and reward model selection:** First, you must select the prompts you
    want to train on, relative to other stages of training. The simplest method is
    to re-use every prompt from the first SFT/IFT stage, but this can cause some overfitting.
    Before doing rejection sampling, you must also have trained a reward model (see
    Chapter 7 for more information).'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**æç¤ºå’Œå¥–åŠ±æ¨¡å‹é€‰æ‹©ï¼š** é¦–å…ˆï¼Œä½ å¿…é¡»é€‰æ‹©ä½ æƒ³è¦åœ¨è®­ç»ƒä¸­ä½¿ç”¨çš„æç¤ºï¼Œç›¸å¯¹äºè®­ç»ƒçš„å…¶ä»–é˜¶æ®µã€‚æœ€ç®€å•çš„æ–¹æ³•æ˜¯é‡ç”¨ç¬¬ä¸€è½®SFT/IFTé˜¶æ®µçš„æ¯ä¸ªæç¤ºï¼Œä½†è¿™å¯èƒ½ä¼šå¯¼è‡´ä¸€äº›è¿‡æ‹Ÿåˆã€‚åœ¨è¿›è¡Œæ‹’ç»é‡‡æ ·ä¹‹å‰ï¼Œä½ è¿˜å¿…é¡»å·²ç»è®­ç»ƒäº†ä¸€ä¸ªå¥–åŠ±æ¨¡å‹ï¼ˆæ›´å¤šä¿¡æ¯è¯·å‚é˜…ç¬¬7ç« ï¼‰ã€‚'
- en: '**Generate completions from the starting checkpoint:** Next, one must generate
    completions to the selected prompts with the model they want to optimize. This
    can involve tweaking many settings, such as sampling temperature, top-p, max sequence
    length, number of completions per prompt, etc.'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ä»èµ·å§‹æ£€æŸ¥ç‚¹ç”Ÿæˆå®Œæˆå†…å®¹**ï¼šæ¥ä¸‹æ¥ï¼Œå¿…é¡»ä½¿ç”¨ä»–ä»¬æƒ³è¦ä¼˜åŒ–çš„æ¨¡å‹ç”Ÿæˆæ‰€é€‰æç¤ºçš„å®Œæˆå†…å®¹ã€‚è¿™å¯èƒ½æ¶‰åŠè°ƒæ•´è®¸å¤šè®¾ç½®ï¼Œä¾‹å¦‚é‡‡æ ·æ¸©åº¦ã€top-pã€æœ€å¤§åºåˆ—é•¿åº¦ã€æ¯ä¸ªæç¤ºçš„å®Œæˆæ•°é‡ç­‰ã€‚'
- en: '**Select top completions with a reward model**: All completions are ranked
    by a reward model. This can include deduplication to only have one prompt per
    completion after this stage, or not, as a lot of the decisions become based on
    empirical ablation studies.'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ä½¿ç”¨å¥–åŠ±æ¨¡å‹é€‰æ‹©é¡¶çº§å®Œæˆ**ï¼šæ‰€æœ‰å®Œæˆå†…å®¹éƒ½é€šè¿‡å¥–åŠ±æ¨¡å‹è¿›è¡Œæ’åã€‚è¿™å¯ä»¥åŒ…æ‹¬å»é‡ï¼Œä»¥ä¾¿åœ¨è¿™ä¸€ç‚¹ä¹‹åæ¯ä¸ªå®Œæˆå†…å®¹åªæœ‰ä¸€ä¸ªæç¤ºï¼Œæˆ–è€…ä¸è¿›è¡Œå»é‡ï¼Œå› ä¸ºè®¸å¤šå†³ç­–éƒ½åŸºäºç»éªŒæ¶ˆé™¤ç ”ç©¶ã€‚'
- en: '**SFT on top completions:** To finish rejection sampling, one instruction finetunes
    the starting checkpoint on the selected completions.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**åœ¨é¡¶çº§å®Œæˆä¸Šè¿›è¡ŒSFT**ï¼šä¸ºäº†å®Œæˆæ‹’ç»é‡‡æ ·ï¼Œä¸€æ¡æŒ‡ä»¤å¯¹æ‰€é€‰çš„å®Œæˆå†…å®¹ä¸Šçš„èµ·å§‹æ£€æŸ¥ç‚¹è¿›è¡Œå¾®è°ƒã€‚'
- en: A visual overview of the rejection sampling process is included below in fig.Â [14](#fig:rs-overview).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: æ‹’ç»é‡‡æ ·è¿‡ç¨‹çš„è§†è§‰æ¦‚è¿°å¦‚ä¸‹ï¼Œè§å›¾[14](#fig:rs-overview)ã€‚
- en: '![Figure 14: Rejection sampling overview.](../media/file12.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![å›¾14ï¼šæ‹’ç»é‡‡æ ·æ¦‚è¿°ã€‚](../media/file12.png)'
- en: 'Figure 14: Rejection sampling overview.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾14ï¼šæ‹’ç»é‡‡æ ·æ¦‚è¿°ã€‚
- en: The actual details on which prompts to use, how to select a reward model, how
    to sequence rejection sampling, etc. are not well documented in the literature.
    This chapter provides an overview of the methods and leaves further experimentation
    to the reader.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: å…³äºä½¿ç”¨å“ªäº›æç¤ºã€å¦‚ä½•é€‰æ‹©å¥–åŠ±æ¨¡å‹ã€å¦‚ä½•è¿›è¡Œæ‹’ç»é‡‡æ ·æ’åºç­‰å®é™…ç»†èŠ‚ï¼Œåœ¨æ–‡çŒ®ä¸­å¹¶æ²¡æœ‰å¾ˆå¥½åœ°è®°å½•ã€‚æœ¬ç« æä¾›äº†æ–¹æ³•æ¦‚è¿°ï¼Œå¹¶å°†è¿›ä¸€æ­¥çš„å®éªŒç•™ç»™è¯»è€…ã€‚
- en: 1\. Generating Completions
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1. ç”Ÿæˆå®Œæˆå†…å®¹
- en: 'To generate a set of multiple candidate completions per prompt, letâ€™s define
    a set of <semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics>
    prompts as a vector:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ä¸ºæ¯ä¸ªæç¤ºç”Ÿæˆä¸€ç»„å¤šä¸ªå€™é€‰å®Œæˆï¼Œè®©æˆ‘ä»¬å®šä¹‰ä¸€ç»„<semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics>æç¤ºä½œä¸ºä¸€ä¸ªå‘é‡ï¼š
- en: <semantics><mrow><mi>X</mi><mo>=</mo><mo stretchy="false" form="prefix">[</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>x</mi><mi>M</mi></msub><mo
    stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">X
    = [x_1, x_2, ..., x_M]</annotation></semantics>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <semantics><mrow><mi>X</mi><mo>=</mo><mo stretchy="false" form="prefix">[</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><msub><mi>x</mi><mn>2</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>x</mi><mi>M</mi></msub><mo
    stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">X
    = [x_1, x_2, ..., x_M]</annotation></semantics>
- en: These prompts can come from many sources, but most commonly they come from the
    instruction training set.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›æç¤ºå¯ä»¥æ¥è‡ªè®¸å¤šæ¥æºï¼Œä½†æœ€å¸¸è§çš„æ˜¯æ¥è‡ªæŒ‡ä»¤è®­ç»ƒé›†ã€‚
- en: 'For each prompt <semantics><msub><mi>x</mi><mi>i</mi></msub><annotation encoding="application/x-tex">x_i</annotation></semantics>,
    we generate <semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics>
    completions. We can represent this as a matrix:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæ¯ä¸ªæç¤º<semantics><msub><mi>x</mi><mi>i</mi></msub><annotation encoding="application/x-tex">x_i</annotation></semantics>ï¼Œæˆ‘ä»¬ç”Ÿæˆ<semantics><mi>N</mi><annotation
    encoding="application/x-tex">N</annotation></semantics>ä¸ªå®Œæˆã€‚æˆ‘ä»¬å¯ä»¥å°†è¿™è¡¨ç¤ºä¸ºä¸€ä¸ªçŸ©é˜µï¼š
- en: '<semantics><mrow><mi>Y</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd
    columnalign="center" style="text-align: center"><msub><mi>y</mi><mrow><mn>1</mn><mo>,</mo><mn>1</mn></mrow></msub></mtd><mtd
    columnalign="center" style="text-align: center"><msub><mi>y</mi><mrow><mn>1</mn><mo>,</mo><mn>2</mn></mrow></msub></mtd><mtd
    columnalign="center" style="text-align: center"><mi>â‹¯</mi></mtd><mtd columnalign="center"
    style="text-align: center"><msub><mi>y</mi><mrow><mn>1</mn><mo>,</mo><mi>N</mi></mrow></msub></mtd></mtr><mtr><mtd
    columnalign="center" style="text-align: center"><msub><mi>y</mi><mrow><mn>2</mn><mo>,</mo><mn>1</mn></mrow></msub></mtd><mtd
    columnalign="center" style="text-align: center"><msub><mi>y</mi><mrow><mn>2</mn><mo>,</mo><mn>2</mn></mrow></msub></mtd><mtd
    columnalign="center" style="text-align: center"><mi>â‹¯</mi></mtd><mtd columnalign="center"
    style="text-align: center"><msub><mi>y</mi><mrow><mn>2</mn><mo>,</mo><mi>N</mi></mrow></msub></mtd></mtr><mtr><mtd
    columnalign="center" style="text-align: center"><mi>â‹®</mi></mtd><mtd columnalign="center"
    style="text-align: center"><mi>â‹®</mi></mtd><mtd columnalign="center" style="text-align:
    center"><mo>â‹±</mo></mtd><mtd columnalign="center" style="text-align: center"><mi>â‹®</mi></mtd></mtr><mtr><mtd
    columnalign="center" style="text-align: center"><msub><mi>y</mi><mrow><mi>M</mi><mo>,</mo><mn>1</mn></mrow></msub></mtd><mtd
    columnalign="center" style="text-align: center"><msub><mi>y</mi><mrow><mi>M</mi><mo>,</mo><mn>2</mn></mrow></msub></mtd><mtd
    columnalign="center" style="text-align: center"><mi>â‹¯</mi></mtd><mtd columnalign="center"
    style="text-align: center"><msub><mi>y</mi><mrow><mi>M</mi><mo>,</mo><mi>N</mi></mrow></msub></mtd></mtr></mtable><mo
    stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">Y
    = \begin{bmatrix} y_{1,1} & y_{1,2} & \cdots & y_{1,N} \\ y_{2,1} & y_{2,2} &
    \cdots & y_{2,N} \\ \vdots & \vdots & \ddots & \vdots \\ y_{M,1} & y_{M,2} & \cdots
    & y_{M,N} \end{bmatrix}</annotation></semantics>'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: where <semantics><msub><mi>y</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><annotation
    encoding="application/x-tex">y_{i,j}</annotation></semantics> represents the <semantics><mi>j</mi><annotation
    encoding="application/x-tex">j</annotation></semantics>-th completion for the
    <semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics>-th
    prompt. Each row <semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics>
    corresponds to a single prompt <semantics><msub><mi>x</mi><mi>i</mi></msub><annotation
    encoding="application/x-tex">x_i</annotation></semantics> and contains its <semantics><mi>N</mi><annotation
    encoding="application/x-tex">N</annotation></semantics> candidate completions;
    each column <semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics>
    corresponds to the <semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics>-th
    sampled completion across all prompts.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­ <semantics><msub><mi>y</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><annotation
    encoding="application/x-tex">y_{i,j}</annotation></semantics> ä»£è¡¨ç¬¬ <semantics><mi>j</mi><annotation
    encoding="application/x-tex">j</annotation></semantics> ä¸ªå¯¹ç¬¬ <semantics><mi>i</mi><annotation
    encoding="application/x-tex">i</annotation></semantics> ä¸ªæç¤ºçš„å®Œæˆã€‚æ¯ä¸€è¡Œ <semantics><mi>i</mi><annotation
    encoding="application/x-tex">i</annotation></semantics> å¯¹åº”ä¸€ä¸ªå•ç‹¬çš„æç¤º <semantics><msub><mi>x</mi><mi>i</mi></msub><annotation
    encoding="application/x-tex">x_i</annotation></semantics>ï¼Œå¹¶åŒ…å«å…¶ <semantics><mi>N</mi><annotation
    encoding="application/x-tex">N</annotation></semantics> ä¸ªå€™é€‰å®Œæˆï¼›æ¯ä¸€åˆ— <semantics><mi>j</mi><annotation
    encoding="application/x-tex">j</annotation></semantics> å¯¹åº”æ‰€æœ‰æç¤ºä¸­çš„ç¬¬ <semantics><mi>j</mi><annotation
    encoding="application/x-tex">j</annotation></semantics> ä¸ªé‡‡æ ·å®Œæˆã€‚
- en: 2\. Scoring Completions
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2. è¯„åˆ†å®Œæˆ
- en: 'Now, we pass all of these prompt-completion pairs through a reward model, to
    get a matrix of rewards. Weâ€™ll represent the rewards as a matrix <semantics><mi>R</mi><annotation
    encoding="application/x-tex">R</annotation></semantics>:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬å°†æ‰€æœ‰è¿™äº›æç¤º-å®Œæˆå¯¹é€šè¿‡ä¸€ä¸ªå¥–åŠ±æ¨¡å‹ï¼Œä»¥è·å¾—ä¸€ä¸ªå¥–åŠ±çŸ©é˜µã€‚æˆ‘ä»¬å°†å¥–åŠ±è¡¨ç¤ºä¸ºä¸€ä¸ªçŸ©é˜µ <semantics><mi>R</mi><annotation
    encoding="application/x-tex">R</annotation></semantics>ï¼š
- en: '<semantics><mrow><mi>R</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd
    columnalign="center" style="text-align: center"><msub><mi>r</mi><mrow><mn>1</mn><mo>,</mo><mn>1</mn></mrow></msub></mtd><mtd
    columnalign="center" style="text-align: center"><msub><mi>r</mi><mrow><mn>1</mn><mo>,</mo><mn>2</mn></mrow></msub></mtd><mtd
    columnalign="center" style="text-align: center"><mi>â‹¯</mi></mtd><mtd columnalign="center"
    style="text-align: center"><msub><mi>r</mi><mrow><mn>1</mn><mo>,</mo><mi>N</mi></mrow></msub></mtd></mtr><mtr><mtd
    columnalign="center" style="text-align: center"><msub><mi>r</mi><mrow><mn>2</mn><mo>,</mo><mn>1</mn></mrow></msub></mtd><mtd
    columnalign="center" style="text-align: center"><msub><mi>r</mi><mrow><mn>2</mn><mo>,</mo><mn>2</mn></mrow></msub></mtd><mtd
    columnalign="center" style="text-align: center"><mi>â‹¯</mi></mtd><mtd columnalign="center"
    style="text-align: center"><msub><mi>r</mi><mrow><mn>2</mn><mo>,</mo><mi>N</mi></mrow></msub></mtd></mtr><mtr><mtd
    columnalign="center" style="text-align: center"><mi>â‹®</mi></mtd><mtd columnalign="center"
    style="text-align: center"><mi>â‹®</mi></mtd><mtd columnalign="center" style="text-align:
    center"><mo>â‹±</mo></mtd><mtd columnalign="center" style="text-align: center"><mi>â‹®</mi></mtd></mtr><mtr><mtd
    columnalign="center" style="text-align: center"><msub><mi>r</mi><mrow><mi>M</mi><mo>,</mo><mn>1</mn></mrow></msub></mtd><mtd
    columnalign="center" style="text-align: center"><msub><mi>r</mi><mrow><mi>M</mi><mo>,</mo><mn>2</mn></mrow></msub></mtd><mtd
    columnalign="center" style="text-align: center"><mi>â‹¯</mi></mtd><mtd columnalign="center"
    style="text-align: center"><msub><mi>r</mi><mrow><mi>M</mi><mo>,</mo><mi>N</mi></mrow></msub></mtd></mtr></mtable><mo
    stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">R
    = \begin{bmatrix} r_{1,1} & r_{1,2} & \cdots & r_{1,N} \\ r_{2,1} & r_{2,2} &
    \cdots & r_{2,N} \\ \vdots & \vdots & \ddots & \vdots \\ r_{M,1} & r_{M,2} & \cdots
    & r_{M,N} \end{bmatrix}</annotation></semantics>'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '<semantics><mrow><mi>R</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd
    columnalign="center" style="text-align: center"><msub><mi>r</mi><mrow><mn>1</mn><mo>,</mo><mn>1</mn></mrow></msub></mtd><mtd
    columnalign="center" style="text-align: center"><msub><mi>r</mi><mrow><mn>1</mn><mo>,</mo><mn>2</mn></mrow></msub></mtd><mtd
    columnalign="center" style="text-align: center"><mi>â‹¯</mi></mtd><mtd columnalign="center"
    style="text-align: center"><msub><mi>r</mi><mrow><mn>1</mn><mo>,</mo><mi>N</mi></mrow></msub></mtd></mtr><mtr><mtd
    columnalign="center" style="text-align: center"><msub><mi>r</mi><mrow><mn>2</mn><mo>,</mo><mn>1</mn></mrow></msub></mtd><mtd
    columnalign="center" style="text-align: center"><msub><mi>r</mi><mrow><mn>2</mn><mo>,</mo><mn>2</mn></mrow></msub></mtd><mtd
    columnalign="center" style="text-align: center"><mi>â‹¯</mi></mtd><mtd columnalign="center"
    style="text-align: center"><msub><mi>r</mi><mrow><mn>2</mn><mo>,</mo><mi>N</mi></mrow></msub></mtd></mtr><mtr><mtd
    columnalign="center" style="text-align: center"><mi>â‹®</mi></mtd><mtd columnalign="center"
    style="text-align: center"><mi>â‹®</mi></mtd><mtd columnalign="center" style="text-align:
    center"><mo>â‹±</mo></mtd><mtd columnalign="center" style="text-align: center"><mi>â‹®</mi></mtd></mtr><mtr><mtd
    columnalign="center" style="text-align: center"><msub><mi>r</mi><mrow><mi>M</mi><mo>,</mo><mn>1</mn></mrow></msub></mtd><mtd
    columnalign="center" style="text-align: center"><msub><mi>r</mi><mrow><mi>M</mi><mo>,</mo><mn>2</mn></mrow></msub></mtd><mtd
    columnalign="center" style="text-align: center"><mi>â‹¯</mi></mtd><mtd columnalign="center"
    style="text-align: center"><msub><mi>r</mi><mrow><mi>M</mi><mo>,</mo><mi>N</mi></mrow></msub></mtd></mtr></mtable><mo
    stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">R
    = \begin{bmatrix} r_{1,1} & r_{1,2} & \cdots & r_{1,N} \\ r_{2,1} & r_{2,2} &
    \cdots & r_{2,N} \\ \vdots & \vdots & \ddots & \vdots \\ r_{M,1} & r_{M,2} & \cdots
    & r_{M,N} \end{bmatrix}</annotation></semantics>'
- en: 'Each reward <semantics><msub><mi>r</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><annotation
    encoding="application/x-tex">r_{i,j}</annotation></semantics> is computed by passing
    the completion <semantics><msub><mi>y</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><annotation
    encoding="application/x-tex">y_{i,j}</annotation></semantics> and its corresponding
    prompt <semantics><msub><mi>x</mi><mi>i</mi></msub><annotation encoding="application/x-tex">x_i</annotation></semantics>
    through a reward model <semantics><mi>â„›</mi><annotation encoding="application/x-tex">\mathcal{R}</annotation></semantics>:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: æ¯ä¸ªå¥–åŠ± <semantics><msub><mi>r</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><annotation
    encoding="application/x-tex">r_{i,j}</annotation></semantics> éƒ½æ˜¯é€šè¿‡å°†å®Œæˆ <semantics><msub><mi>y</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><annotation
    encoding="application/x-tex">y_{i,j}</annotation></semantics> å’Œå…¶å¯¹åº”çš„æç¤º <semantics><msub><mi>x</mi><mi>i</mi></msub><annotation
    encoding="application/x-tex">x_i</annotation></semantics> é€šè¿‡ä¸€ä¸ªå¥–åŠ±æ¨¡å‹ <semantics><mi>â„›</mi><annotation
    encoding="application/x-tex">\mathcal{R}</annotation></semantics> æ¥è®¡ç®—çš„ï¼š
- en: <semantics><mrow><msub><mi>r</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>=</mo><mi>â„›</mi><mo
    stretchy="false" form="prefix">(</mo><msub><mi>y</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>âˆ£</mo><msub><mi>x</mi><mi>i</mi></msub><mo
    stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">r_{i,j}
    = \mathcal{R}(y_{i,j} \mid x_i)</annotation></semantics>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <semantics><mrow><msub><mi>r</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>=</mo><mi>â„›</mi><mo
    stretchy="false" form="prefix">(</mo><msub><mi>y</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>âˆ£</mo><msub><mi>x</mi><mi>i</mi></msub><mo
    stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">r_{i,j}
    = \mathcal{R}(y_{i,j} \mid x_i)</annotation></semantics>
- en: There are multiple methods to select the top completions to train on.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: æœ‰å¤šç§æ–¹æ³•å¯ä»¥é€‰æ‹©ç”¨äºè®­ç»ƒçš„æœ€é«˜å®Œæˆé¡¹ã€‚
- en: To formalize the process of selecting the best completions based on our reward
    matrix, we can define a selection function <semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics>
    that operates on the reward matrix <semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics>.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†å½¢å¼åŒ–åŸºäºæˆ‘ä»¬çš„å¥–åŠ±çŸ©é˜µé€‰æ‹©æœ€ä½³å®Œæˆé¡¹çš„è¿‡ç¨‹ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªé€‰æ‹©å‡½æ•°<semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics>ï¼Œå®ƒä½œç”¨äºå¥–åŠ±çŸ©é˜µ<semantics><mi>R</mi><annotation
    encoding="application/x-tex">R</annotation></semantics>ã€‚
- en: Top Per Prompt
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: æœ€é«˜æç¤º
- en: The first potential selection function takes the max reward per prompt.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ç¬¬ä¸€ä¸ªæ½œåœ¨çš„é€‰æ‹©å‡½æ•°å–æ¯ä¸ªæç¤ºçš„æœ€å¤§å¥–åŠ±ã€‚
- en: <semantics><mrow><mi>S</mi><mo stretchy="false" form="prefix">(</mo><mi>R</mi><mo
    stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">[</mo><mrow><mi
    mathvariant="normal">arg</mi><mo>â¡</mo></mrow><munder><mi mathvariant="normal">max</mi><mi>j</mi></munder><msub><mi>r</mi><mrow><mn>1</mn><mo>,</mo><mi>j</mi></mrow></msub><mo>,</mo><mrow><mi
    mathvariant="normal">arg</mi><mo>â¡</mo></mrow><munder><mi mathvariant="normal">max</mi><mi>j</mi></munder><msub><mi>r</mi><mrow><mn>2</mn><mo>,</mo><mi>j</mi></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mrow><mi
    mathvariant="normal">arg</mi><mo>â¡</mo></mrow><munder><mi mathvariant="normal">max</mi><mi>j</mi></munder><msub><mi>r</mi><mrow><mi>M</mi><mo>,</mo><mi>j</mi></mrow></msub><mo
    stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">S(R)
    = [\arg\max_{j} r_{1,j}, \arg\max_{j} r_{2,j}, ..., \arg\max_{j} r_{M,j}]</annotation></semantics>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <semantics><mrow><mi>S</mi><mo stretchy="false" form="prefix">(</mo><mi>R</mi><mo
    stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">[</mo><mrow><mi
    mathvariant="normal">arg</mi><mo>â¡</mo></mrow><munder><mi mathvariant="normal">max</mi><mi>j</mi></munder><msub><mi>r</mi><mrow><mn>1</mn><mo>,</mo><mi>j</mi></mrow></msub><mo>,</mo><mrow><mi
    mathvariant="normal">arg</mi><mo>â¡</mo></mrow><munder><mi mathvariant="normal">max</mi><mi>j</mi></munder><msub><mi>r</mi><mrow><mn>2</mn><mo>,</mo><mi>j</mi></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mrow><mi
    mathvariant="normal">arg</mi><mo>â¡</mo></mrow><munder><mi mathvariant="normal">max</mi><mi>j</mi></munder><msub><mi>r</mi><mrow><mi>M</mi><mo>,</mo><mi>j</mi></mrow></msub><mo
    stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">S(R)
    = [\arg\max_{j} r_{1,j}, \arg\max_{j} r_{2,j}, ..., \arg\max_{j} r_{M,j}]</annotation></semantics>
- en: 'This function <semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics>
    returns a vector of indices, where each index corresponds to the column with the
    maximum reward for each row in <semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics>.
    We can then use these indices to select our chosen completions:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªå‡½æ•°<semantics><mi>S</mi><annotation encoding="application/x-tex">S</annotation></semantics>è¿”å›ä¸€ä¸ªç´¢å¼•å‘é‡ï¼Œå…¶ä¸­æ¯ä¸ªç´¢å¼•å¯¹åº”äº<semantics><mi>R</mi><annotation
    encoding="application/x-tex">R</annotation></semantics>ä¸­æ¯è¡Œçš„æœ€å¤§å¥–åŠ±åˆ—ã€‚ç„¶åæˆ‘ä»¬å¯ä»¥ä½¿ç”¨è¿™äº›ç´¢å¼•æ¥é€‰æ‹©æˆ‘ä»¬çš„é€‰æ‹©å®Œæˆé¡¹ï¼š
- en: <semantics><mrow><msub><mi>Y</mi><mrow><mi>c</mi><mi>h</mi><mi>o</mi><mi>s</mi><mi>e</mi><mi>n</mi></mrow></msub><mo>=</mo><mo
    stretchy="false" form="prefix">[</mo><msub><mi>y</mi><mrow><mn>1</mn><mo>,</mo><mi>S</mi><mo
    stretchy="false" form="prefix">(</mo><mi>R</mi><msub><mo stretchy="false" form="postfix">)</mo><mn>1</mn></msub></mrow></msub><mo>,</mo><msub><mi>y</mi><mrow><mn>2</mn><mo>,</mo><mi>S</mi><mo
    stretchy="false" form="prefix">(</mo><mi>R</mi><msub><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msub></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>y</mi><mrow><mi>M</mi><mo>,</mo><mi>S</mi><mo
    stretchy="false" form="prefix">(</mo><mi>R</mi><msub><mo stretchy="false" form="postfix">)</mo><mi>M</mi></msub></mrow></msub><mo
    stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">Y_{chosen}
    = [y_{1,S(R)_1}, y_{2,S(R)_2}, ..., y_{M,S(R)_M}]</annotation></semantics>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <semantics><mrow><msub><mi>Y</mi><mrow><mi>c</mi><mi>h</mi><mi>o</mi><mi}s</mi><mi>e</mi><mi>n</mi></mrow></msub><mo>=</mo><mo
    stretchy="false" form="prefix">[</mo><msub><mi>y</mi><mrow><mn>1</mn><mo>,</mo><mi>S</mi><mo
    stretchy="false" form="prefix">(</mo><mi>R</mi><msub><mo stretchy="false" form="postfix">)</mo><mn>1</mn></msub></mrow></msub><mo>,</mo><msub><mi>y</mi><mrow><mn>2</mn><mo>,</mo><mi>S</mi><mo
    stretchy="false" form="prefix">(</mo><mi>R</mi><msub><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msub></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>y</mi><mrow><mi>M</mi><mo>,</mo><mi>S</mi><mo
    stretchy="false" form="prefix">(</mo><mi>R</mi><msub><mo stretchy="false" form="postfix">)</mo><mi>M</mi></msub></mrow></msub><mo
    stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">Y_{chosen}
    = [y_{1,S(R)_1}, y_{2,S(R)_2}, ..., y_{M,S(R)_M}]</annotation></semantics>
- en: Top Overall Pairs
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: æ€»ä½“å‰Kå¯¹
- en: 'Alternatively, we can select the top K prompt-completion pairs from the entire
    set. First, letâ€™s flatten our reward matrix R into a single vector:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ–è€…ï¼Œæˆ‘ä»¬å¯ä»¥ä»æ•´ä¸ªé›†åˆä¸­é€‰æ‹©å‰Kä¸ªæç¤º-å®Œæˆå¯¹ã€‚é¦–å…ˆï¼Œè®©æˆ‘ä»¬å°†å¥–åŠ±çŸ©é˜µRå±•å¹³æˆä¸€ä¸ªå•ä¸€å‘é‡ï¼š
- en: <semantics><mrow><msub><mi>R</mi><mrow><mi>f</mi><mi>l</mi><mi>a</mi><mi>t</mi></mrow></msub><mo>=</mo><mo
    stretchy="false" form="prefix">[</mo><msub><mi>r</mi><mrow><mn>1</mn><mo>,</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>r</mi><mrow><mn>1</mn><mo>,</mo><mn>2</mn></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>r</mi><mrow><mn>1</mn><mo>,</mo><mi>N</mi></mrow></msub><mo>,</mo><msub><mi>r</mi><mrow><mn>2</mn><mo>,</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>r</mi><mrow><mn>2</mn><mo>,</mo><mn>2</mn></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>r</mi><mrow><mn>2</mn><mo>,</mo><mi>N</mi></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>r</mi><mrow><mi>M</mi><mo>,</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>r</mi><mrow><mi>M</mi><mo>,</mo><mn>2</mn></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>r</mi><mrow><mi>M</mi><mo>,</mo><mi>N</mi></mrow></msub><mo
    stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">R_{flat}
    = [r_{1,1}, r_{1,2}, ..., r_{1,N}, r_{2,1}, r_{2,2}, ..., r_{2,N}, ..., r_{M,1},
    r_{M,2}, ..., r_{M,N}]</annotation></semantics>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <semantics><mrow><msub><mi>R</mi><mrow><mi>f</mi><mi>l</mi><mi>a</mi><mi>t</mi></mrow></msub><mo>=</mo><mo
    stretchy="false" form="prefix">[</mo><msub><mi>r</mi><mrow><mn>1</mn><mo>,</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>r</mi><mrow><mn>1</mn><mo>,</mo><mn>2</mn></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>r</mi><mrow><mn>1</mn><mo>,</mo><mi>N</mi></mrow></msub><mo>,</mo><msub><mi>r</mi><mrow><mn>2</mn><mo>,</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>r</mi><mrow><mn>2</mn><mo>,</mo><mn>2</mn></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>r</mi><mrow><mn>2</mn><mo>,</mo><mi>N</mi></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>r</mi><mrow><mi>M</mi><mo>,</mo><mn>1</mn></mrow></msub><mo>,</mo><msub><mi>r</mi><mrow><mi>M</mi><mo>,</mo><mn>2</mn></mrow></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>r</mi><mrow><mi>M</mi><mo>,</mo><mi>N</mi></mrow></msub><mo
    stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">R_{flat}
    = [r_{1,1}, r_{1,2}, ..., r_{1,N}, r_{2,1}, r_{2,2}, ..., r_{2,N}, ..., r_{M,1},
    r_{M,2}, ..., r_{M,N}]</annotation></semantics>
- en: This <semantics><msub><mi>R</mi><mrow><mi>f</mi><mi>l</mi><mi>a</mi><mi>t</mi></mrow></msub><annotation
    encoding="application/x-tex">R_{flat}</annotation></semantics> vector has length
    <semantics><mrow><mi>M</mi><mo>Ã—</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">M
    \times N</annotation></semantics>, where <semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics>
    is the number of prompts and <semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics>
    is the number of completions per prompt.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ª<semantics><msub><mi>R</mi><mrow><mi>f</mi><mi>l</mi><mi>a</mi><mi>t</mi></mrow></msub><annotation
    encoding="application/x-tex">R_{flat}</annotation></semantics>å‘é‡çš„é•¿åº¦æ˜¯<semantics><mrow><mi>M</mi><mo>Ã—</mo><mi>N</mi></mrow><annotation
    encoding="application/x-tex">M \times N</annotation></semantics>ï¼Œå…¶ä¸­<semantics><mi>M</mi><annotation
    encoding="application/x-tex">M</annotation></semantics>æ˜¯æç¤ºçš„æ•°é‡ï¼Œ<semantics><mi>N</mi><annotation
    encoding="application/x-tex">N</annotation></semantics>æ˜¯æ¯ä¸ªæç¤ºçš„å®Œæˆæ•°é‡ã€‚
- en: 'Now, we can define a selection function <semantics><msub><mi>S</mi><mi>K</mi></msub><annotation
    encoding="application/x-tex">S_K</annotation></semantics> that selects the indices
    of the K highest values in <semantics><msub><mi>R</mi><mrow><mi>f</mi><mi>l</mi><mi>a</mi><mi>t</mi></mrow></msub><annotation
    encoding="application/x-tex">R_{flat}</annotation></semantics>:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªé€‰æ‹©å‡½æ•° <semantics><msub><mi>S</mi><mi>K</mi></msub><annotation encoding="application/x-tex">S_K</annotation></semantics>ï¼Œè¯¥å‡½æ•°ç”¨äºé€‰æ‹©
    <semantics><msub><mi>R</mi><mrow><mi>f</mi><mi>l</mi><mi>a</mi><mi>t</mi></mrow></msub><annotation
    encoding="application/x-tex">R_{flat}</annotation></semantics> ä¸­ K ä¸ªæœ€é«˜å€¼çš„ç´¢å¼•ï¼š
- en: <semantics><mrow><msub><mi>S</mi><mi>K</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>R</mi><mrow><mi>f</mi><mi>l</mi><mi>a</mi><mi>t</mi></mrow></msub><mo
    stretchy="false" form="postfix">)</mo><mo>=</mo><mtext mathvariant="normal">argsort</mtext><mo
    stretchy="false" form="prefix">(</mo><msub><mi>R</mi><mrow><mi>f</mi><mi>l</mi><mi>a</mi><mi>t</mi></mrow></msub><mo
    stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">[</mo><mi>âˆ’</mi><mi>K</mi><mo>:</mo><mo
    stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">S_K(R_{flat})
    = \text{argsort}(R_{flat})[-K:]</annotation></semantics>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <semantics><mrow><msub><mi>S</mi><mi>K</mi></msub><mo stretchy="false" form="prefix">(</mo><msub><mi>R</mi><mrow><mi>f</mi><mi>l</mi><mi>a</mi><mi>t</mi></mrow></msub><mo
    stretchy="false" form="postfix">)</mo><mo>=</mo><mtext mathvariant="normal">argsort</mtext><mo
    stretchy="false" form="prefix">(</mo><msub><mi>R</mi><mrow><mi>f</mi><mi>l</mi><mi>a</mi><mi>t</mi></mrow></msub><mo
    stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">[</mo><mi>âˆ’</mi><mi>K</mi><mo>:</mo><mo
    stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">S_K(R_{flat})
    = \text{argsort}(R_{flat})[-K:]</annotation></semantics>
- en: where <semantics><mtext mathvariant="normal">argsort</mtext><annotation encoding="application/x-tex">\text{argsort}</annotation></semantics>
    returns the indices that would sort the array in ascending order, and we take
    the last K indices to get the K highest values.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­ <semantics><mtext mathvariant="normal">argsort</mtext><annotation encoding="application/x-tex">\text{argsort}</annotation></semantics>
    è¿”å›å°†æ•°ç»„æŒ‰å‡åºæ’åºçš„ç´¢å¼•ï¼Œæˆ‘ä»¬å–æœ€å K ä¸ªç´¢å¼•ä»¥è·å– K ä¸ªæœ€é«˜å€¼ã€‚
- en: To get our selected completions, we need to map these flattened indices back
    to our original completion matrix <semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics>.
    To recover the corresponding (prompt, completion) pair, you can map a zero-indexed
    flattened index <semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics>
    to <semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo
    stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics>
    via <semantics><mrow><mi>i</mi><mo>=</mo><mo stretchy="false" form="prefix">âŒŠ</mo><mi>k</mi><mi>/</mi><mi>N</mi><mo
    stretchy="false" form="postfix">âŒ‹</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i
    = \lfloor k / N \rfloor + 1</annotation></semantics> and <semantics><mrow><mi>j</mi><mo>=</mo><mo
    stretchy="false" form="prefix">(</mo><mi>k</mi><mrow><mrow><mi mathvariant="normal">mod</mi><mo>â¡</mo></mrow><mi>N</mi></mrow><mo
    stretchy="false" form="postfix">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">j
    = (k \bmod N) + 1</annotation></semantics>.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: è¦è·å–æˆ‘ä»¬çš„é€‰æ‹©å®Œæˆé¡¹ï¼Œæˆ‘ä»¬éœ€è¦å°†è¿™äº›å±•å¹³çš„ç´¢å¼•æ˜ å°„å›æˆ‘ä»¬çš„åŸå§‹å®ŒæˆçŸ©é˜µ <semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics>ã€‚è¦æ¢å¤ç›¸åº”çš„ï¼ˆæç¤ºï¼Œå®Œæˆï¼‰å¯¹ï¼Œä½ å¯ä»¥å°†é›¶ç´¢å¼•çš„å±•å¹³ç´¢å¼•
    <semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics>
    æ˜ å°„åˆ° <semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo
    stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics>ï¼Œé€šè¿‡
    <semantics><mrow><mi>i</mi><mo>=</mo><mo stretchy="false" form="prefix">âŒŠ</mo><mi>k</mi><mi>/</mi><mi>N</mi><mo
    stretchy="false" form="postfix">âŒ‹</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i
    = \lfloor k / N \rfloor + 1</annotation></semantics> å’Œ <semantics><mrow><mi>j</mi><mo>=</mo><mo
    stretchy="false" form="prefix">(</mo><mi>k</mi><mrow><mrow><mi mathvariant="normal">mod</mi><mo>â¡</mo></mrow><mi>N</mi></mrow><mo
    stretchy="false" form="postfix">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">j
    = (k \bmod N) + 1</annotation></semantics>ã€‚
- en: Selection Example
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: é€‰æ‹©ç¤ºä¾‹
- en: Consider the case where we have the following situation, with 5 prompts and
    4 completions. We will show two ways of selecting the completions based on reward.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘ä»¥ä¸‹æƒ…å†µï¼Œæˆ‘ä»¬æœ‰ 5 ä¸ªæç¤ºå’Œ 4 ä¸ªå®Œæˆé¡¹ã€‚æˆ‘ä»¬å°†å±•ç¤ºä¸¤ç§åŸºäºå¥–åŠ±é€‰æ‹©å®Œæˆé¡¹çš„æ–¹æ³•ã€‚
- en: '<semantics><mrow><mi>R</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd
    columnalign="center" style="text-align: center"><mn>0.7</mn></mtd><mtd columnalign="center"
    style="text-align: center"><mn>0.3</mn></mtd><mtd columnalign="center" style="text-align:
    center"><mn>0.5</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0.2</mn></mtd></mtr><mtr><mtd
    columnalign="center" style="text-align: center"><mn>0.4</mn></mtd><mtd columnalign="center"
    style="text-align: center"><mn>0.8</mn></mtd><mtd columnalign="center" style="text-align:
    center"><mn>0.6</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0.5</mn></mtd></mtr><mtr><mtd
    columnalign="center" style="text-align: center"><mn>0.9</mn></mtd><mtd columnalign="center"
    style="text-align: center"><mn>0.3</mn></mtd><mtd columnalign="center" style="text-align:
    center"><mn>0.4</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0.7</mn></mtd></mtr><mtr><mtd
    columnalign="center" style="text-align: center"><mn>0.2</mn></mtd><mtd columnalign="center"
    style="text-align: center"><mn>0.5</mn></mtd><mtd columnalign="center" style="text-align:
    center"><mn>0.8</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0.6</mn></mtd></mtr><mtr><mtd
    columnalign="center" style="text-align: center"><mn>0.5</mn></mtd><mtd columnalign="center"
    style="text-align: center"><mn>0.4</mn></mtd><mtd columnalign="center" style="text-align:
    center"><mn>0.3</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0.6</mn></mtd></mtr></mtable><mo
    stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">R
    = \begin{bmatrix} 0.7 & 0.3 & 0.5 & 0.2 \\ 0.4 & 0.8 & 0.6 & 0.5 \\ 0.9 & 0.3
    & 0.4 & 0.7 \\ 0.2 & 0.5 & 0.8 & 0.6 \\ 0.5 & 0.4 & 0.3 & 0.6 \end{bmatrix}</annotation></semantics>'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '<semantics><mrow><mi>R</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd
    columnalign="center" style="text-align: center"><mn>0.7</mn></mtd><mtd columnalign="center"
    style="text-align: center"><mn>0.3</mn></mtd><mtd columnalign="center" style="text-align:
    center"><mn>0.5</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0.2</mn></mtd></mtr><mtr><mtd
    columnalign="center" style="text-align: center"><mn>0.4</mn></mtd><mtd columnalign="center"
    style="text-align: center"><mn>0.8</mn></mtd><mtd columnalign="center" style="text-align:
    center"><mn>0.6</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0.5</mn></mtd></mtr><mtr><mtd
    columnalign="center" style="text-align: center"><mn>0.9</mn></mtd><mtd columnalign="center"
    style="text-align: center"><mn>0.3</mn></mtd><mtd columnalign="center" style="text-align:
    center"><mn>0.4</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0.7</mn></mtd></mtr><mtr><mtd
    columnalign="center" style="text-align: center"><mn>0.2</mn></mtd><mtd columnalign="center"
    style="text-align: center"><mn>0.5</mn></mtd><mtd columnalign="center" style="text-align:
    center"><mn>0.8</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0.6</mn></mtd></mtr><mtr><mtd
    columnalign="center" style="text-align: center"><mn>0.5</mn></mtd><mtd columnalign="center"
    style="text-align: center"><mn>0.4</mn></mtd><mtd columnalign="center" style="text-align:
    center"><mn>0.3</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0.6</mn></mtd></mtr></mtable><mo
    stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">R
    = \begin{bmatrix} 0.7 & 0.3 & 0.5 & 0.2 \\ 0.4 & 0.8 & 0.6 & 0.5 \\ 0.9 & 0.3
    & 0.4 & 0.7 \\ 0.2 & 0.5 & 0.8 & 0.6 \\ 0.5 & 0.4 & 0.3 & 0.6 \end{bmatrix}</annotation></semantics>'
- en: 'First, **per prompt**. Intuitively, we can highlight the reward matrix as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œ**æ ¹æ®æç¤º**ã€‚ç›´è§‚ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥å°†å¥–åŠ±çŸ©é˜µçªå‡ºæ˜¾ç¤ºå¦‚ä¸‹ï¼š
- en: '<semantics><mrow><mi>R</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd
    columnalign="center" style="text-align: center"><mtext mathvariant="bold">ğŸ.ğŸ•</mtext></mtd><mtd
    columnalign="center" style="text-align: center"><mn>0.3</mn></mtd><mtd columnalign="center"
    style="text-align: center"><mn>0.5</mn></mtd><mtd columnalign="center" style="text-align:
    center"><mn>0.2</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align:
    center"><mn>0.4</mn></mtd><mtd columnalign="center" style="text-align: center"><mtext
    mathvariant="bold">ğŸ.ğŸ–</mtext></mtd><mtd columnalign="center" style="text-align:
    center"><mn>0.6</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0.5</mn></mtd></mtr><mtr><mtd
    columnalign="center" style="text-align: center"><mtext mathvariant="bold">ğŸ.ğŸ—</mtext></mtd><mtd
    columnalign="center" style="text-align: center"><mn>0.3</mn></mtd><mtd columnalign="center"
    style="text-align: center"><mn>0.4</mn></mtd><mtd columnalign="center" style="text-align:
    center"><mn>0.7</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align:
    center"><mn>0.2</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0.5</mn></mtd><mtd
    columnalign="center" style="text-align: center"><mtext mathvariant="bold">ğŸ.ğŸ–</mtext></mtd><mtd
    columnalign="center" style="text-align: center"><mn>0.6</mn></mtd></mtr><mtr><mtd
    columnalign="center" style="text-align: center"><mn>0.5</mn></mtd><mtd columnalign="center"
    style="text-align: center"><mn>0.4</mn></mtd><mtd columnalign="center" style="text-align:
    center"><mn>0.3</mn></mtd><mtd columnalign="center" style="text-align: center"><mtext
    mathvariant="bold">ğŸ.ğŸ”</mtext></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation
    encoding="application/x-tex">R = \begin{bmatrix} \textbf{0.7} & 0.3 & 0.5 & 0.2
    \\ 0.4 & \textbf{0.8} & 0.6 & 0.5 \\ \textbf{0.9} & 0.3 & 0.4 & 0.7 \\ 0.2 & 0.5
    & \textbf{0.8} & 0.6 \\ 0.5 & 0.4 & 0.3 & \textbf{0.6} \end{bmatrix}</annotation></semantics>'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the argmax method, we select the best completion for each prompt:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: <semantics><mrow><mi>S</mi><mo stretchy="false" form="prefix">(</mo><mi>R</mi><mo
    stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">[</mo><mrow><mi
    mathvariant="normal">arg</mi><mo>â¡</mo></mrow><munder><mi mathvariant="normal">max</mi><mi>j</mi></munder><msub><mi>r</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub>
    <mrow><mtext mathvariant="normal">for</mtext></mrow> <mi>i</mi><mo>âˆˆ</mo><mo stretchy="false"
    form="prefix">[</mo><mn>1</mn><mo>,</mo><mn>5</mn><mo stretchy="false" form="postfix">]</mo><mo
    stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">S(R)
    = [\arg\max_{j} r_{i,j} \text{ for } i \in [1,5]]</annotation></semantics>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: <semantics><mrow><mi>S</mi><mo stretchy="false" form="prefix">(</mo><mi>R</mi><mo
    stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">[</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>4</mn><mo
    stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">S(R)
    = [1, 2, 1, 3, 4]</annotation></semantics>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <semantics><mrow><mi>S</mi><mo stretchy="false" form="prefix">(</mo><mi>R</mi><mo
    stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">[</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>4</mn><mo
    stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">S(R)
    = [1, 2, 1, 3, 4]</annotation></semantics>
- en: 'This means we would select:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ„å‘³ç€æˆ‘ä»¬ä¼šé€‰æ‹©ï¼š
- en: 'For prompt 1: completion 1 (reward 0.7)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯¹äºæç¤º1ï¼šå®Œæˆ1ï¼ˆå¥–åŠ±0.7ï¼‰
- en: 'For prompt 2: completion 2 (reward 0.8)'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯¹äºæç¤º2ï¼šå®Œæˆ2ï¼ˆå¥–åŠ±0.8ï¼‰
- en: 'For prompt 3: completion 1 (reward 0.9)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯¹äºæç¤º3ï¼šå®Œæˆ1ï¼ˆå¥–åŠ±0.9ï¼‰
- en: 'For prompt 4: completion 3 (reward 0.8)'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯¹äºæç¤º4ï¼šå®Œæˆ3ï¼ˆå¥–åŠ±0.8ï¼‰
- en: 'For prompt 5: completion 4 (reward 0.6)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯¹äºæç¤º5ï¼šå®Œæˆ4ï¼ˆå¥–åŠ±0.6ï¼‰
- en: Now, **best overall**. Letâ€™s highlight the top 5 overall completion pairs.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œ**æœ€ä½³æ•´ä½“**ã€‚è®©æˆ‘ä»¬çªå‡ºæ˜¾ç¤ºå‰5ä¸ªæœ€ä½³æ•´ä½“å®Œæˆå¯¹ã€‚
- en: '<semantics><mrow><mi>R</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd
    columnalign="center" style="text-align: center"><mtext mathvariant="bold">ğŸ.ğŸ•</mtext></mtd><mtd
    columnalign="center" style="text-align: center"><mn>0.3</mn></mtd><mtd columnalign="center"
    style="text-align: center"><mn>0.5</mn></mtd><mtd columnalign="center" style="text-align:
    center"><mn>0.2</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align:
    center"><mn>0.4</mn></mtd><mtd columnalign="center" style="text-align: center"><mtext
    mathvariant="bold">ğŸ.ğŸ–</mtext></mtd><mtd columnalign="center" style="text-align:
    center"><mn>0.6</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0.5</mn></mtd></mtr><mtr><mtd
    columnalign="center" style="text-align: center"><mtext mathvariant="bold">ğŸ.ğŸ—</mtext></mtd><mtd
    columnalign="center" style="text-align: center"><mn>0.3</mn></mtd><mtd columnalign="center"
    style="text-align: center"><mn>0.4</mn></mtd><mtd columnalign="center" style="text-align:
    center"><mtext mathvariant="bold">ğŸ.ğŸ•</mtext></mtd></mtr><mtr><mtd columnalign="center"
    style="text-align: center"><mn>0.2</mn></mtd><mtd columnalign="center" style="text-align:
    center"><mn>0.5</mn></mtd><mtd columnalign="center" style="text-align: center"><mtext
    mathvariant="bold">ğŸ.ğŸ–</mtext></mtd><mtd columnalign="center" style="text-align:
    center"><mn>0.6</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align:
    center"><mn>0.5</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0.4</mn></mtd><mtd
    columnalign="center" style="text-align: center"><mn>0.3</mn></mtd><mtd columnalign="center"
    style="text-align: center"><mn>0.6</mn></mtd></mtr></mtable><mo stretchy="true"
    form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">R
    = \begin{bmatrix} \textbf{0.7} & 0.3 & 0.5 & 0.2 \\ 0.4 & \textbf{0.8} & 0.6 &
    0.5 \\ \textbf{0.9} & 0.3 & 0.4 & \textbf{0.7} \\ 0.2 & 0.5 & \textbf{0.8} & 0.6
    \\ 0.5 & 0.4 & 0.3 & 0.6 \end{bmatrix}</annotation></semantics>'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '<semantics><mrow><mi>R</mi><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd
    columnalign="center" style="text-align: center"><mtext mathvariant="bold">ğŸ.ğŸ•</mtext></mtd><mtd
    columnalign="center" style="text-align: center"><mn>0.3</mn></mtd><mtd columnalign="center"
    style="text-align: center"><mn>0.5</mn></mtd><mtd columnalign="center" style="text-align:
    center"><mn>0.2</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align:
    center"><mn>0.4</mn></mtd><mtd columnalign="center" style="text-align: center"><mtext
    mathvariant="bold">ğŸ.ğŸ–</mtext></mtd><mtd columnalign="center" style="text-align:
    center"><mn>0.6</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0.5</mn></mtd></mtr><mtr><mtd
    columnalign="center" style="text-align: center"><mtext mathvariant="bold">ğŸ.ğŸ—</mtext></mtd><mtd
    columnalign="center" style="text-align: center"><mn>0.3</mn></mtd><mtd columnalign="center"
    style="text-align: center"><mn>0.4</mn></mtd><mtd columnalign="center" style="text-align:
    center"><mtext mathvariant="bold">ğŸ.ğŸ•</mtext></mtd></mtr><mtr><mtd columnalign="center"
    style="text-align: center"><mn>0.2</mn></mtd><mtd columnalign="center" style="text-align:
    center"><mn>0.5</mn></mtd><mtd columnalign="center" style="text-align: center"><mtext
    mathvariant="bold">ğŸ.ğŸ–</mtext></mtd><mtd columnalign="center" style="text-align:
    center"><mn>0.6</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align:
    center"><mn>0.5</mn></mtd><mtd columnalign="center" style="text-align: center"><mn>0.4</mn></mtd><mtd
    columnalign="center" style="text-align: center"><mn>0.3</mn></mtd><mtd columnalign="center"
    style="text-align: center"><mn>0.6</mn></mtd></mtr></mtable><mo stretchy="true"
    form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">R
    = \begin{bmatrix} \textbf{0.7} & 0.3 & 0.5 & 0.2 \\ 0.4 & \textbf{0.8} & 0.6 &
    0.5 \\ \textbf{0.9} & 0.3 & 0.4 & \textbf{0.7} \\ 0.2 & 0.5 & \textbf{0.8} & 0.6
    \\ 0.5 & 0.4 & 0.3 & 0.6 \end{bmatrix}</annotation></semantics>'
- en: 'First, we flatten the reward matrix:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæˆ‘ä»¬å°†å¥–åŠ±çŸ©é˜µå±•å¹³ï¼š
- en: <semantics><mrow><msub><mi>R</mi><mrow><mi>f</mi><mi>l</mi><mi>a</mi><mi>t</mi></mrow></msub><mo>=</mo><mo
    stretchy="false" form="prefix">[</mo><mn>0.7</mn><mo>,</mo><mn>0.3</mn><mo>,</mo><mn>0.5</mn><mo>,</mo><mn>0.2</mn><mo>,</mo><mn>0.4</mn><mo>,</mo><mn>0.8</mn><mo>,</mo><mn>0.6</mn><mo>,</mo><mn>0.5</mn><mo>,</mo><mn>0.9</mn><mo>,</mo><mn>0.3</mn><mo>,</mo><mn>0.4</mn><mo>,</mo><mn>0.7</mn><mo>,</mo><mn>0.2</mn><mo>,</mo><mn>0.5</mn><mo>,</mo><mn>0.8</mn><mo>,</mo><mn>0.6</mn><mo>,</mo><mn>0.5</mn><mo>,</mo><mn>0.4</mn><mo>,</mo><mn>0.3</mn><mo>,</mo><mn>0.6</mn><mo
    stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">R_{flat}
    = [0.7, 0.3, 0.5, 0.2, 0.4, 0.8, 0.6, 0.5, 0.9, 0.3, 0.4, 0.7, 0.2, 0.5, 0.8,
    0.6, 0.5, 0.4, 0.3, 0.6]</annotation></semantics>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <semantics><mrow><msub><mi>R</mi><mrow><mi>f</mi><mi>l</mi><mi>a</mi><mi>t</mi></mrow></msub><mo>=</mo><mo
    stretchy="false" form="prefix">[</mo><mn>0.7</mn><mo>,</mo><mn>0.3</mn><mo>,</mo><mn>0.5</mn><mo>,</mo><mn>0.2</mn><mo>,</mo><mn>0.4</mn><mo>,</mo><mn>0.8</mn><mo>,</mo><mn>0.6</mn><mo>,</mo><mn>0.5</mn><mo>,</mo><mn>0.9</mn><mo>,</mo><mn>0.3</mn><mo>,</mo><mn>0.4</mn><mo>,</mo><mn>0.7</mn><mo>,</mo><mn>0.2</mn><mo>,</mo><mn>0.5</mn><mo>,</mo><mn>0.8</mn><mo>,</mo><mn>0.6</mn><mo>,</mo><mn>0.5</mn><mo>,</mo><mn>0.4</mn><mo>,</mo><mn>0.3</mn><mo>,</mo><mn>0.6</mn><mo
    stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">R_{flat}
    = [0.7, 0.3, 0.5, 0.2, 0.4, 0.8, 0.6, 0.5, 0.9, 0.3, 0.4, 0.7, 0.2, 0.5, 0.8,
    0.6, 0.5, 0.4, 0.3, 0.6]</annotation></semantics>
- en: 'Now, we select the indices of the 5 highest values: <semantics><mrow><msub><mi>S</mi><mn>5</mn></msub><mo
    stretchy="false" form="prefix">(</mo><msub><mi>R</mi><mrow><mi>f</mi><mi>l</mi><mi>a</mi><mi>t</mi></mrow></msub><mo
    stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">[</mo><mn>8</mn><mo>,</mo><mn>5</mn><mo>,</mo><mn>14</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>11</mn><mo
    stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">S_5(R_{flat})
    = [8, 5, 14, 0, 11]</annotation></semantics>'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬é€‰æ‹©5ä¸ªæœ€é«˜å€¼çš„ç´¢å¼•ï¼š<semantics><mrow><msub><mi>S</mi><mn>5</mn></msub><mo stretchy="false"
    form="prefix">(</mo><msub><mi>R</mi><mrow><mi>f</mi><mi>l</mi><mi>a</mi><mi>t</mi></mrow></msub><mo
    stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">[</mo><mn>8</mn><mo>,</mo><mn>5</mn><mo>,</mo><mn>14</mn><mo>,</mo><mn>0</mn><mo>,</mo><mn>11</mn><mo
    stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">S_5(R_{flat})
    = [8, 5, 14, 0, 11]</annotation></semantics>
- en: 'Mapping these back to our original matrix:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: å°†è¿™äº›æ˜ å°„å›æˆ‘ä»¬çš„åŸå§‹çŸ©é˜µï¼š
- en: Index 8 â†’ prompt 3, completion 1 (reward 0.9)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç´¢å¼• 8 â†’ æç¤º 3ï¼Œè¡¥å…¨ 1ï¼ˆå¥–åŠ± 0.9ï¼‰
- en: Index 5 â†’ prompt 2, completion 2 (reward 0.8)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç´¢å¼• 5 â†’ æç¤º 2ï¼Œè¡¥å…¨ 2ï¼ˆå¥–åŠ± 0.8ï¼‰
- en: Index 14 â†’ prompt 4, completion 3 (reward 0.8)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç´¢å¼• 14 â†’ æç¤º 4ï¼Œè¡¥å…¨ 3ï¼ˆå¥–åŠ± 0.8ï¼‰
- en: Index 0 â†’ prompt 1, completion 1 (reward 0.7)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç´¢å¼• 0 â†’ æç¤º 1ï¼Œè¡¥å…¨ 1ï¼ˆå¥–åŠ± 0.7ï¼‰
- en: Index 11 â†’ prompt 3, completion 4 (reward 0.7)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç´¢å¼• 11 â†’ æç¤º 3ï¼Œè¡¥å…¨ 4ï¼ˆå¥–åŠ± 0.7ï¼‰
- en: Implementation Example
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: å®ç°ç¤ºä¾‹
- en: Here is a code snippet showing how the selection methods could be implemented.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯ä¸€ä¸ªä»£ç ç‰‡æ®µï¼Œå±•ç¤ºäº†é€‰æ‹©æ–¹æ³•å¯ä»¥å¦‚ä½•å®ç°ã€‚
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 3\. Fine-tuning
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3. å¾®è°ƒ
- en: With the selected completions, you then perform standard instruction fine-tuning
    on the current rendition of the model. More details can be found in the [chapter
    on instruction tuning](https://rlhfbook.com/c/instructions).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨é€‰å®šçš„è¡¥å…¨åï¼Œæ‚¨æ¥ç€å¯¹å½“å‰ç‰ˆæœ¬çš„æ¨¡å‹æ‰§è¡Œæ ‡å‡†çš„æŒ‡ä»¤å¾®è°ƒã€‚æ›´å¤šç»†èŠ‚å¯ä»¥åœ¨[æŒ‡ä»¤è°ƒæ•´ç« èŠ‚](https://rlhfbook.com/c/instructions)ä¸­æ‰¾åˆ°ã€‚
- en: Implementation Details
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å®ç°ç»†èŠ‚
- en: 'The core hyperparameters for performing this training are very intuitive:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰§è¡Œæ­¤è®­ç»ƒçš„æ ¸å¿ƒè¶…å‚æ•°éå¸¸ç›´è§‚ï¼š
- en: '**Sampling parameters**: Rejection sampling is directly dependent on the completions
    received from the model. Common settings for rejection sampling include temperatures
    above zero, e.g.Â between 0.7 and 1.0, with other modifications to parameters such
    as top-p or top-k sampling.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**é‡‡æ ·å‚æ•°**ï¼šæ‹’ç»é‡‡æ ·ç›´æ¥ä¾èµ–äºä»æ¨¡å‹æ”¶åˆ°çš„è¡¥å…¨ã€‚æ‹’ç»é‡‡æ ·çš„å¸¸è§è®¾ç½®åŒ…æ‹¬é«˜äºé›¶çš„æ¸©åº¦ï¼Œä¾‹å¦‚åœ¨0.7åˆ°1.0ä¹‹é—´ï¼Œä»¥åŠå…¶ä»–å¯¹å‚æ•°å¦‚top-pæˆ–top-ké‡‡æ ·çš„ä¿®æ”¹ã€‚'
- en: '**Completions per prompt**: Successful implementations of rejection sampling
    have included 10 to 30 or more completions for each prompt. Using too few completions
    will make training biased and/or noisy.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**æ¯ä¸ªæç¤ºçš„è¡¥å…¨æ•°é‡**ï¼šæ‹’ç»é‡‡æ ·çš„æˆåŠŸå®ç°åŒ…æ‹¬æ¯ä¸ªæç¤º10åˆ°30ä¸ªæˆ–æ›´å¤šçš„è¡¥å…¨ã€‚ä½¿ç”¨è¿‡å°‘çš„è¡¥å…¨å°†ä½¿è®­ç»ƒç»“æœåå‘ä¸”/æˆ–å™ªå£°è¾ƒå¤§ã€‚'
- en: '**Instruction tuning details**: No clear training details for the instruction
    tuning during rejection sampling have been released. It is likely that they use
    slightly different settings than the initial instruction tuning phase of the model.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**æŒ‡ä»¤è°ƒæ•´ç»†èŠ‚**ï¼šåœ¨æ‹’ç»é‡‡æ ·æœŸé—´çš„æŒ‡ä»¤è°ƒæ•´æ²¡æœ‰å‘å¸ƒæ˜ç¡®çš„è®­ç»ƒç»†èŠ‚ã€‚å¾ˆå¯èƒ½æ˜¯ä»–ä»¬ä½¿ç”¨äº†ä¸æ¨¡å‹åˆå§‹æŒ‡ä»¤è°ƒæ•´é˜¶æ®µç•¥æœ‰ä¸åŒçš„è®¾ç½®ã€‚'
- en: '**Heterogeneous model generations**: Some implementations of rejection sampling
    include generations from multiple models rather than just the current model that
    is going to be trained. Best practices on how to do this are not established.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**å¼‚æ„æ¨¡å‹ç”Ÿæˆ**ï¼šä¸€äº›æ‹’ç»é‡‡æ ·çš„å®ç°åŒ…æ‹¬ä»å¤šä¸ªæ¨¡å‹ç”Ÿæˆï¼Œè€Œä¸ä»…ä»…æ˜¯å³å°†è®­ç»ƒçš„å½“å‰æ¨¡å‹ã€‚å¦‚ä½•åšåˆ°è¿™ä¸€ç‚¹è¿˜æ²¡æœ‰å»ºç«‹æœ€ä½³å®è·µã€‚'
- en: '**Reward model training**: The reward model used will heavily impact the final
    result. For more resources on reward model training, see the [relevant chapter](https://rlhfbook.com/c/07-reward-models).'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**å¥–åŠ±æ¨¡å‹è®­ç»ƒ**ï¼šæ‰€ä½¿ç”¨çš„å¥–åŠ±æ¨¡å‹å°†ä¸¥é‡å½±å“æœ€ç»ˆç»“æœã€‚æœ‰å…³å¥–åŠ±æ¨¡å‹è®­ç»ƒçš„æ›´å¤šèµ„æºï¼Œè¯·å‚é˜…[ç›¸å…³ç« èŠ‚](https://rlhfbook.com/c/07-reward-models)ã€‚'
- en: When doing batch reward model inference, you can sort the tokenized completions
    by length so that the batches are of similar lengths. This eliminates the need
    to run inference on as many padding tokens and will improve throughput in exchange
    for minor implementation complexity.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿›è¡Œæ‰¹é‡å¥–åŠ±æ¨¡å‹æ¨ç†æ—¶ï¼Œä½ å¯ä»¥æŒ‰é•¿åº¦å¯¹åˆ†è¯è¡¥å…¨è¿›è¡Œæ’åºï¼Œä»¥ä¾¿æ‰¹æ¬¡å…·æœ‰ç›¸ä¼¼é•¿åº¦ã€‚è¿™æ¶ˆé™¤äº†å¯¹è®¸å¤šå¡«å……æ ‡è®°è¿›è¡Œæ¨ç†çš„éœ€è¦ï¼Œå¹¶å°†é€šè¿‡è½»å¾®çš„å®ç°å¤æ‚æ€§æ¢å–ååé‡çš„æé«˜ã€‚
- en: 'Related: Best-of-N Sampling'
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ç›¸å…³ï¼šBest-of-N é‡‡æ ·
- en: Best-of-N (BoN) is a close relative of rejection sampling, where the same generate-and-score
    procedure is followed, but you do **not** fine-tune the model on the selected
    completions. Instead, BoN is a way of computing a best possible completion to
    a static prompt (or set of prompts) at inference time, and related techniques
    are often used in â€œProâ€ tiers of chat models that spend extra compute to get an
    answer to your query.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Best-of-N (BoN) æ˜¯æ‹’ç»é‡‡æ ·çš„ä¸€ä¸ªè¿‘äº²ï¼Œéµå¾ªç›¸åŒçš„ç”Ÿæˆå’Œè¯„åˆ†è¿‡ç¨‹ï¼Œä½†ä½ **ä¸**å¯¹é€‰å®šçš„è¡¥å…¨è¿›è¡Œå¾®è°ƒã€‚ç›¸åï¼ŒBoN æ˜¯ä¸€ç§åœ¨æ¨ç†æ—¶è®¡ç®—å¯¹é™æ€æç¤ºï¼ˆæˆ–æç¤ºé›†ï¼‰çš„æœ€ä½³å¯èƒ½è¡¥å…¨çš„æ–¹æ³•ï¼Œç›¸å…³æŠ€æœ¯å¸¸ç”¨äºâ€œProâ€çº§åˆ«çš„èŠå¤©æ¨¡å‹ï¼Œè¿™äº›æ¨¡å‹ä¼šæŠ•å…¥é¢å¤–çš„è®¡ç®—èµ„æºæ¥å›ç­”ä½ çš„æŸ¥è¯¢ã€‚
- en: Best-of-N sampling is often included as a baseline relative to RLHF training
    methods. It is important to remember that BoN *does not* modify the underlying
    model, but is a sampling technique. For this reason, comparisons for BoN sampling
    to online training methods, such as PPO, are still valid in some contexts. For
    example, you can still measure the KL distance when running BoN sampling relative
    to any other policy.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Best-of-N é‡‡æ ·é€šå¸¸è¢«åŒ…æ‹¬ä¸ºä¸ RLHF è®­ç»ƒæ–¹æ³•ç›¸å¯¹çš„åŸºçº¿ã€‚é‡è¦çš„æ˜¯è¦è®°ä½ï¼ŒBoN **ä¸**ä¿®æ”¹åº•å±‚æ¨¡å‹ï¼Œè€Œæ˜¯ä¸€ç§é‡‡æ ·æŠ€æœ¯ã€‚å› æ­¤ï¼Œå°† BoN
    é‡‡æ ·ä¸åœ¨çº¿è®­ç»ƒæ–¹æ³•ï¼ˆå¦‚ PPOï¼‰è¿›è¡Œæ¯”è¾ƒåœ¨æŸäº›æƒ…å†µä¸‹ä»ç„¶æ˜¯æœ‰æ•ˆçš„ã€‚ä¾‹å¦‚ï¼Œå½“è¿è¡Œ BoN é‡‡æ ·ç›¸å¯¹äºä»»ä½•å…¶ä»–ç­–ç•¥æ—¶ï¼Œä½ ä»ç„¶å¯ä»¥æµ‹é‡ KL è·ç¦»ã€‚
- en: Here, we will show that when using simple BoN sampling over one prompt, both
    selection criteria shown above are equivalent.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†å±•ç¤ºï¼Œå½“ä½¿ç”¨ç®€å•çš„ BoN é‡‡æ ·å¯¹ä¸€ä¸ªæç¤ºè¿›è¡Œé‡‡æ ·æ—¶ï¼Œä¸Šè¿°ä¸¤ä¸ªé€‰æ‹©æ ‡å‡†æ˜¯ç­‰ä»·çš„ã€‚
- en: 'Let R be a reward vector for our single prompt with N completions:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: è®¾ R ä¸ºæˆ‘ä»¬å•ä¸ªæç¤ºçš„å¥–åŠ±å‘é‡ï¼Œå…¶ä¸­åŒ…å« N ä¸ªè¡¥å…¨ï¼š
- en: <semantics><mrow><mi>R</mi><mo>=</mo><mo stretchy="false" form="prefix">[</mo><msub><mi>r</mi><mn>1</mn></msub><mo>,</mo><msub><mi>r</mi><mn>2</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>r</mi><mi>N</mi></msub><mo
    stretchy="false" form="postfix">]</mo><mrow><mo stretchy="false" form="prefix">(</mo><mn>31</mn><mo
    stretchy="false" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">R
    = [r_1, r_2, ..., r_N]\qquad{(31)}</annotation></semantics>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <semantics><mrow><mi>R</mi><mo>=</mo><mo stretchy="false" form="prefix">[</mo><msub><mi>r</mi><mn>1</mn></msub><mo>,</mo><msub><mi>r</mi><mn>2</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mi>r</mi><mi>N</mi></msub><mo
    stretchy="false" form="postfix">]</mo><mrow><mo stretchy="false" form="prefix">(</mo><mn>31</mn><mo
    stretchy="false" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">R
    = [r_1, r_2, ..., r_N]\qquad{(31)}</annotation></semantics>
- en: Where <semantics><msub><mi>r</mi><mi>j</mi></msub><annotation encoding="application/x-tex">r_j</annotation></semantics>
    represents the reward for the j-th completion.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä¸­ï¼Œ<semantics><msub><mi>r</mi><mi>j</mi></msub><annotation encoding="application/x-tex">r_j</annotation></semantics>
    ä»£è¡¨ç¬¬ j ä¸ªè¡¥å…¨çš„å¥–åŠ±ã€‚
- en: 'Using the argmax method, we select the best completion for the prompt:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ argmax æ–¹æ³•ï¼Œæˆ‘ä»¬é€‰æ‹©æç¤ºçš„æœ€ä½³è¡¥å…¨ï¼š
- en: <semantics><mrow><mi>S</mi><mo stretchy="false" form="prefix">(</mo><mi>R</mi><mo
    stretchy="false" form="postfix">)</mo><mo>=</mo><mrow><mi mathvariant="normal">arg</mi><mo>â¡</mo></mrow><munder><mi
    mathvariant="normal">max</mi><mrow><mi>j</mi><mo>âˆˆ</mo><mo stretchy="false" form="prefix">[</mo><mn>1</mn><mo>,</mo><mi>N</mi><mo
    stretchy="false" form="postfix">]</mo></mrow></munder><msub><mi>r</mi><mi>j</mi></msub><mrow><mo
    stretchy="false" form="prefix">(</mo><mn>32</mn><mo stretchy="false" form="postfix">)</mo></mrow></mrow><annotation
    encoding="application/x-tex">S(R) = \arg\max_{j \in [1,N]} r_j\qquad{(32)}</annotation></semantics>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <semantics><mrow><mi>S</mi><mo stretchy="false" form="prefix">(</mo><mi>R</mi><mo
    stretchy="false" form="postfix">)</mo><mo>=</mo><mrow><mi mathvariant="normal">arg</mi><mo>â¡</mo></mrow><munder><mi
    mathvariant="normal">max</mi><mrow><mi>j</mi><mo>âˆˆ</mo><mo stretchy="false" form="prefix">[</mo><mn>1</mn><mo>,</mo><mi>N</mi><mo
    stretchy="false" form="postfix">]</mo></mrow></munder><msub><mi>r</mi><mi>j</mi></msub><mrow><mo
    stretchy="false" form="prefix">(</mo><mn>32</mn><mo stretchy="false" form="postfix">)</mo></mrow></mrow><annotation
    encoding="application/x-tex">S(R) = \arg\max_{j \in [1,N]} r_j\qquad{(32)}</annotation></semantics>
- en: Using the Top-K method with <semantics><mrow><mi>K</mi><mo>=</mo><mn>1</mn></mrow><annotation
    encoding="application/x-tex">K=1</annotation></semantics> reduces to the same
    method, which is common practice.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ Top-K æ–¹æ³•ï¼Œå…¶ä¸­ <semantics><mrow><mi>K</mi><mo>=</mo><mn>1</mn></mrow><annotation
    encoding="application/x-tex">K=1</annotation></semantics>ï¼Œç®€åŒ–ä¸ºç›¸åŒçš„æ–¹æ³•ï¼Œè¿™æ˜¯å¸¸è§çš„åšæ³•ã€‚
